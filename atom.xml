<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不是很懂</title>
  
  <subtitle>不是很懂你们程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://moeyui1.github.io/"/>
  <updated>2021-08-03T09:10:59.927Z</updated>
  <id>http://moeyui1.github.io/</id>
  
  <author>
    <name>moeyui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《高效能人士的七个习惯》读书分享</title>
    <link href="http://moeyui1.github.io/%E8%AF%BB%E4%B9%A6/84e4d9.html"/>
    <id>http://moeyui1.github.io/读书/84e4d9.html</id>
    <published>2021-07-27T12:57:46.000Z</published>
    <updated>2021-08-03T09:10:59.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvt4ik601j30sg0lcwi3.jpg" alt="image-20210727210159976"></p><p>《高效能人士的七个习惯》自从1989年出版以来，累计销量超过<strong>2500万册</strong>，在全球<strong>140个国家以40种语言</strong>发行。除了商业上的成功，也获得了极高的口碑赞誉，比如2011年美国时代杂志把本书列为“<strong>25本最有影响力的商业管理书籍</strong>”之一。</p><p>作者史蒂芬·柯维（Stephen R. Covey）是哈佛大学企业管理硕士，杨百翰大学博士。他是柯维领导中心的创始人，也是富兰克林柯维公司（Franklin Covey）的联合主席，曾协助众多企业、教育单位与政府机关培训领导人才。柯维在领导理论，家庭与人际关系，个人管理等领域久负盛名。</p><p>七个习惯的缘起就来自柯维博士解决自己生活中艰难问题的经历：他和夫人一生一共养育了9个子女，曾在2003年获得美国权威机构颁发的“国家优秀父亲大奖”。然而，像每对夫妇一样，他和夫人曾经在生活中面临着一些深刻而痛苦的问题，这些问题根本就没有办法举重若轻地轻易化解。他们通过改变思维方式，成功把自己一个学业吃力、各方面都不那么优秀的儿子，培养成一个在学业、社交和体育方面都取得了远超平均水平的发展——成为了几个学生团体的领导者，州一级的运动员，同时获得了优秀的学业成绩的孩子。更重要的是，他发展出了热情和真诚的人格，可以在人际关系中自信地交往。</p><p>柯维博士是如何想到“七个习惯”的呢？“不是我想出来的。”他在访谈中提到，“确实是我写的这本书，但是这些准则却是早在我之前就广为人知，”他说道，“<strong>这更像是自然法则。我只是把它们整合在一起，通过梳理分析，为人所用。</strong>”</p><p>书中精选柯维博士“七个习惯”的最核心思想和方法，为忙碌人士带来超价值的自我提升体验。用最少的时间，参透高效能人士的持续成功之路。柯维博士行文流畅，用丰富的事例形象化地诠释深刻的道理。本文将摘选其中精彩段落，结合笔者的感悟与读者分享，一睹《高效能人士的七个习惯》的真知灼见。</p><h1 id="二、概论"><a href="#二、概论" class="headerlink" title="二、概论"></a>二、概论</h1><h2 id="2-1-基本原则"><a href="#2-1-基本原则" class="headerlink" title="2.1 基本原则"></a>2.1 基本原则</h2><ol><li>为获得生活的长久成功，培养一个人独立、健全、富足的人格，其作用远远大于掌握某种特定的技巧；</li><li>生活中很多深刻而痛苦的问题，并没有轻松的捷径。想要解决问题，首先要有意愿和有勇气改变自己；</li><li>改变自己，首先要从改变自己的思维方式开始。如果我们不能改变头脑里的想法，最终也无法改变外部的真实世界。</li></ol><p>柯维博士把这些理念统称之为<strong>“由内而外”的改变</strong>，英语是<strong>Inside-out</strong>，是构成七个习惯的非常重要的基本原则。所谓由内而外，是指从改变自己的思维，修炼自己的内在人格开始，继而影响到外在环境和他人。而“由外而内”，就是指希望借助某种技巧，能够快速地扭转局面或者操控他人。特定的技巧也许能在短期取得成效，但是如果不是基于健全的人格和品格，一定没有办法取得长久的成功。</p><h3 id="2-1-1-思维转换"><a href="#2-1-1-思维转换" class="headerlink" title="2.1.1 思维转换"></a>2.1.1 思维转换</h3><p>“思维转换（Paradigm Shift）”一词由托马斯·库恩（Thomas Kuhn）在他的经典之作《科学革命的结构》（The Structure of Scientific Revolutions）一书中最先提出。库恩在书中阐释，科学研究的每一项重大突破，几乎都是首先打破传统，打破旧思维、旧模式才得以成功。</p><p>由内而外的起点是改变自己的思维，核心就是<strong>对自己思维的认识和改造</strong>。每个人都有自己的思维方式，人与人因为之前经历的不同，思维方式经常存在极大的差异。一个人成长的前提，就是愿意用现实来检验自己的思维，当发现当前思维的局限性时，愿意打碎旧的认知，采纳更为有效的新思维，这个过程就叫做<strong>思维的转换</strong>。</p><p>古埃及天文学家托勒密认为地球是宇宙的中心，但哥白尼主张太阳才是宇宙的中心，因而激起思维转换。尽管后者曾招致强烈反对与迫害，但转眼间，人类对宇宙万物的诠释完全改观。人类获得了更大的自由和能力，同时也对世界有了崭新的认识和感受。</p><p>如果我们只想让生活发生相对较小的变化，那么专注于自己的态度和行为即可，但是实质性的生活变化还是要靠思维的转换。</p><blockquote><p>梭罗（Thoreau）曾经说过：“一棵邪恶的大树，砍它枝叶千斧，不如砍它根基一斧。”行为和态度就是枝叶，思维方式就是根基，抓住根本才能让生活出现实质性的进展。</p></blockquote><h3 id="2-1-2-以原则为中心"><a href="#2-1-2-以原则为中心" class="headerlink" title="2.1.2 以原则为中心"></a>2.1.2 以原则为中心</h3><p>改变思维的目的是采纳更好的思维，紧接着的一个问题就是：<strong>什么是更好的思维呢</strong>？柯维博士认为是<strong>原则</strong>。</p><p>至于这些原则的真实性和影响力到底怎样，看看弗兰克·柯克（Frank Koch）在海军学院的杂志《过程》（Proceedings）中写到的思维转换经历就知道了。</p><blockquote><p>两艘演习战舰在阴沉的天气中航行了数日，我就在打头的那艘旗舰上当班。当时天色已晚，我站在舰桥上瞭望，浓重的雾气使得能见度极低，因此船长也留在舰桥上压阵。</p><p>入夜后不久，舰桥一侧的瞭望员忽然报告：“右舷位置有灯光。”</p><p>船长问他光线的移动方向，他回答：“正逼近我们。”这意味着我们可能相撞，后果不堪设想。</p><p>船长命令信号兵通知对方：“我们正迎面驶来，建议你转向20度。”</p><p>对方说：“建议你转向20度。”</p><p>船长说：“发信号，告诉他我是上校，命令他转向20度。”</p><p>对方回答：“我是二等水手，你最好转向20度。”</p><p>这时船长已勃然大怒，大叫道：“告诉他，这是战舰，让他转向20度。”</p><p>对方的信号传来：“这是灯塔。”</p><p>结果，我们改变了航道。</p></blockquote><p>原则如灯塔，是不容动摇的自然法则。大自然中存在着不变的规律和普遍的法则，不以人的意志为转移。比如宇宙中存在的万有引力，人类直到17世纪才通过牛顿用数学公式描述清楚。而自宇宙诞生起的上百亿年，万有引力就一直存在，它制约着宇宙中一切物体的运动。如果我们<strong>发现规律</strong>并<strong>遵从规律，就可以实现最大的自由。违背规律，就无法实现想要的结果</strong>。</p><blockquote><p> 人们可以自由选择行为，但不能自由选择结果，结果是由原则制约的。</p></blockquote><p>原则不同于实践。实践是特定的行为或活动，在某一情况下适用的实践未必能在另一种情况下适用。就好比父母不能将教育第一个孩子的方法照搬到第二个孩子身上。实践是个别的、具体的，而原则是深刻的、基本的和普遍的。原则适用于任何个人、婚姻、家庭以及公私机构。如果我们把原则内化为习惯，就能够用不同的实践方法应对任何局面。</p><p>原则不是价值观。一群盗匪可以有相同的价值观，但却违背了良善的原则。如果说原则是地域，那么价值观就是地图。唯有尊重正确原则，才能认清真相。</p><p>老子在《道德经》谈到了只有遵循“道”，<strong>循道而行</strong>，才能实现美好和谐的结果。孔子在《论语》中谈到“<strong>从心所欲，不逾矩</strong>”，意思就是不违背规律，就能实现随心所欲的自由。</p><h3 id="2-1-3-新的思想水平"><a href="#2-1-3-新的思想水平" class="headerlink" title="2.1.3 新的思想水平"></a>2.1.3 新的思想水平</h3><blockquote><p>爱因斯坦（Albert Einstein）曾说：“重大问题发生时，依我们当时的思想水平往往无法解决。”</p></blockquote><p>由上文，我们需要新的、更深层次的思想水平，即基于原则的思维方式，它能正确引导我们实现高效能，改善人际关系，解决深层问题。这种新的思想水平就是《高效能人士的七个习惯》要阐述的内容，它强调以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</p><blockquote><p>我们必不可停止探索，而一切探索的尽头，就是重回起点，并对起点有首次般的了解。——艾略特（T．S．Eliot）</p></blockquote><h2 id="2-2-习惯"><a href="#2-2-习惯" class="headerlink" title="2.2 习惯"></a>2.2 习惯</h2><p>本书将习惯(habit)定义为“<strong>知识</strong>”、“<strong>技巧</strong>”与“<strong>意愿</strong>”三者的混合体。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvt8x6w80j30u50u0752.jpg" alt=""></p><p>习惯对我们的生活有绝大的影响，因为它是一贯的。在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。</p><blockquote><p>人的行为总是一再重复。因此卓越不是单一的举动，而是习惯。    ——亚里斯多德(Aristotle),古希腊哲学家、文艺理论家</p></blockquote><p>七个习惯具体定义如下：</p><ul><li>习惯一：积极主动（BE PROACTIVE）</li><li>习惯二：以终为始（BEGIN WITH THE END IN MIND）</li><li>习惯三：要事第一（PUT FIRST THINGS FIRST）</li><li>习惯四：双赢思维（THINK WIN-WIN）</li><li>习惯五：知彼解己（SEEK FIRST TO UNDERSTAND,THEN TO BE UNDERSTOOD）</li><li>习惯六：统合综效（SYNERGIZE）</li><li>习惯七：不断更新（SHARPEN THE SAW）</li></ul><p>这七个习惯并非零落、分散的心理法则。它们符合成长规律，提供了开发个人和人际效能的渐进、连续和高度整合的方法，让我们依次经历“成熟模式”——由<strong>依赖</strong>到<strong>独立</strong>，再到<strong>互赖</strong>，不断进步。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvt9krj5dj30u00wb0tp.jpg" alt=""></p><ol><li>依赖（Dependence）期以“你”为核心——你照顾我；你为我的得失成败负责。</li><li>独立（Independence）期以“我”为核心——我可以做到；我可以负责；我可以靠自己；我有权选择。</li><li>互赖（Interdependence）期以“我们”为核心——我们可以做到；我们可以合作；我们可以融合彼此的智慧和能力，共创前程。</li></ol><p>简单来说，依赖期的人靠别人来实现愿望；独立期的人单枪匹马打天下；互赖期的人，群策群力实现最高成就。</p><h2 id="2-3-效能"><a href="#2-3-效能" class="headerlink" title="2.3 效能"></a>2.3 效能</h2><p>本书意欲介绍“高效能”人士的习惯，那么什么是效能？针对这些问题，柯维首先提出了<strong>“产出/产能平衡”（P/PC Balance）</strong>原则。</p><p>伊索寓言中有一则关于鹅生金蛋的故事，足以说明这个常遭违背的原则。</p><blockquote><p>一个穷困的农夫，有一天在他的鹅圈里发现一个闪闪发光的金蛋。开始他以为这是个恶作剧，正准备把金蛋扔掉的时候，他转念一想决定拿去验证一下。</p><p>结果鹅蛋竟然是纯金的！农民简直不敢相信自己会有这样的好运。第二天他越发怀疑，跑到鹅圈一看，还是和昨天一样。此后他每天早上一睁眼，就去鹅圈拿金蛋。不久他就成了富翁，一切都那么不可思议。</p><p>可是财富却使他变得贪婪又急躁，已无法满足于每天一个金蛋，于是他异想天开地把鹅宰杀，想将鹅肚子里的金蛋全部取出。谁知打开一看，鹅肚子里并没有金蛋。鹅死了，再也无法得到金蛋。而毁掉这一切的，正是农民自己。</p></blockquote><p>这则寓言中蕴含了一个自然法则，即效能的基本定义。许多人都用金蛋模式来看待效能，即产出越多，效能越高。而真正的效能应该包含两个要素：一是“产出”，即金蛋；二是“产能”——生产的资产或能力，即下金蛋的鹅。在生活中“重蛋轻鹅”的人，最终会连这个产金蛋的资产也保不住。反之，“重鹅轻蛋”的人，最后自己都可能会被活活饿死，更不用说鹅了。</p><p>所以，<strong>效能在于产出与产能的平衡</strong>。 P代表希望获得的产出，即金蛋；PC代表产能，即生产金蛋的资产或能力。</p><blockquote><p>在一次集体活动中有人问我：“怎样对付那些懒散、不称职的员工？”一位仁兄回答：“投几颗手榴弹！”有几个人颇附和这种霸权式的主张——“不好好干就走人。”</p><p>接着又有一个人问：“谁来收拾残局呢？”</p><p>“不会有残局。”</p><p>“那你怎么不这样对待顾客呢？‘不想买就滚蛋！’”</p><p>“那怎么行呢？”</p><p>“那这样对待员工就行吗？”</p><p>“因为他们是我雇来的。”</p><p>“原来如此。请问你的员工是否忠心耿耿？是否勤奋工作？人员流动率如何？”</p><p>“开什么玩笑？现在根本找不到得力助手，人人都想请假、兼职、跳槽，对公司毫不在乎。”</p></blockquote><p>像这种只重金蛋的态度和思维方式，实在难以激发员工的热情和潜能。短期的盈利底线固然重要，但却不应凌驾于一切之上。</p><p>效能的关键在于平衡。一味重视产出会导致糟糕的健康状况、耗损的机器设备、透支的银行存款或破裂的人际关系。而太过维护产能，就如同一个每天长跑三四个小时的人，宣称可以因此多活十年，却不知大好时光都在跑步中流逝。唯有在金蛋（产出）与鹅的健康和幸福（产能）之间取得平衡，才能实现真正的效能。虽然你常会因此面临两难选择，但这正是效能原则的精髓所在。</p><h1 id="3-七个习惯"><a href="#3-七个习惯" class="headerlink" title="3. 七个习惯"></a>3. 七个习惯</h1><h2 id="3-1-积极主动——个人愿景的原则"><a href="#3-1-积极主动——个人愿景的原则" class="headerlink" title="3.1 积极主动——个人愿景的原则"></a>3.1 积极主动——个人愿景的原则</h2><h3 id="3-1-1-刺激与回应"><a href="#3-1-1-刺激与回应" class="headerlink" title="3.1.1 刺激与回应"></a>3.1.1 刺激与回应</h3><blockquote><p>人性的本质是主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。</p></blockquote><p>时下盛行的社会观点认为，环境（conditioning）与条件（conditions）对我们起着决定性的作用。柯维博士不否认条件作用影响之大，但他不认为它是决定我们命运的主要因素。</p><p>柯维博士将这些被广泛接受用来解释人性的社会观点分为三类：</p><ul><li>基因决定论（Genetic Determinism）：认为人的本性是祖先遗传下来的。比如一个人的脾气不好，那是因为他先祖的DNA中就有坏脾气的因素，又借着基因被继承下来。</li><li>心理决定论（Psychic Determinism）：强调一个人的本性是由父母的言行决定的。比如你总是不敢在人前出头，每次犯错都内疚不已，那是与父母的教育方式和你的童年经历分不开的，因为你忘不了自己尚且稚嫩、柔弱和依赖他人时受到的心灵伤害，忘不了小时候因为表现欠佳而遭遇的惩罚、排斥和与人比较的感受。</li><li>环境决定论（Environmental Determinism）：主张环境决定人的本性。周遭的人与事，例如老板、配偶、叛逆期子女，或者经济状况乃至国家政策，都可能是影响因素。</li></ul><p>这三种理论都以“刺激-回应”为理论基础，柯维博士把这类比为心理学家巴普洛夫的狗。</p><blockquote><p>著名的心理学家巴甫洛夫用狗做了这样一个实验：每次给狗送食物以前打开红灯、响起铃声。这样经过一段时间以后，铃声一响或红灯一亮，狗就开始分泌唾液。这个实验用来形容一个人反应不经大脑思考，如对逻辑思辨的抗拒。</p></blockquote><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvtbc4e5ej31rm0e63yu.jpg" alt=""></p><p>这些“决定论”是否能清晰反映人类真正的本性呢？柯维博士在书中引用了奥地利著名的犹太神经与心理学家维克多弗兰克尔的故事。</p><blockquote><p>弗兰克尔是一位深受弗洛伊德心理学影响的决定论者。该学派认为一个人的幼年经历会造就他的品德和性格，进而决定他的一生。</p><p>身为犹太人，弗兰克尔曾在“二战”期间被关进纳粹德国的死亡集中营，其父母、妻子与兄弟都死于纳粹魔掌，只剩下一个妹妹。他本人也饱受凌辱，历尽酷刑，过着朝不保夕的生活。</p><p>有一天，他赤身独处于狭小的囚室，忽然有一种全新的感受，后来他称之为“人类终极的自由”。虽然纳粹能控制他的生存环境，摧残他的肉体，但他的自我意识却是独立的，能够超脱肉体的束缚，以旁观者的身份审视自己的遭遇。他可以决定外界刺激对自己的影响程度，或者说，在遭遇（刺激）与对遭遇的回应之间，他有选择回应方式的自由或能力。</p><p>这期间他设想了各式各样的状况，比如想象他从死亡营获释后，站在讲台上给学生讲授自己从这段痛苦遭遇中学得的宝贵教训，告诉他们如何用心灵的眼睛看待自己的经历。</p><p>凭着想象与记忆，他不断修炼心灵、头脑和道德的自律能力，将内心的自由种子培育得日益成熟，直到超脱纳粹的禁锢。对于物质环境，纳粹享有决定权和一定的自由，但是弗兰克尔享有更伟大的自由——他强大的内心力量可以帮助他实践自己的选择，超越纳粹的禁锢。这种力量感化了其他的囚犯，甚至狱卒，帮助狱友们在苦难中找到生命的意义，寻回自尊。</p></blockquote><p>在最恶劣的环境中，弗兰克尔运用人类独有的自我意识，发掘了人性最根本的原则，即在刺激与回应之间，人有<strong>选择的自由</strong>。选择的自由包括人类特有的四种天赋，包括<strong>自我意识</strong>（self-awareness）、<strong>想象力</strong>（Imagination）、<strong>良知</strong>（Conscience）和<strong>独立意志</strong>（Independent Will），这就是人类与动物的区别。人类独特的能力将我们与动物完全区分。对这些能力加以开发和锻炼，将会在不同程度上实现我们独具的人类潜能。在刺激与回应之间自由选择就是我们最大的能力。</p><p>“依赖”层次的人，在逆境中习惯指责他人和环境，把自己说成是受害者，<em>我被他害了，他逼我，没办法，环境太差了。</em>柯维博士在书中分析了这种思维的本质，就是：<strong>在面对不利局面时，急于免除自己在其中的责任</strong>。借着把所有责任推给他人，自己规避了承担责任的压力，获得了心理上暂时的舒适。“<em>这不管我的事</em>”。显然，长此以往，这种思维将对一个人的人际关系和工作能力造成巨大的负面影响，要付出沉重的代价。这就好比是吞食一种毒品，<strong>当下获得短暂的舒适和快感，但长远上却在毁灭神经系统和身体脏器。</strong></p><p>而积极主动应该怎么做呢？弗兰克尔在狱中发现了人性的这个基本原则：</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvtbc4e5ej31rm0e63yu.jpg" alt=""></p><p>同时，弗兰克尔还指出了人生的三种主要价值观：</p><ol><li>经验价值观（Experiential Value）：来自自身经历；</li><li>创造价值观（Creative Value）：源于个人独创；</li><li>态度价值观（Attitudinal Value）：即面临困境（如绝症）时的回应。</li></ol><p>这三种价值观中，境界最高的是态度价值观。</p><p>从这个角度讲，我们也可以在生活中每次经历负面事件时，当成一个训练自己主动积极的习惯的机会。这样不但可以培养更为健康的精神状态，更重要的是，有可能通过自己的努力使逆境发生转化。</p><h3 id="3-1-2-应对逆境"><a href="#3-1-2-应对逆境" class="headerlink" title="3.1.2 应对逆境"></a>3.1.2 应对逆境</h3><p>如何在逆境下培养积极主动的习惯呢？柯维博士给了两个建议：</p><h4 id="3-1-2-1-聆听自己的语言"><a href="#3-1-2-1-聆听自己的语言" class="headerlink" title="3.1.2.1 聆听自己的语言"></a>3.1.2.1 聆听自己的语言</h4><p>语言很重要，因为一方面一个人的<strong>语言模式暴露了思维习惯</strong>，另一方面，<strong>语言的改变反过来也可以促进思维习惯的改变</strong>，所以，培养积极的思维和行为可以从选择更为积极的语言模式开始。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvtd52jadj31hc0kc0ul.jpg" alt=""></p><blockquote><p>我曾碰到这么一位男士，他说：“你讲得很有道理，可是每个人的状况不同。我的婚姻真是让我忧心忡忡，我和太太已经失去了往日的感觉，我猜我们都已经不再爱对方了。该怎么办呢？”</p><p>“爱她。”我回答。</p><p>“我告诉过你，我已经没有那种感觉了。”</p><p>“那就去爱她。”</p><p>“你还没理解，我是说我已经没有了爱的感觉。”</p><p>“就是因为你已经没有了爱的感觉，所以才要去爱她。”</p><p>“可是没有爱，你让我怎么去爱呢？”</p><p>“老兄，爱是一个动词，爱的感觉是爱的行动所带来的成果，所以请你爱她，为她服务，为她牺牲，聆听她心里的话，设身处地为她着想，欣赏她，肯定她。你愿意吗？”</p><p>在所有进步的社会中，爱都是代表动作，但消极被动的人却把爱当作一种感觉。好莱坞式的电影就常灌输这种不必为爱负责的观念——因为爱只是感觉，没有感觉，便没有爱。事实上，任由感觉左右行为是不负责任的做法。</p><p>积极主动的人则以实际行动来表现爱。就像母亲忍受痛苦，把新生命带至人世，爱是牺牲奉献，不求回报。又好像父母爱护子女，无微不至，爱必须通过行动来实现，爱的感觉由此而生。</p></blockquote><p>东方禅宗的智慧中有一句话，上半句叫“<strong>心随境转则烦</strong>”，意思是如果一个人的在顺境就兴高采烈，逆境就沮丧抱怨，那么就会烦恼不已。在七个习惯的体系中这就是一种偏向被动地受制于环境的低效能的表现。下半句叫“<strong>境随心转则悦</strong>”，意思是不管环境或顺或逆，人都有自由选择自己的思维和语言。<strong>往往是首先改变了自己的思维，才最终将逆境转化为顺境，能够做到这点的人的精神也会更加平和喜悦。</strong>在七个习惯的体系中这就是主动选择对环境的回应的高效能的状态。</p><h4 id="3-1-2-2-关注圈和影响圈"><a href="#3-1-2-2-关注圈和影响圈" class="headerlink" title="3.1.2.2 关注圈和影响圈"></a>3.1.2.2 关注圈和影响圈</h4><p>每个人都有格外关注的问题，比如健康、子女、事业、工作、国债或核战争等等，这些都可以被归入“关注圈”（Circle of Concern），以区别于自己没有兴趣或不愿理会的事物。</p><p>关注圈内的事物，有些可以被掌控，有些则超出个人能力范围，前者可以被圈成一个较小的“影响圈”（Circle of Influence）。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvte1megkj30u00u9gm2.jpg" alt=""></p><p>积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvte9t1j3j30tu0tsmxp.jpg" alt=""></p><p>反之，消极被动的人则全神贯注于“关注圈”，紧盯他人弱点、环境问题以及超出个人能力范围的事不放，结果越来越怨天尤人，一味把自己当作受害者，并不断为自己的消极行为寻找借口。错误的焦点产生了消极能量，再加上对力所能及之事的忽略，就造成了影响圈日益缩小。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvteigwivj30to0tu0t9.jpg" alt=""></p><p>简单地讲，<strong>如果你把精力都花在了关注圈，也就是不断抱怨懊恼那些虽然你很在乎，但无法控制、也已经无法改变的事情上，就是一种消极的习惯</strong>。</p><p>比如一名职业篮球运动员会非常关注自己的身高，这就是他的关注圈。他渴望自己达到2米。但现实中他可能只有1米85。如果他每天在内心都对此事都懊恼不已，埋怨父母，埋怨基因，埋怨那些已经不可改变的事情，那么本来可以用在训练场上的时间就会在这些抱怨声中悄悄溜走，可以肯定地说这样的思维习惯必然无法带来成功的运动生涯。反之，如果运动员知道自己的身高并不是优势，他选择接受这个事实，然后把所有的精力都用到训练中（即影响圈），通过常年的自律和锻炼增强自己的力量、速度和技术，保持优异的身材和运动状态，在一定程度弥补自己身高的不足。这样，他更有可能在职业生涯中取得辉煌的成就。</p><p>通常来讲，<strong>别人对你的态度和行为就在关注圈，而我们自己的思维、语言和行为就是影响圈</strong>。那些自己可以直接或者间接控制的问题，永远应该是精力付出的焦点，有勇气去尝试之前未曾实施的方法，在不确定性中谋求进展，也坦然承担不确定性中的风险。对那些目前个人无法控制的问题，要尝试接纳，虽然这个过程可能会伴随着压力和痛苦，但我们总可以用独立意志选择看待问题的角度，营造更为平和的心境，这样也更有利于坚决地在影响圈中付出努力。</p><h2 id="3-2-以终为始——自我领导的原则"><a href="#3-2-以终为始——自我领导的原则" class="headerlink" title="3.2 以终为始——自我领导的原则"></a>3.2 以终为始——自我领导的原则</h2><p>阅读下面的内容时，请找个僻静的角落，抛开一切杂念，敞开心扉，跟着柯维博士走过这段心灵之旅。</p><blockquote><p>假设你正在前往殡仪馆的路上，去参加一位至亲的葬礼。你缓缓走进告别室，淡淡的花香伴随着肃穆的音乐。一路上你见到很多亲友熟悉的面孔，你能体会到他们痛失至亲的悲哀，也能回想起往日相聚的欢乐。</p><p>到达前厅，当你看向棺木时，你发现面对的竟然是你自己！是的，没有错，这就是你自己的葬礼，也许这发生在很久之后；也许，并不那么的遥远。 </p><p>今天，你的亲朋好友们从各地齐聚一堂，追述你的生平，表达对你的爱和感激。</p><p>一共有三位致辞的嘉宾，第一位是你的家庭成员，可能是你的配偶、子女、兄弟姐妹。第二位是你的好朋友，第三位是你工作和事业中的伙伴。</p><p>现在请仔细想想，你希望人们怎样描述你的一生呢？</p><p>在人们眼中你是个怎样的丈夫、妻子、父亲、母亲？又是个怎样的朋友和同事？你希望人们说你是个<strong>怎样的人呢</strong>？能提到你的哪些<strong>成就</strong>？因为你的存在给人们的生活带来了<strong>什么不同</strong>？</p></blockquote><h3 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h3><p>以终为始说明在做任何事之前，都要先认清方向。这样不但可以对目前处境了如指掌，而且不至于在追求目标的过程中误入歧途，白费工夫。毕竟人生旅途的岔路很多，一不小心就会走冤枉路。许多人拼命埋头苦干，到头来却发现追求成功的梯子搭错了墙，但是为时已晚，所以说忙碌的人未必出成果。在七个习惯中，“以终为始”的重点是：</p><blockquote><p>开始每一天的时候，在脑海里想一想在生命终点时你所希望的画面，并以此来指导生活中的所有事情。</p></blockquote><p>那么为什么非要谈到“<strong>生命终点</strong>”呢？毕竟这在全世界很多文化中都是最为禁忌的话题。原因就在于：只有当人们赤裸裸地面对生命终点时，才有可能彻底抛开来自外部的所有期待值，毫无顾忌地表达自己内心深处最渴望的东西。</p><p>这实际上是一种“<strong>向死而生</strong>”的人生哲学，日常生活中可能很少会遇到。那么有没有人真的在这样做呢？有的！史蒂夫·乔布斯在2005年美国斯坦福大学毕业典礼上的演讲《Stay Hungry, Stay Foolish》中这么说：</p><blockquote><p>“记住我即将死去”是我一生中遇到的最重要的箴言，它帮我做出了生命中重要的选择。因为几乎所有的事情, 包括所有外部的期待，所有的荣耀，所有的尴尬或失败,这些在死亡面前都会消失。留下的只有真正重要的。你有时候会陷入患得患失的迷局，“记住你即将死去”是我知道的保持清醒的最好方法。你本来就无可失去, 没有理由不去追随本心。”</p></blockquote><h3 id="3-2-2-原则"><a href="#3-2-2-原则" class="headerlink" title="3.2.2 原则"></a>3.2.2 原则</h3><h4 id="两次创造"><a href="#两次创造" class="headerlink" title="两次创造"></a>两次创造</h4><p>我们做任何事都是先在头脑中构思，即智力上的或第一次的创造（Mental/First Creation），然后付诸实践，即体力上的或第二次的创造（Physical/Second Creation）。</p><p>以软件开发工作为例，开发前需要有尽可能详细的需求分析、详细设计等文档，在编写这些文档时，开发者会在脑海中构思每一个细节。这些文档会成为设计的蓝图，有了这些文档，开发者才会按部就班地进行编程，整个开发过程将以蓝图为准绳。</p><p>“任何事物都是两次创造而成”是个客观原则，但“第一次的创造”未必都经过有意识的设计。有些人自我意识薄弱，不愿主动设计自己的生活，结果就让影响圈外的人或事控制了自己，其生活轨迹屈从于家庭、同事、朋友或环境的压力。如果说人生是一出戏，那么这些人的人生剧本就源于早年的经历、所接受的教育或外界条件的制约。自我意识、良知和想象力这些人类的独特天赋让我们能够审视各种第一次的创造，并掌控自己的那一部分，即自己撰写自己的剧本。换句话说，习惯一谈的是“你是创造者”，习惯二谈的是“第一次创造”。</p><h4 id="领导与管理"><a href="#领导与管理" class="headerlink" title="领导与管理"></a>领导与管理</h4><p>“以终为始”的另一个原则基础是自我领导，但领导（Leadership）不同于管理（Management）。领导是第一次的创造，必须先于管理；管理是第二次的创造，具体会在习惯三中谈到。领导与管理就好比思想与行为。管理关注基层，思考的是“怎样才能有效地把事情做好”；领导关注高层，思考的是“我想成就的是什么事业”。</p><p>想象一下，一群工人在丛林里清除矮灌木。他们是生产者，解决的是实际问题。管理者在他们后面拟定政策，引进技术，确定工作进度和补贴计划。领导者则爬上最高那棵树，巡视全貌，然后大声嚷道：“不是这块丛林！”</p><p>而忙碌的生产者和管理者会怎么回答呢？“别嚷啦，我们正干得起劲呢。”</p><p>很多个人、团队和企业都是这样埋头猛砍，却意识不到他们要砍的并非这片丛林。当今世界日新月异，更突出了有效领导的重要性。</p><h3 id="3-2-3-个人使命宣言"><a href="#3-2-3-个人使命宣言" class="headerlink" title="3.2.3 个人使命宣言"></a>3.2.3 个人使命宣言</h3><p>柯维博士认为，实践以终为始最为实际的方法就是“个人使命宣言”，即人生哲学或基本信念。你可以把个人使命宣言称为个人宪法。对于个人来说，基于正确原则的个人使命宣言也同样是评价一切的标准，成为我们以不变应万变的力量源泉。它既是做出任何关键抉择的基础，也是在千变万化的环境和情绪下做出日常决策的基础。</p><p>有了使命感，你就抓住了积极主动的实质，有了用以指导生活的愿景和价值观，并在这些根本指引的基础上设立长期和短期目标。使命感还有助于你制定基于正确原则的个人书面宪法，让你能够据此高效能地利用时间、精力和才能。</p><p>这个话题，我们可以先从生物进化论的角度看，其实每一种生物都带有一种天然的使命，那就是<strong>生存和繁衍</strong>。比如鲑鱼，也就是大马哈鱼，为了完成繁衍的使命，每年从太平洋海域开始几千公里的旅行，回到出生地产卵。在河流中要逆流而上，中途要跳过小瀑布，还要面对其他动物的捕食。在这个壮观的旅程中它们表现出了极大的勇气和力量。所以说使命激发力量，使命指引方向。</p><p>制订个人使命宣言必须从影响圈的核心开始。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvtft4406j30u00u5q3b.jpg" alt=""></p><ul><li>“安全感”（Security）　代表价值观、认同、情感的归属、自尊自重与拥有个人的基本能力。</li><li>“人生方向”（Guidance）　是“地图”和内心的准绳，人类以此为解释外界事物的理据以及决策与行为的原则和内在标准。</li><li>“智慧”（Wisdom）　是人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体。</li><li>“力量”（Power）　则指采取行动、达成目标的能力，它是做出抉择的关键性力量，也包括培育更有效的习惯以替代顽固旧习的能力。</li></ul><p>每个人都有自己的生活中心，柯维博士将常见的生活中心整理为表格。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvtgsndgxj312g0nggo8.jpg" alt=""></p><p>![image-20210727211407555](/Users/mengyikun/Library/Application Support/typora-user-images/image-20210727211407555.png)</p><p>而多数人的生活中心是以上某几种中心的混合体，依环境不同而有所变化。大多数人的生活受到多种因素的影响，可能今天以朋友为中心，明天又变为以配偶为中心。生活中心如此摇摆不定，情绪上难免起起落落，一会儿意气风发，一会儿颓唐沮丧；一会儿斗志昂扬，一会儿又落魄消沉。缺乏固定的人生方向，没有持久的智慧，也没有稳定的力量或自我评价。</p><p>柯维博士认为正确的生活中心应当是<strong>以正确原则为中心</strong>。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gsvthl3i7lj31360goq5i.jpg" alt=""></p><p>以永恒不变的原则作为生活中心，就能建立高效能的思维方式，也就能正确审视所有其他的生活中心。找到正确的生活中心才能制定正确的个人使命宣言。</p><p>弗兰克尔说：“我们是发现而不是发明自己的人生使命。”这么说的确再恰当不过了。凡是人都具备良知与理智，足以发现个人的特长与使命。制定个人使命宣言并非一蹴而就，而是必须经过深思熟虑，几经删改，才可以定案。其间可能耗费数周，甚至数月的时间，而且即使定案，仍须不时修正。因为随着物换星移，人的想法也会改变。但时间间隔通常都是以几年为单位，就好比一个国家的宪法一旦形成，绝对不会经常修订。</p><h2 id="3-3-要事第一——自我管理的原则"><a href="#3-3-要事第一——自我管理的原则" class="headerlink" title="3.3 要事第一——自我管理的原则"></a>3.3 要事第一——自我管理的原则</h2><p>在确定了人生方向后，就应该对自己进行有效的管理。要事第一，就是对习惯二以终为始的<strong>执行和坚持。</strong>习惯三是关于第二次的创造或者体力上的创造的习惯，是对前面两个习惯的实现、执行和自然流露。它要求我们运用独立意志努力实现一个目标，即以原则为基础安排人生。</p><p>生活中以下两种人很常见：</p><ul><li>有些人总是显得很忙乱，疲于应对生活中的各种危机和突发事件，就好像一个救火队员。从心理层面看，其实这种状态有微妙的激励作用：能把火扑灭的人通常会被关注和称赞，因为他们完成了极为重要的任务，甚至可能被视为“英雄”。但另外一方面，因为这些事情的紧急和突发，会让人处于高度的压力和紧张感中，<strong>虽然度过了危机，但已然筋疲力尽</strong>。长此以往，很可能内心焦虑，体力透支，甚至需要借助过度的娱乐或者药物才能缓解压力。所以这并不是一种“高效能”的状态。</li><li>另外一些人，则喜欢一直做琐碎的事情，甚至对<strong>不断地完成随时冒出来的琐碎事情上瘾</strong>。最终的结果往往是自己原来的计划不断被打乱，虽然看起来很忙碌，但并没有取得有价值的进展。就像柯维博士所说的：<strong>忙碌不等于成就</strong>。从心理层面看，这种状态也有一定的激励机制：人们喜欢表现出忙碌状态以得到内心的安全感，琐碎的事情往往容易很快完成，内心可以得到即时的满足感。此外，有相当一部分琐碎的事情是来自于别人的要求和干扰，如果一个人特别喜欢受人欢迎，于是来者不拒，也很容易陷入这种模式中。显然，这也不是一种“高效能”的状态。</li></ul><p>而“要事第一”的意思，就是<strong>去识别少数几个对自己真正重要的事情，并且能够在外界压力和干扰下，坚持主动优先完成，这样才更有可能实现自己的重要目标和个人使命。</strong></p><h3 id="3-3-1-时间管理矩阵"><a href="#3-3-1-时间管理矩阵" class="headerlink" title="3.3.1 时间管理矩阵"></a>3.3.1 时间管理矩阵</h3><p>从本质上看，我们对时间的使用方式不外乎以下四种。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsxmpxf5j1j31hc0rqdhx.jpg" alt=""></p><h3 id="3-3-2-反复出现的危机"><a href="#3-3-2-反复出现的危机" class="headerlink" title="3.3.2 反复出现的危机"></a>3.3.2 反复出现的危机</h3><p>很显然，我们无法清除所有的突发危机，因为很多时候这就是工作和生活的本质：比如，如果你的工作就是处理客户投诉，或者在医院急诊室工作，那么突发事件是我们无法控制和减少的。另一方面，如果我们仔细观察问题出现的规律和共性，很可能会发现，如果提前做一些预防性的工作，就能减少一部分危机的爆发，这样就能减少随之而来的压力和打扰。</p><p>举个例子，在软件开发工作中，有一段时间，软件某个功能的客诉显著增加，团队成员不得不加班加点忙于处理每一个紧急且重要的业务危机。但回过头来我们发现问题的根源在于外部依赖的变更导致软件的一个内部逻辑不再适用，这才导致源源不断的客诉。要彻底解决这个问题，就要在眼下紧急而又重要的客诉处理中抽调人力进行开发修复，这非常重要，但可能不是非做不可，“额外”做这个事只会让团队在短期内加更多的班，付出更多的精力。但是从整体来考虑，我们还是决定先进行开发修复，虽然短期会更辛苦，但长远来看这能让团队的工作状态更轻松，业绩产出更优秀。</p><p>这说明了“要事第一”的道理：<strong>在还不紧急的情况下主动去完成重要的事情，从长远讲将会带来更大的成功。</strong>马云在演讲中经常强调：“如果你的屋顶坏了，要在晴天的时候修屋顶。”如果拖延到雨天才被动去修屋顶，将会狼狈不堪，同时不得不付出多得多的经济成本。</p><p>在另外一些情况下，即使我们不能减少危机的发生，但也可以让危机爆发后的负面影响最小化。比如在一切平安时购买意外保险，在职业生涯中不断学习新的知识技能，万一遭遇裁员可以迅速找到新工作。做好这些虽然不能杜绝危机的发生，但是可以防止我们被危机降临时的巨大压力击垮。</p><p>另外一方面，从生活的经验中我们知道，如果一个人不得不长期承受过度的压力，那么度过危机后就会倾向于过度的释放和补偿，比如通宵打游戏、刷剧，或者酗酒和用药等。乃至一个表面上善于处理危机的“英雄”可能会突然崩溃。</p><p>所以，“要事第一”带来的另一个好处是：<strong>因为减少了危机和随之而来的巨大压力，一个人更有能够从成瘾性的行为中摆脱出来。实现一种更为可持续的健康模式。</strong></p><h3 id="3-3-3-别被琐事打扰"><a href="#3-3-3-别被琐事打扰" class="headerlink" title="3.3.3 别被琐事打扰"></a>3.3.3 别被琐事打扰</h3><p>有一个女生在一家大企业做人力资源工作，她面临的一个问题是在她工作时间，不断有员工过来找她求助，以至于她自己的重要任务总是无法按计划完成，不得不加班或者拖延。在七个习惯的课堂上，她反思了自己的思维模式和心理倾向：她非常不善于拒绝别人的请求，导致承担了太多额外的琐碎事件，占据了过多的时间。再进一步的分析，<strong>她内心非常渴望受到别人的欢迎和认同，所以才无法恰当地表达拒绝</strong>，<strong>因为全盘答应别人可以换来最大的受欢迎程度</strong>。时间一长，甚至有人会形成习惯，依赖上她，把一些本来应该自己做的事情也甩给她来做。最终的结果，是她自己的效能降低，虽然忙碌但没有重要的成就。</p><p>这种不断被琐事打扰的现象也是习惯三“要事第一”要解决的问题。柯维博士提出了两种具体可行的人际技巧。</p><h4 id="勇敢说不"><a href="#勇敢说不" class="headerlink" title="勇敢说不"></a>勇敢说不</h4><p>从原因上看，如果一个人头脑中不清楚什么对自己是最重要的，在现实中就会缺乏勇气和独立意志，结果是更容易屈从于他人和环境的压力。这是处于“依赖”层次的低成熟度的表现。反过来，一个人越是能以终为始，明确什么是最重要的，就越有勇气和胆识做出舍弃和拒绝的决定。这就是乔布斯所说的“<strong>只有心中燃烧着熊熊的‘是’的火焰，才能坚定地对其他说‘不’</strong>”。这是处于“独立”层次的高成熟度的表现。</p><p>在《乔布斯传》中，记载了1998年，在阔别苹果公司13年后，乔布斯重新担任CEO的情景。如果说今天的苹果公司是巨人，那时候就是个瘦弱的矮人，技术实力和财务实力都很有限。乔布斯很清楚，只有集中资源做出爆品，才有可能让苹果起死回生。他发现那时公司在并行开发着十几个产品，经过慎重的思考，乔布斯认为音乐播放器是当时最有前景的产品领域，于是他做出重大决定，关停大部分的产品线，集中精力开发少数几个产品。这在公司内部引起了巨大争议，但得益于乔布斯本人的强悍作风，最终诞生了后来风靡全球的iPod 产品，这成为苹果浴火重生并延续十多年辉煌业绩的起点。</p><p>当然，在这里我们的重点不是鼓吹强悍的个人作风，因为<strong>粗暴的拒绝可以说是摧毁人际关系的核武器</strong>。我们真正想说的是，高效能的人有独立意志，必要时有勇气说不，同时又能保持、甚至增进人际关系的信任。</p><h4 id="适当授权"><a href="#适当授权" class="headerlink" title="适当授权"></a>适当授权</h4><p>而实现这种平衡，“适当授权”就是一项关键技巧。</p><p>授权，简单讲，就是虽然我没有时间做一件事，但我可以安排另外一个人来做。一方面，这可以把对自己没那么重要的事情分散出去，另一方面，对于被授权的一方来说，考虑到经验和能力的差异，对他们这反而可能是个很好的锻炼机会。本质上，<strong>授权是一种信任的传递</strong>，授权可以促成一种“双赢”的局面，对一方减少了琐事的打扰，对另一方提供了成长的机会。</p><p>如果你是团队的领导或者孩子的家长，更有条件体会到授权对于提升效能和促进双赢的影响。</p><p>授权是事必躬亲与管理之间的最大分野。事必躬亲者凡事不假外求。不放心子女、宁可自己洗碗的父母，自绘蓝图的建筑师或自己打字的执行秘书，都属于这一类。反之，管理者注重建立制度，然后汇集群力共同完成工作。比如分派子女洗碗的父母，领导一群设计人员的建筑师，或监督其他秘书与行政人员的执行秘书。</p><p>在书中，柯维博士还详细区分了“指令授权”和“责任授权”，责任授权能够让双方都受益，并最终能够使善于分配工作的人用很少的时间做成很多的事情。</p><h2 id="3-4-双赢思维——人际领导的原则"><a href="#3-4-双赢思维——人际领导的原则" class="headerlink" title="3.4 双赢思维——人际领导的原则"></a>3.4 双赢思维——人际领导的原则</h2><p>习惯四、五、六都能帮助我们建立和维系高质量的人际关系。双赢思维，来自英文 Think Win-Win，直翻就是<strong>以双赢的方式思考</strong>。思考解决人际关系中问题的方法。</p><p>每个人在试图解决人际关系中的矛盾冲突时，都有自己相对固定的思维方式和行为习惯。</p><h3 id="3-4-1-赢输思维"><a href="#3-4-1-赢输思维" class="headerlink" title="3.4.1 赢输思维"></a>3.4.1 赢输思维</h3><p>最常见的处理人际关系的思维方式就叫做<strong>赢/输，也就是“我要赢你必须输</strong>”，或者“我的获益是以你的损失为代价的”。当我们在关系中身处强势地位，拥有更优越的资源和选择权时，更容易运用这种方式。比如，上级对下级，客户对供应商，家长对孩子。赢/输思维引发的行为是向对方施加压力和威胁，以快速达到自己的目的。</p><p>在纯竞争性的场合下，“赢输”思维有适用的空间。比如运动员比赛，冠军只有一个，每个人都想要。比如金融市场中的期货交易，获益方是以损失方为代价的。有时候我们又把这类场景叫做“<strong>零和游戏</strong>”，就是加起来的总量等于零，所以有正必然就有负。</p><p>然而，<strong>生活中只有极少数的场合是纯粹的零和游戏</strong>，大多数的人际关系是长期的、相互依赖的关系，关系中往往既有竞争性，也有合作性。在这种关系下，如果强势方总是用赢输思维来处理关系，确实有可能在当下逼迫弱势一方就范，但在这个过程中，也在关系中积累了不满、怨恨，甚至仇恨。长此以往，可能导致关系的破裂，而这个结果并不符合强势方自己的利益。比如，家长不断地呵斥责骂孩子，孩子没有其他选择只能忍气吞声和顺从。直到某个时间，比如进入青春期，孩子开始反叛，离家出走，甚至跳楼。面对这个结果家长痛不欲生，但事情的结果已无法挽回。这样的社会新闻几乎每隔几天就能看到。</p><p>所以，即使我们在人际关系中处于强势地位，如果我们希望这段关系长久，在乎这段关系的质量，那么我们就要谨慎评估“赢输”思维是不是最佳选择。说到底，<strong>这是一种在达到自己的当前目的和维系住长期关系之间的一种平衡</strong>。现实世界中的因果关系往往有很明显的滞后性，人们通常看不到自己的行为可能带来的长期后果，这是很值得我们警惕的现象。</p><h3 id="3-4-2-输赢思维"><a href="#3-4-2-输赢思维" class="headerlink" title="3.4.2 输赢思维"></a>3.4.2 输赢思维</h3><p>另外一种和“赢/输”相反的思维是“<strong>输/赢”，也就是我输你赢</strong>，“我愿意放弃我的利益以成全你”。这种思维导致的行为是不敢坚持自己的主张，没勇气表达自己的感受，在对方的威胁下轻易地退让和妥协。在人际关系中的弱势方经常会采用这种方式，究其原因，是因为希望讨好对方，通过妥协得到对方的接纳。这种现象通常不像“赢输”那样常见，但在生活中也有实例：比如为了追求配偶或者讨好配偶而忍气吞声，比如销售人员为了保住客户而无底线地退让。</p><p>所以，如果我们习惯用“输赢”的方式通过讨好对方来得到接纳，也要仔细权衡短期的结果和长期的代价，反思这是否是自己真正想要的状态</p><p>可以看到，赢输和输赢思维各有短期的好处，但也都有明显的局限性。事实上，如果我们的成熟度不够高，内心缺乏安全感，<strong>我们可能在这两种模式中反复震荡</strong>。比如一开始用赢输的方式威胁压迫对方，如果不能得到结果，或者是因为在这个过程中自己内心积累的内疚感，又马上切换成了输赢的模式，希望通过乞求怜悯的方式达成一致。如果还不能实现，心中的挫折感和愤怒又占了上风，我们瞬间又回到了赢输的强悍状态中。这种行为的不一致性难以赢得别人的信任，也无法维系牢固的人际关系。</p><h3 id="3-4-3-双赢思维"><a href="#3-4-3-双赢思维" class="headerlink" title="3.4.3 双赢思维"></a>3.4.3 双赢思维</h3><p>意识到这些局限性，我们就容易理解双赢思维的本质意义：生活中的绝大多数人际关系并不是纯粹的零和游戏，而是一种相互依赖的游戏。<strong>双赢思维就是在这种互赖的关系中，永远谋求共同利益的处世之道，而不是简单地用“我赢”或者“你赢”这样的二分法来处理关系</strong>。</p><p>自从2007年第一代iPhone发布以来，苹果公司和App开发者的关系也是一个典型的双赢。乔布斯当年慷慨地把收入分成定为三七开，苹果公司只拿30%的收入。这样的制度极大激发了全球应用开发者的积极性，随着App的数量和质量的急剧提升，iPhone和iOS生态系统也迅速占领全球市场，最终是开发者获得了可观的收入，苹果公司为了地球上最赚钱和最值钱的公司。这是一个相互成就的双赢结果。</p><p>苹果公司相对于个体开发者，当然是绝对的强势地位。当年苹果完全有权力把政策定成七三开，公司拿70%，甚至90%。那样的话就是一种“赢/输”思维，在初期能给苹果公司带来更多的现金流。但我们可以想象，按照这个轨迹，十几年后的今天，开发者只能获得极为有限的收入，iOS 系统和苹果公司也绝不会像今天这样强大。这是一个相互制约的<strong>双输结果</strong>。所以，我们再次看到这个结论，即使是关系中的强势者，长远讲，双赢思维也要强于赢输思维，<strong>因为最终能给自己带来更大的收益</strong>。</p><h4 id="3-4-3-1-不可替代价值"><a href="#3-4-3-1-不可替代价值" class="headerlink" title="3.4.3.1 不可替代价值"></a>3.4.3.1 不可替代价值</h4><p>要想实现双赢，有一个重要的先决条件，那就是赢得对方的信任。</p><p>而信任取决于两个因素，品德和能力。品德的作用很明显，如果你不诚信，没有人愿意和你建立合作关系。但只有端正的品德并不足够，能力的作用在这里很重要：弱势一方，应该站在对方的立场上，仔细理解对方的需求，<strong>努力寻找自己可以为对方提供哪些不可替代的价值</strong>。对方对你越有依赖性，就越有双赢的机会。如果发现了这些价值，即使我们地位卑微，也应该有勇气大胆阐明自己的价值和主张。回到习惯一主动积极中的观点，我们无法控制别人，但永远可以努力做好自己<strong>影响圈</strong>之内的事情。</p><blockquote><p>再拿苹果公司举例，上次我们说过乔布斯1998年回到苹果做CEO，发现公司财务状况极差，如果不能及时融资，现金流有可能断裂，公司会倒闭。摆在二进宫的CEO面前的第一个难题就是：去哪里能快速融到巨额资金？</p><p>熟悉IT行业历史的朋友可能知道，那个年代，在个人电脑和操作系统市场上，微软公司和苹果公司是一对冤家。当时微软的实力比苹果强很多，但年轻气盛的乔布斯多次指责微软公司盗窃了苹果的视窗操作系统，在应用软件上双方也是直接竞争的关系。看起来，这两家公司是势不两立，你死我活的宿敌……然而，最后给苹果融资的居然是微软公司！为什么呢？ </p><p>乔布斯仔细分析了现状，微软公司在个人电脑领域是无可争议的霸主，<strong>如此强大的微软，是否在某些方面要依赖苹果呢</strong>？多年以来，微软在操作系统和办公软件上一支独大，经历了多次政府的反垄断调查，苹果虽然弱小，但基本是微软唯一的竞争对手。如果苹果公司倒闭，微软实际上就坐牢了市场垄断地位。按照美国政府的《反垄断法》，被判为垄断的公司，将面临着被强行拆分的命运。而这是比尔盖茨最不愿意看到的。 </p><p>所以，微软实际上需要苹果继续存在，才能够让自己保持完整。这就是我们说的，相互依赖性就是双赢关系的基础。最终，比尔盖茨决定注资1.5亿美元，帮助苹果度过了生死难关。达成交易后，乔布斯本人也说:“我们希望摒弃这样一种观念，即苹果要赢，微软就得输。”</p></blockquote><p>在这个有趣的故事中，我们可以看到：弱势的一方，不一定只能接受逆来顺受的宿命，这种匮乏的心态非常不利于发现现实中隐藏的机会。</p><h4 id="3-4-3-2-看透表面"><a href="#3-4-3-2-看透表面" class="headerlink" title="3.4.3.2 看透表面"></a>3.4.3.2 看透表面</h4><p>透过上面的故事还可以看到，<strong>一些表面上看起来是纯粹竞争的关系，从更大的范围上看往往存在合作和共生的关系</strong>。比如，就算是职业运动员，场上每个人全力取胜，但场下往往是惺惺相惜。因为正是有了这些高水平的对手，自己的水平才能不断提升，才会有更多观众买票来支撑这个行业的存在。中国乒乓球独步天下，但拿下所有的世界冠军未必是件好事，因为一旦其他国家不再投入，这个竞技项目的吸引力就会大打折扣，甚至无法再列为奥运项目，而这绝不是我们国家希望看到的。在商业中，几家供应商平时是竞争的关系，但遇到一些超大型的复杂项目，任何一家都无法独揽，只有联合起来才能满足客户的需求。这些都说明了现实中互赖关系的普遍性，同时也给双赢思维的运用提供了广阔和肥沃的土壤。</p><h4 id="3-4-3-3-不成交"><a href="#3-4-3-3-不成交" class="headerlink" title="3.4.3.3 不成交"></a>3.4.3.3 不成交</h4><p>双赢思维还有一种表现形式，“不成交”。意思是如果经过分析，认为无法找到一个兼顾双方利益的方案，那可以选择暂时不建立关系。虽然我们失去了当下一个成交机会，但避免了日后因无法满足期待值而导致关系破裂的风险。只要双方的信任关系尚且存在，就可以在未来繁殖出很多新的机会。</p><p>举个典型的例子，一个销售人员评估客户的需求后，发现自己的产品并不是最合适的方案。但客户并不完全了解市场行情，如果强力推销，也能够成交。如果强行成交，虽然赚到这笔钱，然而，一旦客户发现真实情况，就不会再信任销售，双方关系破裂甚至对簿公堂。而“不成交”，就是在这个时刻跟客户阐明原因，给客户诚恳的建议，然后选择退出交易。这样的确失去了一单生意，但信任关系反而会加强，长远讲带来的收益很可能会更大。很多做大客户业务的客户经理都有过这样的实际感受。</p><p>在中间件的业务接入中也是一样的道理，如果强行接入不合适的业务场景，也会为日后的运营埋下隐患，甚至失去业务的信任。而跟业务阐明原因，选择“不成交”，有时却能获得业务的信任，建立良好的口碑，同时也保证了服务的质量。</p><p>无论是双赢还是不成交，都再次说明了这个重要的道理：<strong>在一个相互依赖的系统中，满足对方的利益会最终使自己受益，人际关系不断加强，这是高效能的体现。相反地，损人利己的方式虽然得到当下的好处，但最终让自己遭受巨大的损失，是一种低成熟度的表现。简单讲，在互赖的人际关系中，如果不能维系住双赢的状态，最后的状态就将堕落为双输。这正是双赢思维的现实意义。</strong></p><h2 id="3-5-知彼解己——移情沟通的原则"><a href="#3-5-知彼解己——移情沟通的原则" class="headerlink" title="3.5 知彼解己——移情沟通的原则"></a>3.5 知彼解己——移情沟通的原则</h2><p>知彼解己的英文原文是 Seek first to understand, then to be understood，直接翻译是：<strong>首先寻求理解他人，然后再让别人理解自己。“知彼”就是“先理解别人”，“解己”就是“再让别人理解自己”。</strong></p><p>常见的现象是，当人际之间出现分歧和冲突时，每个人都本能性地保护自己的利益，为自己辩解。导致的现象是每个人都争着讲话，甚至打断别人，希望用反复强调和更大的嗓门来让对方“<strong>听进去</strong>”。然而，现实的结果恰恰是“<strong>听不进去”</strong>，如果我们被别人抢了话，虽然出于礼貌在听，但实际上是在忍耐的煎熬中听，对方在讲什么并不重要，我只想你讲完后该我讲了。</p><p>这样，虽然双方在激烈地对话，但实际上没有人“听进去”。因为都没有听进去，所以也没有人被说服。打个比方，这就好比我很想把我瓶子里的水倒进你的瓶子里，但你的瓶子的盖子没有打开，不管我倒得多么汹涌，你还是滴水未进。最终问题还是没法解决，对话不欢而散。时间长了，双方都逐渐形成了对方的负面认知，人际关系因此变得紧张而疏远。</p><p>造成这种现象的一个主要原因，<strong>就是每个人在内心都可能有一种倾向：就是这个世界上的观点只有“我的”和“错误的”这两类。</strong>对方的观点和诉求是谬误，所以不值得一听。</p><blockquote><p>在历史上阿拉伯国家和犹太民族有诸多矛盾，其中埃及曾经和以色列进行过五次中东战争。埃及作为战败一方，自己的领土西奈半岛曾经被以色列占领过十几年。在1978年，双方开始就西奈半岛的归还展开谈判。埃及的要求非常明确，立刻归还，因为几千年来西奈半岛就是埃及的领土。但以色列一开始只同意归还部分领土，要求保留部分接壤的领土。</p><p>埃及感到愤怒，因为这是对国家主权的不尊重，双方关系趋于紧张。在协调方的斡旋下，埃及的代表愿意摆脱情绪的控制，花时间了解以色列的想法和顾虑。以色列并不否认埃及对西奈半岛的所属权，也愿意尊重埃及的主权。然而，以色列的担心是一旦归还，埃及可以在和两国接壤的领土布置重型武器，一旦展开报复行动，以色列的国土将极为危险。原来以色列并非想继续霸占别国的领土，而是担心自己的国家安全受到威胁。</p><p>在理解了以色列的顾虑以后，埃及也表达了自己的承诺，不会发动类似的攻击。在兼顾双方的诉求后，最终达成了协议：西奈半岛的主权全部归还埃及，埃及拥有完整的行政管理权。另一方面，在两国接壤的200余公里的边界线上，埃及只能部署几百名装备轻武器的士兵，以照顾以色列的顾虑。这就是历史上著名的《戴维营协议》，直到40年后的今天仍然有着深远的影响。</p></blockquote><p>从上述事例我们可以看到：“知彼”有助于化解分歧，达成一致。如果双方互相斗狠，互相威胁，最终将会是双输的结局。</p><h3 id="3-5-1-同理心（Empathy）聆听"><a href="#3-5-1-同理心（Empathy）聆听" class="headerlink" title="3.5.1 同理心（Empathy）聆听"></a>3.5.1 同理心（Empathy）聆听</h3><p>沟通是生活中最重要的技能。人们在清醒时的大多数时间都在交流。但是从小到大，我们接受的教育多偏向读写的训练，说也占其中一部分，可是从来没有人教导我们如何去听。然而听懂别人说话，尤其是从对方的立场去聆听，实在不是件容易事。接受过倾听训练的人少之又少，多数训练是关于个人魅力的，这样反而妨碍了建立真正理解他人最需要的性格、交往基础。</p><p>我们的聆听一般分为五个层次：</p><ol><li>充耳不闻，压根不听别人说话；</li><li>装模作样，敷衍、打哈哈；</li><li>选择性接收，只听一部分；</li><li>聚精会神，努力听到每一个字；</li><li>同理心聆听，以理解为目的的聆听，要求听者站在说话者的角度理解他们的思维方式和感受。</li></ol><p><strong>同理心倾听的目的是理解，而不是表达不同意或者同意。</strong>特别当对方处于情绪激动的状态时，同理心倾听还应当表现出我们注意到了对方的情绪，比如“<em>看起来你对这件事感到最愤怒</em>”，这相当于是给了对方“心理空气”，有助于缓和激动的情绪。</p><p>应用“知彼解己”的另一个典型场景就是父母与孩子的沟通。父母通常没有耐心听孩子的想法，而是根据自己的人生经验，判断孩子年幼无知，想让孩子闭上嘴听自己的。当然，年幼的孩子的头脑和见识当然比不过父母，不过如果随意否定孩子的想法，会让孩子关闭内心的大门，让自己跟父母对立起来。同时，因为没有花时间充分沟通，孩子也很难对父母的观点心悦诚服。</p><p>移情聆听是有风险的。只有当你做好了被对方影响的准备，才能深入到移情聆听的阶段，而这是需要足够的安全感的，因为这时候的你会变得很脆弱。从某种意义上说，这很矛盾，因为在影响对方之前，你必须先被影响，即真正理解对方。所以说习惯一、二和三是基础，帮你保持核心不变，即以原则为中心，从而平和而有力地应对坚实内心之外的脆弱。</p><h3 id="3-5-2-表达也要讲技巧"><a href="#3-5-2-表达也要讲技巧" class="headerlink" title="3.5.2 表达也要讲技巧"></a>3.5.2 表达也要讲技巧</h3><p>了解别人固然重要，但我们也有义务让自己被人了解，这通常需要相当的勇气。古希腊人有一种很经典的哲学观点，即<strong>品德第一，感情第二，理性第三</strong>。这三个词集中体现了让他人理解自己以及有效表达自己的精髓。</p><ul><li>品德指的是你个人的可信度，是人们对你的诚信和能力的认可，是人们对你的信任。</li><li>感情指的是你的移情能力，是感性的，说明你能通过交流迅速理解他人的情感。</li><li>理性是你的逻辑能力，即合理表达自己的能力。</li></ul><p>请注意这个顺序：品德、感情、理性。首先是你本身的品德，然后是你同他人的关系，最后是你表达自己的能力，这是另外一种重要的模式转换。多数人习惯直接用左脑逻辑表达自己，意图说服别人，却从来没把品德第一、感情第二放在心上。</p><blockquote><p>有天他告诉我：“史蒂芬，我申请研究基金的事毫无成果，因为我的研究不是学院的主要方向。”</p><p>详细地分析了他的处境后，我希望他能按照品德、感情、理性的顺序重新准备一下实验介绍。我告诉他：“我明白你很真诚，研究确实能带来好处。只是你要描述一下实验能产生的相关效应和优势。让他们明白你确实对此有深入研究，而且要清晰地表述要求背后的逻辑。”</p><p>他欣然同意，并且愿意和我一起按照这个方式事先演练一下。</p><p>介绍的开头，他首先表达已经了解对方的目标以及关于这个实验的担忧，提出自己的建议。</p><p>他慢慢地逐步深入。介绍进行到一半，他表达了自己清晰的思路，并尊重对方的观点。一位教授向另一位教授点点头，告诉他基金申请获得批准。</p></blockquote><p>表达自己并非自吹自擂，而是根据对他人的了解来诉说自己的意见，有时候甚至会改变初衷。因为在了解别人的过程中，你也会产生新的见解。</p><h2 id="3-6-统合综效——创造性合作的原则"><a href="#3-6-统合综效——创造性合作的原则" class="headerlink" title="3.6 统合综效——创造性合作的原则"></a>3.6 统合综效——创造性合作的原则</h2><p>如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。<strong>与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。</strong></p><p>从个人效能的角度，统合综效基于这样的原则：人与人是有差异的，每个人都有自己的优势和弱势。<strong>认知上每个人都有盲点，能力上每个人都有短板。成为一个全能的人是不现实的，对于我们每个人的最弱项来讲，可能付出极大的努力也很难达到平均的水平</strong>。</p><p>一种更高效能的思路是：清晰地意识到我们最突出的优势和弱势，然后主动去寻找可以跟自己互补的对象，建立和经营一个相互依赖的系统，这个系统将发挥出统合综效的效果，实现比“孤家寡人”远远优越的结果，也就是1+1&gt;2。</p><p>自然界到处都有统合综效的影子。如果你把两棵植物种得很近，它们的根就会缠绕在一起，土壤质量就会提高，两棵植物都能比被分开时更加茁壮地成长。叠放在一起的两块木片所能承受的重量大于叠放前分别承受的重量之和。</p><p>在《乔布斯传》中，乔布斯有一个非常重要的合伙人，叫沃兹尼亚克。大家现在对乔布斯的印象可能是技术天才，但是如果仔细看那段历史，会发现他最擅长的并不是技术。那时候他们两个人各司其职，沃兹尼亚克用今天的话讲就是个极客，精通硬件软件。但他生性羞涩内敛，并不擅长与人交往。而乔布斯，虽然也有不错的技术功底，但真正的强项却是商业敏感度和影响他人。传记中记载了当年乔布斯单枪匹马跟大公司谈判，拿回来一个为一款硬件设计游戏的订单，但凭他自己的能力没法完成。沃兹可以编程，但他没有能力拿下订单。只有两人合作，各自才能挣到更多的钱。两人的这种合作关系一直延续了多年。设想如果沃兹当年想要变成杰出的商业高手，必然消耗大量的时间，自己擅长的技术可能也会荒废。而当他和乔布斯组成一个“共生系统”时，他用容易的多的方式取得了大得多的成功。</p><h3 id="3-6-1-统合综效沟通"><a href="#3-6-1-统合综效沟通" class="headerlink" title="3.6.1 统合综效沟通"></a>3.6.1 统合综效沟通</h3><p>所谓统合综效的沟通，是指敞开胸怀，接纳一切奇怪的想法，同时也贡献自己的见地。</p><p>柯维博士将沟通分为三个层次，下图揭示了信任度与沟通层次之间的联系：</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsxmrtuxspj31hc0n3q3x.jpg" alt=""></p><p>低层次的沟通源自低信任度，其特点是人与人之间互相提防，步步为营，经常借助法律说话，为情况恶化作打算，其结果只能是赢/输或者输/赢，而且毫无效率可言，即产出/产能不平衡，最后只能是让人们更有理由进行自我防御和保护。</p><p>中间一层是彼此尊重的交流方式，唯有相当成熟的人才办得到。但是为了避免冲突，双方都保持礼貌，但却不一定为对方设想。即使掌握了对方的意向，也不能了解背后的真正原因，也不可能完全开诚布公，探讨其余的选择路径。这种沟通层次在独立的，甚至在相互依赖的环境中尚有立足之地，但并不具创造性。妥协一般意味着1+1=1.5，双方有得有失，只是一种低级别的双赢。</p><p>那么统合综效的沟通具体应该怎么做呢？书中提到了以下两点。</p><h3 id="3-6-2-尊重差异"><a href="#3-6-2-尊重差异" class="headerlink" title="3.6.2 尊重差异"></a>3.6.2 尊重差异</h3><p>与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。</p><p>自以为是的人，总自认最客观，他人都有所偏颇，这正是画地为牢；反之，虚怀若谷的人能承认自己的不足，并乐于在与人交往中汲取丰富的知识见解，重视不同的意见，因而增广见闻。此所谓“三人行，必有我师焉”。子路曰“君子和而不同，小人同而不和”，我们在沟通中应当尊重差异。</p><p>差异非常可贵，与所见略同的人沟通，益处不大，要有分歧才有收获。当发现一个有能力的人的观点与我不同时，那么对方的主张必定有我还未能体会的奥妙，这时应该主动邀请对方阐明，然后再展开共同的探讨。这实际就是一个“知彼解己”的过程。</p><p>在乔布斯的例子中我们看到沃兹和乔布斯的差异，这种差异不需要抹除，反而对合作有益。乔布斯拿手的产品设计，也不是一个人在办公室冥思苦想，而是跟团队一起到一个僻静的地方，一起冥想之后，展开头脑风暴，在观点的交锋中寻找灵感。实际上，正是因为差异性和互补性，才使得一个团队或者系统格外的坚固。<strong>刻意消除差异反而无法形成真正的和谐</strong>。一个人总是有独立见解，虽然与别人不一样，但可以不断吸引别人进行交往。相反，人云亦云，唯唯诺诺，表面上避免了冲突，但实际上没创造价值，不能赢得别人深厚的信任。</p><h3 id="3-6-3-第三种选择"><a href="#3-6-3-第三种选择" class="headerlink" title="3.6.3 第三种选择"></a>3.6.3 第三种选择</h3><blockquote><p>一个父亲想利用暑假假期带全家去露营钓鱼，为此提前做了很多准备，两个儿子也极为兴奋。然而假期临近，妻子却有想法利用难得的假期去陪伴久病不愈的母亲。一场家庭争端即将触发。</p><p>面对分歧，丈夫和妻子有可能争吵和互相攻击，比如丈夫说 <em>母亲已经有妻子的妹妹在照顾，本来也计划过几个月过年时去看望母亲。妻子说不知道母亲还有多少时日在世上，陪伴母亲比钓鱼更重要。然后丈夫反驳说 老公和孩子也很重要……</em></p><p>当双方都开始攻击对方时，能量就会转为负面，关系也趋于紧张。 </p><p>另外的可能就是忍让和妥协，这实际就是为了避免直接冲突，一方或者双方不得不采用了“输赢”的思维。无论是丈夫还是妻子，放弃了自己的想法都会心有不甘。如果分开行动，夫妻心里都会有内疚感，也不会愉快。</p><p>而寻找第三种选择，就是在双赢思维和知彼解己这些原则的支持下，寻找可能的更好的方案。如果双方能在平静的状态下充分沟通，丈夫会发现妻子想减轻妹妹常年照顾母亲的负担，也的确担心没法见到母亲最后一面。妻子也发现丈夫为了让全家开心煞费苦心，特意去参加了钓鱼培训班和购买了专业的设备。</p><p>然后他们可以试着寻找第三条道路的可能性。</p><p>“也许在这个月找一周，家务请人代劳，其他由我负责，你就可以去看母亲。要不然，到距离母亲较近的地点去度假钓鱼也不错，甚至邀请附近的亲友一起度假，更有意思。”<br>虽然这些方法也不一定都可行，但是要好过简单的妥协和忍让。而且在商讨的过程中没有积累负面的情绪。就像柯维博士所说的，差异和分歧可能让人们产生隔膜，但也有可能让彼此更加亲近。因为在寻找第三选择的过程中，人们之间的相互信任和依赖会加强，这个过程也给原有的关系注入了新的活力。</p></blockquote><p>对第三选择的寻找是统合综效思维的重要应用。第三选择在开始时并不明显，而且人们在面对冲突时因为情绪的影响也可能失去了耐心和理性。寻找第三选择需要我们内心的富足心态，相信一定存在更好的方案。同时内心有足够的安全感和谦逊，把维护自我的虚荣置于追求更好的结果之下，把压制对方的冲动转化为同理心倾听。如果一个人面对压力能坚持这样做，并且引导人们找到解决问题的新方法，那么一定可以赢得他人的信任和尊重，实现更大的成功。</p><p>柯维博士在2011年，也就是他去世的前一年，出版了最新的著作the 3rd alternative, 《第3选择-解决所有难题的关键思维》详细阐述了运用统合综效的思想，以不同于妥协退让的方式解决生活中的难题的思想。建议大家作为习惯六的拓展阅读。</p><h2 id="3-7-习惯七：不断更新——平衡的自我提升原则"><a href="#3-7-习惯七：不断更新——平衡的自我提升原则" class="headerlink" title="3.7 习惯七：不断更新——平衡的自我提升原则"></a>3.7 习惯七：不断更新——平衡的自我提升原则</h2><p>最后一个习惯在模型图中环绕着其它六个习惯，因为正是习惯七让其它习惯成为可能。</p><p>不断更新的英文原文是 Sharpen the Saw，Saw 即锯子，这个短语的意思其实是磨锯子。它的寓意来自一个小故事：</p><blockquote><p>假使你在森林中看到一名伐木工人，为了锯一棵树已辛苦工作了５个小时，筋疲力竭却进展有限，你当然会建议他：“为什么不暂停几分钟，把锯子磨得更锋利？”对方却回答：“我没空，锯树都来不及，哪有时间磨锯子？”</p></blockquote><p>“不断更新”的意思就是当我们忙于追逐目标，或者为他人奉献自己时，千万不要忘了给自己加油充电，照顾好自己。每个人所拥有的最大资产就是自己，“不断更新”就是在漫长的人生中从四个方面维护好这项资产——<strong>身体，智力，精神和社会情感</strong>。这四个要素构成了一个完整的人，在这四个方面健全、平衡地投入时间发展，就是不断更新的含义。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gt3p9cyjj1j30yt0u00tj.jpg" alt=""></p><h3 id="3-7-1-身体层面"><a href="#3-7-1-身体层面" class="headerlink" title="3.7.1 身体层面"></a>3.7.1 身体层面</h3><p>身体层面指有效呵护我们的身体——健康饮食，充足休息以及定期锻炼。</p><p>还记得在习惯三中提到的时间管理矩阵吗？锻炼属于第二象限事务，但是由于不具紧急性，因此很少人能坚持不懈，结果终有一天我们会发现自己陷入了第一象限事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。</p><p>身体锻炼主要指以下三个方面：</p><ul><li><strong>耐力</strong>：源自有氧运动，也就是会大量摄入氧气的运动，这会增强心血管的供血能力。心脏上的肌肉组织是心肌，我们没办法像锻炼胳膊上的肱二头肌那样直接去锻炼心肌。只能通过身体大的肌肉群，特别是腿部肌肉来间接地锻炼心肌。所以像快走，慢跑，自行车，游泳等项目都非常有好处。</li><li><strong>柔韧性</strong>：来自于拉伸运动。在有氧运动之前拉伸可以给肌肉预热，防止受伤。之后拉伸可以排解肌肉中积累的乳酸，防止身体酸痛。</li><li><strong>力量</strong>：源于对肌肉的训练，比如俯卧撑，引体向上，或者举重等器械的练习。肌肉含量的增加能够提高身体的基础代谢率，从而让身体更好的新陈代谢，体重不容易失控，精神也会更好。</li></ul><h3 id="3-7-2-精神层面"><a href="#3-7-2-精神层面" class="headerlink" title="3.7.2 精神层面"></a>3.7.2 精神层面</h3><p>精神层面的自我更新是指明确自己的人生方向，让精神回归平和、充实的状态。在习惯二中，柯维博士提到了维克多弗兰克尔所主张的对精神疾病的<strong>意义疗法</strong>。精神层面的更新，就是指找到内心的<strong>意义感</strong>，避免意志的消沉和情绪的抑郁。</p><p>具体的做法是多种多样的，因为人与人在这方面的习惯可能差异极大。对有些人来讲就是每天花一点时间进行反思和冥想，就好像孔子所说的“吾日三省吾身”。柯维博士就会经常回顾自己写下的个人使命宣言，提醒自己什么是生活中最重要的事情，特别是感到迷茫和困惑的时候。还有些人从大自然中汲取精神能量，大自然会赐福给那些沉浸其中的人。</p><h3 id="3-7-3-智力层面"><a href="#3-7-3-智力层面" class="headerlink" title="3.7.3 智力层面"></a>3.7.3 智力层面</h3><p>多数人的智力发育和训练都是在学校中完成的，但是一旦离开学校，很多人的头脑就会退化。成年人智力的更新最主要的方式是通过阅读，根据人民日报公布的国民阅读调查，中国人在2018年的平均阅读量是4.67本书，美国的数字是9本，而日本达到了40本。习近平主席也曾多次谈到：要提倡多读书，建立书香社会。如果我们每个人都养成终生阅读的习惯，我们的社会也会成为更加高效能的社会。</p><p>柯维博士编写本书是在上世纪八十年代，当时的人们喜欢把时间花在看电视上，而他认为沉迷电视和肥皂剧是一种病态的依赖行为。现在电子信息越来越发达，智能手机、互联网、短视频的出现为生活带来了很多便利，层出不穷的娱乐内容也侵蚀了更多的个人时间。柯维博士提出“<strong>做技术的主人，不要做技术的奴隶</strong>”，我们应当利用好便利的技术不断进行智力层面的自我更新，而不是成为新技术的奴隶。</p><p>更新智力可以从两个方面着手：阅读和写作。</p><p>养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式，柯维博士强烈建议大家从每个月读一本书开始，养成阅读的习惯。在阅读的过程中，面对作者不同的观点，如果能实践习惯五（知彼解己）则会事半功倍。</p><p>写作是另一种有效的方式，正如读书写读书笔记，调研写调研文档，写作能帮助我们梳理思路，从读者的角度吃透所写的内容，帮助我们从“能理解”提升到“可复述”的新层次。</p><h3 id="3-7-4-社会-情感层面"><a href="#3-7-4-社会-情感层面" class="headerlink" title="3.7.4 社会/情感层面"></a>3.7.4 社会/情感层面</h3><p>前三点都是帮助我们从个人角度进行更新，最后一点则帮助我们从与人际关系的角度进行更新。</p><p>社会/情感层面的更新并不像其他层面的更新那样需要花费大量时间，我们可以在与他人的日常交往中完成这项工作。比如每天用积极肯定的语言跟孩子交流，比如对爱人的陪伴和交谈，经常用小礼物表达内心情感，拥抱和亲吻等等。用心维系好重要的情感关系，用心服务于他人，可以让我们自己的心情更舒畅，身体更健康，对生活有更高的满意度。</p><h3 id="3-7-5-螺旋式上升"><a href="#3-7-5-螺旋式上升" class="headerlink" title="3.7.5 螺旋式上升"></a>3.7.5 螺旋式上升</h3><p>自我提升和完善是一种原则，也是一个过程，一个在成长和转变之间螺旋式上升的过程，一个不断完善自我的过程。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gt3pasgtmjj314w0tqtak.jpg" alt=""></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>理解七个习惯的一个好方法就是看看它们的对立面。以下图表将高效能人士与低效能人士作了对比。</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gt3pb6zn8mj30u00uz419.jpg" alt=""></p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gt3pbfre25j30qy12s77h.jpg" alt=""></p><p>我们的生活会被父母、环境、条件等深深地影响。这些影响有些是积极的，有些是消极的。它们就好像是一段写好的程序，虽然我们看不到，但是这些程序每时每刻都在生活的后台运行，影响着我们的生命轨迹。而一个成熟的人，一个主动积极的人，有能力发挥人类的天赋，做出自由的选择，跳出那些传递到自己身上的消极的程序。这样的人，柯维先生称之为“<strong>转型人</strong>”。正如我们被父母所影响，我们的孩子也会被我们深深地影响，而这个过程无声无息潜移默化，甚至我们自己都意识不到。所以，我们的每一次成长，我们的每一个转变，都在影响着孩子和后代。<strong>自己成为转型人，让孩子也成为转型人，这也是每个高效能人士的使命。</strong>七个习惯是有关转变的理论。没有人能够靠劝说让别人真正转变，<strong>每个人的心中都守着一扇只能从内开启的变化之门。</strong></p><h1 id="5、FAQ"><a href="#5、FAQ" class="headerlink" title="5、FAQ"></a>5、FAQ</h1><p>以下FAQ节选自原书的“答读者问”一章。</p><h5 id="您个人认为哪个习惯最难以付诸实践？"><a href="#您个人认为哪个习惯最难以付诸实践？" class="headerlink" title="您个人认为哪个习惯最难以付诸实践？"></a>您个人认为哪个习惯最难以付诸实践？</h5><p>习惯五。当我筋疲力尽的时候，当我深信自己正确的时候，我真不想听别人说话，我甚至会假装聆听。从根本上说，我犯的就是我自己所说的那种错误——聆听的目的是做出回答，而不是去理解对方。事实上，从某种意义上讲，我几乎每天都要花费很大气力去实践所有七个习惯，我没有征服它们当中的任何一个，我认为它们是我们永远无法真正把握的人生原则，我们越是接近于把握它们，就越是意识到我们距离目标其实还相当遥远。你知道得越多，就会意识到自己不知道的更多——这是同样的道理。</p><p>正因为如此，我在大学里给学生打分时，有50％的分数是提问质量分，另外50％的分数是答案质量分。这样更能反映他们真实的知识水平。</p><h5 id="您是富兰克林柯维（FranklinCovey）的副总裁，富兰克林柯维（FranklinCovey）也遵循七个习惯吗？"><a href="#您是富兰克林柯维（FranklinCovey）的副总裁，富兰克林柯维（FranklinCovey）也遵循七个习惯吗？" class="headerlink" title="您是富兰克林柯维（FranklinCovey）的副总裁，富兰克林柯维（FranklinCovey）也遵循七个习惯吗？"></a>您是富兰克林柯维（FranklinCovey）的副总裁，富兰克林柯维（FranklinCovey）也遵循七个习惯吗？</h5><p>我们不断努力实践我们讲授的内容——这是我们最基本的价值观之一。不过，我们做得不够完美。如同其他企业一样，我们面临着挑战：一方面要应对不断变化的市场现实，另一方面要融合前柯维领导中心和富兰克林－奎斯特公司的两种文化。公司的合并是1997年夏天完成的，运用这些原则需要时间、耐心和毅力。成功与否的真正考验是长期性的，只言片语无法描述准确的情况。</p><p>每一架飞机都常常会偏离航线，但又不断回到正确航线上来，并最终抵达目的地。我们所有个人、家庭或组织也是一样，关键是“以终为始”，共同致力于经常性的反馈和线路调整。</p><h5 id="我的老板（配偶、子女、朋友等）确实需要七个习惯，您建议我怎样让他们阅读本书？"><a href="#我的老板（配偶、子女、朋友等）确实需要七个习惯，您建议我怎样让他们阅读本书？" class="headerlink" title="我的老板（配偶、子女、朋友等）确实需要七个习惯，您建议我怎样让他们阅读本书？"></a>我的老板（配偶、子女、朋友等）确实需要七个习惯，您建议我怎样让他们阅读本书？</h5><p>只有当他们知道你对他们有多关心时，他们才会关心你知道的有多多。请以可信赖的人格榜样为基础，和他们建立信任、坦诚的关系，然后和他们分享“七个习惯”对你的帮助。让他们在你的生活中看到鲜活的“七个习惯”，然后在适当的时候，邀请他们参加某个培训项目，或者把这本书作为礼物送给他们，或者在必要时教给他们一些基本理念。</p><h5 id="有些人声称自己掌握着真正的成功秘诀，您对此有何看法？"><a href="#有些人声称自己掌握着真正的成功秘诀，您对此有何看法？" class="headerlink" title="有些人声称自己掌握着真正的成功秘诀，您对此有何看法？"></a>有些人声称自己掌握着真正的成功秘诀，您对此有何看法？</h5><p>我要声明两点，首先，如果他们所说的内容以原则或自然法则为基础，我就愿意向他们求教，并且加以推介；其次，我要说，我们也许是在用不同的措辞表述相同的基本原则或自然法则。</p><h5 id="您真的谢顶吗？抑或是为了节省时间才剃了光头？"><a href="#您真的谢顶吗？抑或是为了节省时间才剃了光头？" class="headerlink" title="您真的谢顶吗？抑或是为了节省时间才剃了光头？"></a>您真的谢顶吗？抑或是为了节省时间才剃了光头？</h5><p>嘿，听我说，当你忙着吹干你的头发时，我已经在为顾客服务了。事实上，当我第一次听说“秃就是美”这句话时，我激动得无以名状！</p><h1 id="6、延伸"><a href="#6、延伸" class="headerlink" title="6、延伸"></a>6、延伸</h1><p>《高效能人士的七个习惯》电子版可以在微信读书阅读。</p>]]></content>
    
    <summary type="html">
    
      《高效能人士的七个习惯》是许多公司、团队的推荐书目，其中的许多理论也是当下各大“方法论”的基石。
    
    </summary>
    
      <category term="读书" scheme="http://moeyui1.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="方法论" scheme="http://moeyui1.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Go 开发经验总结</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/a1eba719.html"/>
    <id>http://moeyui1.github.io/开发/a1eba719.html</id>
    <published>2020-04-20T14:55:01.000Z</published>
    <updated>2021-02-08T10:12:18.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go 从 C 语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</p><p>Go 虽然拥有自动垃圾回收、一等函数、词法作用域、系统调用接口等非常棒的特性，但其本身的特性并不多，并且也不太可能添加太多的特性。例如，Go 没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。因为 Go 语言倡导成熟和稳定，并且保证向后兼容。</p><h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h2><h3 id="2-1-Hello-World"><a href="#2-1-Hello-World" class="headerlink" title="2.1 Hello, World"></a>2.1 Hello, World</h3><p>编写文件 <code>helloworld.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令。Go 语言提供的工具都通过一个单独的命令 <code>go</code> 调用，<code>go</code> 命令有一系列子命令。最简单的一个子命令就是 <code>run</code>。这个命令编译一个或多个以 <code>.go</code> 结尾的源文件，链接库文件，并运行最终生成的可执行文件。所以上面的程序也可以通过 <code>go run helloworld.go</code> 来运行。当然，也可以通过 <code>go build helloworld.go</code> 来编译，生成一个可执行二进制文件。</p><h3 id="2-2-代码格式"><a href="#2-2-代码格式" class="headerlink" title="2.2 代码格式"></a>2.2 代码格式</h3><p>Go 对于代码格式要求很严格，它提供 <code>gofmt</code> 工具把代码格式化为标准格式（Go 官方认定的一套代码格式），主流的 IDE 在保存 Go 源码时都会自动应用 <code>gofmt</code>，这使得 Go 源码的格式非常统一，Go 开发者不会为代码格式而烦恼。如果格式不对，编译时会报错。</p><blockquote><p>以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执。</p></blockquote><p>更重要的是，由于 Go 源码格式是唯一确定的，这使得开发者可以基于唯一格式做各种自动源码处理。</p><h3 id="2-3-命名风格"><a href="#2-3-命名风格" class="headerlink" title="2.3 命名风格"></a>2.3 命名风格</h3><h4 id="2-3-1-可见性"><a href="#2-3-1-可见性" class="headerlink" title="2.3.1 可见性"></a>2.3.1 可见性</h4><p>在 Go 语言中，名字开头字母的大小写决定了其在包外的可见性。如果一个名字是大写字母开头的，那么它将导出供包外访问。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>(</span><br><span class="line">  People <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span><span class="comment">// 名称在前，类型在后</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">  &#125;</span><br><span class="line">  house <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>包名则习惯总是用小写字母。</p><h4 id="2-3-2-长度"><a href="#2-3-2-长度" class="headerlink" title="2.3.2 长度"></a>2.3.2 长度</h4><p>名字的长度没有逻辑限制，但 Go 语言风格倡导使用短小的命名，尤其对于局部变量而言。在 Go 源码中会经常出现 i, p 之类的短名字，只有当那些名字作用域较大，生命周期较长的变量才会使用有意义的长命名。</p><h3 id="2-4-声明和变量"><a href="#2-4-声明和变量" class="headerlink" title="2.4 声明和变量"></a>2.4 声明和变量</h3><p>可以使用 <code>var</code> 关键字来声明一个特定类型的变量，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">// 省略初始化</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 省略类型，自动推断</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-4-1-零值初始化机制"><a href="#2-4-1-零值初始化机制" class="headerlink" title="2.4.1 零值初始化机制"></a>2.4.1 零值初始化机制</h4><p>与 Java 语言不同，如果初始化表达式被省略，那么将使用零值初始化该变量。</p><ul><li>数值类型：0</li><li>布尔类型： false</li><li>字符串：””（空字符串）</li><li>接口或引用类型：nil</li></ul><p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此 Go 语言中不存在未初始化的变量。</p><h4 id="2-4-2-简短变量声明"><a href="#2-4-2-简短变量声明" class="headerlink" title="2.4.2 简短变量声明"></a>2.4.2 简短变量声明</h4><p>在函数内部，有一种成为简短变量声明语句的形式可用于声明和初始化局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := <span class="number">0.1</span></span><br><span class="line">a, b := <span class="string">&quot;a&quot;</span>, <span class="number">100</span></span><br></pre></td></tr></table></figure><p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。<code>var</code> 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><p>对于已经声明过的变量，简短变量声明语句的行为变为赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, e := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-5-指针"><a href="#2-5-指针" class="headerlink" title="2.5 指针"></a>2.5 指针</h3><p>是的，Go 语言中有指针。</p><h4 id="2-5-1-值拷贝"><a href="#2-5-1-值拷贝" class="headerlink" title="2.5.1 值拷贝"></a>2.5.1 值拷贝</h4><p>与 Java 语言不同，Go 中的函数入参、返回值都是值拷贝而非引用传递。所以，尽管 Go 的日常开发中较少需要使用指针，但参数值拷贝代价较大时，应当考虑使用指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/JgAMeQjXcfV</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rename</span><span class="params">(p people, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 = people&#123;<span class="string">&quot;myk&quot;</span>&#125;</span><br><span class="line">fmt.Println(p1.name)</span><br><span class="line">rename(p1, <span class="string">&quot;MYK&quot;</span>)</span><br><span class="line">fmt.Println(p1.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myk</span><br><span class="line">myk</span><br></pre></td></tr></table></figure><h4 id="2-5-2-示例：命令参数"><a href="#2-5-2-示例：命令参数" class="headerlink" title="2.5.2 示例：命令参数"></a>2.5.2 示例：命令参数</h4><p>指针是实现标准库中 flag 包的关键技术，它使用命令行参数来设置对应变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Echo4 prints its command-line arguments.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 返回指针</span></span><br><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 解析命令行参数</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Print(flag.Args())</span><br><span class="line">  <span class="keyword">if</span> !*n &#123;</span><br><span class="line">  fmt.Println()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>flag.Bool</code> 函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是的命令行标志参数的名字<code>n</code>，然后是该标志参数的默认值（这里是 false），最后是该标志参数对应的描述信息。上面的 <code>n</code> 是对应命令行标志参数变量的指针。</p><h3 id="2-6-多返回值"><a href="#2-6-多返回值" class="headerlink" title="2.6 多返回值"></a>2.6 多返回值</h3><p>在 Go 语言中，一个函数可以返回多个值。通常，Go 函数会返回两个值，一个是期望的返回值，另一个是函数出错时的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;xxxxx&quot;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a/b, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, err := divide(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-Deferred-函数"><a href="#2-7-Deferred-函数" class="headerlink" title="2.7 Deferred 函数"></a>2.7 Deferred 函数</h3><p>在网络、IO 操作时，总要记得关闭资源。在 Java 中可以通过 try finally 块或 try with resources 来保证。而 Go 中可以通过独特的 defer 关键字实现。defer 语句执行时，会将其后面的函数延迟执行。直到包含该 defer 语句的函数执行完毕时，这个函数才会被执行。可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">f, _ := os.Create(<span class="string">&quot;/tmp/tmp.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Complete()</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  f.Write(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-数组和切片"><a href="#3-数组和切片" class="headerlink" title="3.数组和切片"></a>3.数组和切片</h2><h3 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h3><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice 功能也更灵活，但是要理解 slice工作原理的话需要先理解数组。</p><p>初始化数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组的索引顺序并不重要，可以如下初始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR                 <span class="comment">// 欧元</span></span><br><span class="line">    GBP                 <span class="comment">// 英镑</span></span><br><span class="line">    RMB                 <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure><p>未被初始化的元素都是零值。</p><p>由于 Go 的入参是值拷贝，所以传递大数组非常低效，并且函数内无法修改原数组。故时常显式地传入一个数组指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于清空数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-切片"><a href="#3-1-切片" class="headerlink" title="3.1 切片"></a>3.1 切片</h3><p>Go 语言中数组长度也是类型的一部分，即 <code>[32]byte</code> 与 <code>[16]byte</code>是不同的类型，也就是说，上面这个函数不能接收 <code>*[16]byte</code> 类型的参数。同时，没有任何方法能添加或删除数组中的元素，所以数组使用起来并不便利。在实际开发中，一般使用 slice 来替代数组。</p><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 <code>[]T</code>，其中T代表 slice 中元素的类型；slice 的语法和数组很像，只是没有固定长度而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>数组和 slice 之间有着紧密的联系。一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 slice 的底层确实引用一个数组对象。一个 slice 由三个部分构成：指针、长度和容量。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。长度对应 slice 中元素的数目；长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置。内置的 <code>len</code> 和 <code>cap</code> 函数分别返回 slice 的长度和容量。</p><p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p><h4 id="3-1-1-示例"><a href="#3-1-1-示例" class="headerlink" title="3.1.1 示例"></a>3.1.1 示例</h4><p>声明一个月份数组如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>使用切片操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2)     <span class="comment">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br></pre></td></tr></table></figure><p><img data-src="https://box.kancloud.cn/2016-01-10_5691fbe34a76f.png" alt="img"></p><p>如果切片操作超出 <code>cap(s)</code> 的上限将导致一个 panic 异常，但是超出 <code>len(s)</code> 则是意味着扩展了 slice，因为新 slice 的长度会变大：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line"></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// 扩展切片 (capacity 内)</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure><p>因为 slice 值包含指向第一个 slice 元素的指针，因此向函数传递 slice 将允许在函数内部修改底层数组的元素。换句话说，复制一个 slice 只是对底层的数组创建了一个新的 slice 别名。</p><h4 id="3-1-2-append"><a href="#3-1-2-append" class="headerlink" title="3.1.2 append"></a>3.1.2 append</h4><p>当 len&lt;cap 时，append 会在底层数组的基础上直接扩展切片；而 len=cap 时，append 后的切片长度会超出底层数组，这时一个新数组将被创建，返回的切片的底层数组将与原切片不同。所以，一般不能确认 append 返回的切片是否与原切片使用同样的底层数组，故通常将返回值复制给原切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endlessSummer = <span class="built_in">append</span>(endlessSummer, <span class="string">&quot;No&quot;</span>, <span class="string">&quot;De&quot;</span>, <span class="string">&quot;??&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="4-Goroutines-和-Channel"><a href="#4-Goroutines-和-Channel" class="headerlink" title="4.Goroutines 和 Channel"></a>4.Goroutines 和 Channel</h2><p>Go 语言中的并发程序可以用两种手段实现，本节主要介绍 goroutines 和 channel。</p><h3 id="4-1-Goroutines（协程）"><a href="#4-1-Goroutines（协程）" class="headerlink" title="4.1 Goroutines（协程）"></a>4.1 Goroutines（协程）</h3><p>Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。</p><blockquote><p>A <em>goroutine</em> is a lightweight thread managed by the Go runtime.</p></blockquote><h4 id="4-1-1-协程"><a href="#4-1-1-协程" class="headerlink" title="4.1.1 协程"></a>4.1.1 协程</h4><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p><img data-src="https://pic2.zhimg.com/80/v2-ae1d48089f6a4ff589bb5b948ee74a8d_1440w.jpg" alt="img"></p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p><p><strong>协程，英文 Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p><img data-src="https://pic4.zhimg.com/80/v2-a31ca547de92311f644a4d25566eca1f_1440w.jpg" alt="img"></p><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><h4 id="4-1-2-Go-协程内部原理"><a href="#4-1-2-Go-协程内部原理" class="headerlink" title="4.1.2 Go 协程内部原理"></a>4.1.2 Go 协程内部原理</h4><p>综上可知，Go 协程实际上是由 Go 运行时管理的轻量级线程。Go 运行时中有一个专用的协程调度器 Go scheduler，更多可以参考 <a href="https://www.zhihu.com/question/20862617">https://www.zhihu.com/question/20862617</a>.</p><p>Go 使用独立的调度器其中一个原因是 Go 的垃圾回收需要等待所有的 goroutine 停止，使得内存状态一致。而垃圾回收的时间点是不确定的，如果依赖操作系统的调度器，那么需要等待大量线程。</p><p>goroutines 在使用上非常简单，使用关键字 <code>go</code> 即可启动协程。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/ZgRpYwet59D</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子其实有些问题，实际运行时可能没有输出。我们将在后面 WaitGroup 的章节中完善它。</p><h5 id="4-1-2-1-调度模型简介"><a href="#4-1-2-1-调度模型简介" class="headerlink" title="4.1.2.1 调度模型简介"></a>4.1.2.1 调度模型简介</h5><p>Goroutines 能拥有强大的并发实现是通过 GPM 调度模型实现，下面就来解释下 goroutines的调度模型。</p><p><img data-src="https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704144900055-654632620.jpg" alt="img"></p><p>Go 的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched未给出）</p><ul><li>M：M 代表内核级线程，一个 M 就是一个线程，goroutine 就是跑在 M 之上的；M 是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 goroutine、随机数发生器等等非常多的信息；</li><li>G：代表一个 goroutine，它有自己的栈，instruction pointer 和其他信息（正在等待的 channel 等等），用于调度；</li><li>P：P 全称是 Processor，处理器，它的主要用途就是用来执行 goroutine 的，所以它也维护了一个 goroutine 队列，里面存储了所有需要它来执行的 goroutine，是调度的上下文；</li><li>Sched：代表调度器，它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</li></ul><h5 id="4-1-2-2-调度实现"><a href="#4-1-2-2-调度实现" class="headerlink" title="4.1.2.2 调度实现"></a>4.1.2.2 调度实现</h5><p><img data-src="https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704160300058-287296807.jpg" alt="img"></p><p>从上图中看，有2个物理线程 M，每一个 M 都拥有一个处理器 P，每一个也都有一个正在运行的 goroutine。</p><p>P 的数量可以通过设置环境变量 <code>GOMAXPROCS</code> 或通过运行时函数 <code>GOMAXPROCS()</code> 来设置，它其实也就代表了真正的并发度，即有多少个goroutine 可以同时运行。</p><p>图中灰色的那些 goroutine 并没有运行，而是处于 ready 的就绪态，它们被排列在名为 runqueues 的列表中。P 维护着这个队列（称之为 runqueue），每有一个 go 语句被执行，runqueue 队列就在其末尾加入一个。</p><p>为了减少互斥锁的竞争，每个 P 都有自己的本地运行队列。旧版本的 Go 调度程序只有一个全局运行队列，该队列由互斥体保护。线程通常在等待互斥锁解除锁定时被阻塞，性能并不好。</p><p>为什么需要 P（上下文）？为什么不能直接把运行队列放到线程上，去掉上下文？因为如果正在运行的线程由于某种原因（常常是系统调用）需要阻塞，那么我们可以将上下文交给其它线程。</p><p>当一个 OS 线程 M0 陷入阻塞时（如下图)，P 转而在运行 M1，图中的 M1 可能是正被创建，或者从线程缓存中取出。</p><p><img data-src="https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704162532330-809705926.jpg" alt="img"></p><p>当 M0 返回时，它必须尝试取得一个 P 来运行goroutine，一般情况下，它会从其他的 OS 线程那里“偷”一个 P 过来，如果没有偷到的话，它就把 goroutine 放在一个 global runqueue 里，然后自己睡眠（放入线程缓冲里）。这个 global runqueue 是 P 在用完本地运行队列时从中提取的运行队列。所有的 P 也会周期性的检查 global runqueue 并运行其中的 goroutine，否则 global runqueue 上的 goroutine 永远无法执行。</p><p>以上处理系统调用的逻辑就是 Go 即使在 <code>GOMAXPROCS</code> 设为1时仍然运行多线程的原因 。</p><p>还有一种情况是 P 所分配的任务 G 很快就执行完了（分配不均），这就导致了这个处理器 P 很闲，但是其他的 P 还有任务，此时如果 global runqueue 没有任务 G 了，那么 P 不得不从其他的 P 里拿一些 G 来执行。一般来说，如果 P 从其他的 P 那里要拿任务的话，一般就拿 runqueue 的一半，这就确保了每个 OS 线程都能充分的使用，如下图：</p><p><img data-src="https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704164251684-1689850867.jpg" alt="img"></p><h4 id="4-1-3-WaitGroup"><a href="#4-1-3-WaitGroup" class="headerlink" title="4.1.3 WaitGroup"></a>4.1.3 WaitGroup</h4><p>前面提到的例子实际运行时可能会没有输出，这是因为协程执行前，主线程可能已经结束了。</p><p>Go sync 包下提供了 <code>sync.WaitGroup</code>，可以解决上述问题。修改程序如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/m4DSi2cCxTE</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 添加一个等待计数</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  <span class="comment">// 阻塞等待</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">  <span class="comment">// 减少一个等待计数</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-1-3-1-实现原理"><a href="#4-1-3-1-实现原理" class="headerlink" title="4.1.3.1 实现原理"></a>4.1.3.1 实现原理</h5><p>WaitGroup 的实现使用了信号量，其结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line"><span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line"><span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line"><span class="comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span></span><br><span class="line"><span class="comment">// for the sema.</span></span><br><span class="line">state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://oscimg.oschina.net/oscnet/3d44fe27957013aa82eca2923cafe50d909.jpg" alt="3d44fe27957013aa82eca2923cafe50d909.jpg"></p><p>state1 是个长度为3的数组，其中包含了 state 和一个信号量，而 state 实际上是两个计数器：</p><ul><li>counter：当前还未执行结束的 goroutine 计数器</li><li>waiter count：等待 goroutine-group 结束的 goroutine 数量，即有多少个等候者</li><li>semaphore：信号量 </li></ul><p>信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。可简单理解为信号量为一个数值：</p><ul><li>当信号量&gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；</li><li>当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；</li></ul><p>WaitGroup对外提供三个接口：</p><ul><li><p><code>Add(delta int)</code>: 将 delta 值加到 counter 中。当 counter = 0 时根据 waiter 数值释放等量的信号量，把等待的 goroutine 全部唤醒</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state() <span class="comment">//获取state和semaphore地址指针</span></span><br><span class="line">    </span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>) <span class="comment">//把delta左移32位累加到state，即累加到counter中</span></span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">//获取counter值</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state)      <span class="comment">//获取waiter值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;              <span class="comment">//经过累加后counter值变为负值，panic</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过累加后，此时，counter &gt;= 0</span></span><br><span class="line">    <span class="comment">//如果counter为正，说明不需要释放信号量，直接退出</span></span><br><span class="line">    <span class="comment">//如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），</span></span><br><span class="line">    <span class="comment">//先把counter置为0，再释放waiter个数的信号量</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>) <span class="comment">//释放信号量，执行一次释放一个，唤醒一个等待者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Wait()</code>： waiter 递增1，并阻塞等待信号量 semaphore</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state() <span class="comment">//获取state和semaphore地址指针</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep) <span class="comment">//获取state值</span></span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)            <span class="comment">//获取counter值</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state)                 <span class="comment">//获取waiter值</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;                        <span class="comment">//如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            runtime_Semacquire(semap) <span class="comment">//累加成功后，等待信号量唤醒自己</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Done()</code>： counter 递减1，按照 waiter 数值释放相应次数信号量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-Channel"><a href="#4-2-Channel" class="headerlink" title="4.2 Channel"></a>4.2 Channel</h3><p>goroutine 本质上是协程，协程之间如何通信呢？</p><blockquote><p><em>Do not communicate by sharing memory; instead, share memory by communicating.</em></p><p>不要通过共享内存来通信，要通过通信来共享内存。</p></blockquote><p>Java，C++ 等语言使用的传统线程模型要求开发者在不同线程中通过共享内存通信。通常，共享数据结构通过锁来保护，线程通过争夺锁的方式来访问数据。</p><p>而 Go 的并发原语——goroutines 和 channels 提供了一种优雅而独特的方法。Go 鼓励使用 channel 在 goroutine 之间传递对数据的引用，而不是显式地使用锁来调解对共享数据的访问。</p><h4 id="4-2-1-使用"><a href="#4-2-1-使用" class="headerlink" title="4.2.1 使用"></a>4.2.1 使用</h4><p>每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。一个可以发送int 类型数据的 channel 一般写为 <code>chan int</code>。Channel 一般有带缓冲和不带缓冲两种类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// unbuffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个 channel 有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个 goroutine 通过 channel 发送到另一个执行接收操作的 goroutine。发送和接收两个操作都是用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割 channel 和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure><p>Channel 还支持 close 操作，用于关闭 channel，随后对基于该 channel 的任何发送操作都将导致 panic 异常。对一个已经被 close 过的 channel 之行接收操作依然可以接受到之前已经成功发送的数据；如果 channel 中已经没有数据的话讲产生一个零值的数据。</p><p>使用内置的 <code>close</code> 函数就可以关闭一个 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h4 id="4-2-2-无缓冲-Channels"><a href="#4-2-2-无缓冲-Channels" class="headerlink" title="4.2.2 无缓冲 Channels"></a>4.2.2 无缓冲 Channels</h4><p>一个基于无缓冲 Channels 的发送操作将导致发送者 goroutine 阻塞，直到另一个goroutine 在相同的 Channels 上执行接收操作，当发送的值通过 Channels 成功传输之后，两个 goroutine 可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者 goroutine 也将阻塞，直到有另一个 goroutine 在相同的 Channels 上执行发送操作。</p><p>基于无缓冲 Channels 的发送和接收操作将导致两个 goroutine 做一次同步操作。因为这个原因，无缓冲 Channels 有时候也被称为同步 Channels。当通过一个无缓冲 Channels 发送数据时，接收者收到数据发生在唤醒发送者 goroutine 之前。<em>happens before</em> 是Go语言并发内存模型的一个关键术语。</p><p>使用同步 Channels 可以将上面的例子改造如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/scuDtKvwqGQ</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-缓冲-Channels"><a href="#4-2-3-缓冲-Channels" class="headerlink" title="4.2.3 缓冲 Channels"></a>4.2.3 缓冲 Channels</h4><p>带缓冲的 channel 内部持有一个元素队列。队列的最大容量是在调用make函数创建channel 时通过第二个参数指定的。其底层数据结构如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20190307092857857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="4-2-4-sends-and-receives"><a href="#4-2-4-sends-and-receives" class="headerlink" title="4.2.4 sends and receives"></a>4.2.4 sends and receives</h4><p>不同goroutine在channel上面进行读写时，涉及到的过程比较复杂，比如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/20190105122332181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>上图中G1会往channel里面写入数据，G2会从channel里面读取数据。</p><p>G1作用于底层hchan的流程如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/20190105123351626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>先获取全局锁；</li><li>然后enqueue元素(通过移动拷贝的方式)；</li><li>释放锁；</li></ol><p>G2读取时候作用于底层数据结构流程如下图所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20190105123802359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>先获取全局锁；</li><li>然后dequeue元素(通过移动拷贝的方式)；</li><li>释放锁；</li></ol><p>上面的读写思路其实很简单，除了hchan数据结构外，不要通过共享内存去通信；而是通过通信(复制)实现共享内存。</p><h4 id="4-2-5-阻塞与调度"><a href="#4-2-5-阻塞与调度" class="headerlink" title="4.2.5 阻塞与调度"></a>4.2.5 阻塞与调度</h4><p>当向满 channel 写入数据时，发生了什么呢？</p><p><img data-src="https://img-blog.csdnimg.cn/20190105143018955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>上图流程大概如下：</p><p>当前 goroutine（G1）会调用<code>gopark</code>函数，将当前协程置为 waiting 状态；<br>将M和G1绑定关系断开；<br>scheduler 会调度另外一个就绪态的 goroutine 与 M 建立绑定关系，然后 M 会运行另外一个 G。<br>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入 channel 的 sender 队列（队列元素是持有G1的sudog）。</p><p>那么 blocked 的G1怎么恢复呢？当有一个 receiver 接收 channel 数据的时候，会恢复 G1。实际上 hchan 数据结构也存储了 channel 的 sender 和 receiver 的等待队列。数据原型如下：</p><p><img data-src="https://img-blog.csdnimg.cn/20190307093911177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>总结一下 Channel 的内部结构如下图：</p><p><img data-src="https://i6448038.github.io/img/channel/hchan.png" alt="img"></p><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的发送或者接收的index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><h3 id="4-3-Context"><a href="#4-3-Context" class="headerlink" title="4.3 Context"></a>4.3 Context</h3><p>上下文 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系。<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p><h4 id="4-3-1-设计原理"><a href="#4-3-1-设计原理" class="headerlink" title="4.3.1 设计原理"></a>4.3.1 设计原理</h4><p>在 Go 服务器中，每个传入的请求都在其自己的 goroutine 中处理。请求处理程序通常会启动其他 goroutine 来访问后端，如数据库和 RPC 服务。当请求被取消或超时时，处理该请求的所有 goroutine 都应快速退出，以便系统可以回收它们正在使用的任何资源。</p><p><img data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7c035gouj30xc0aa74l.jpg" alt="golang-context-usage"></p><p>如下图，如果最上层的 goroutine 因某些原因失败时，下层的 goroutine 无法感知，将继续工作：</p><p><img data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7c1p9jmij30xc0aadfz.jpg" alt="golang-without-context"></p><p>而通过传递 Context，可以让 goroutine 感知整体的状态。Context 代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Deadline</code>：返回 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 被取消的时间，也就是完成工作的截止日期；</li><li><code>Done</code>：返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</li><li><code>Err</code>：返回 <code>context.Context</code> 结束的原因，它只会在 <code>Done</code> 返回的 Channel 被关闭时才会返回非空的值；<ol><li>如果 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 被取消，会返回 <code>Canceled</code> 错误；</li><li>如果 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 超时，会返回 <code>DeadlineExceeded</code> 错误；</li></ol></li><li><code>Value</code>：从 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 中获取键对应的值，对于同一个上下文来说，多次调用 <code>Value</code> 并传入相同的 <code>Key</code> 会返回相同的结果，该方法可以用来传递请求特定的数据；</li></ol><h4 id="4-3-2-使用"><a href="#4-3-2-使用" class="headerlink" title="4.3.2 使用"></a>4.3.2 使用</h4><p>下面的示例演示了如何使用一个带超时的 Context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/WNVVur7OGgV</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 构造一个超时时间为 1s 的 context</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> handle(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;main: &quot;</span>, ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="comment">// select 语句可以同时监听多个 Channel</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;handle&quot;</span>, ctx.Err())</span><br><span class="line">    <span class="comment">// time.After(durantion) 返回一个同步 Channel</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line"><span class="comment">// 模拟阻塞的耗时操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;处理耗时：&quot;</span>, duration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-实践"><a href="#4-4-实践" class="headerlink" title="4.4 实践"></a>4.4 实践</h3><p>下面是一段示例代码，其主要逻辑包含两个并行任务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agent *Agent)</span> <span class="title">doSpecialize</span><span class="params">(ctx context.Context, req *SpecializeRequest)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">agent.logger.Info(<span class="string">&quot;specialization begin...&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个可取消的 context</span></span><br><span class="line">agentCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">  <span class="comment">// 创建一个 task channel</span></span><br><span class="line">taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := agent.fetcher.Fetch(agentCtx, req.Url, req.FileName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">taskCh &lt;- err</span><br><span class="line">      <span class="comment">// 如果出错，则取消 context</span></span><br><span class="line">cancel()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">taskCh &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(appKeyFilePath, []<span class="keyword">byte</span>(req.AppKey), <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">taskCh &lt;- err</span><br><span class="line">      <span class="comment">// 如果出错，则取消 context</span></span><br><span class="line">cancel()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">taskCh &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for the sub task, return error if any</span></span><br><span class="line">taskCount := <span class="number">2</span></span><br><span class="line">  <span class="comment">// 迭代 task channel</span></span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> taskCh &#123;</span><br><span class="line"><span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 如果有错误，则立即返回错误</span></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">taskCount--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> taskCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">agent.logger.Info(<span class="string">&quot;specialization done.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-依赖管理"><a href="#5-依赖管理" class="headerlink" title="5.依赖管理"></a>5.依赖管理</h2><p>相比 Java，Go 没有类似 Maven，Gradle 这样优秀的依赖管理系统，其依赖管理非常粗放，<del>参考 C</del>。</p><p>虽然可以通过 <code>go get xxx</code> 来下载依赖，但它做的仅仅是帮你把源码下载到相关目录，并不提供类似于版本控制、依赖合并等高级功能。所以很多 Go 项目在使用依赖时仅仅是将依赖下载到 <code>GOPATH</code> 下，供 <code>go build</code> 时链接。</p><p>归根结底，造成这种情况的原因可能是 Go 项目结构太过自由，缺少模块的概念。</p><p>但 Go 1.11版本开始添加了对模块的实验性支持，1.12版本删除了对 <code>GOPATH</code> 的支持。使得 Go 终于有了像样的依赖管理。</p><p>可以用环境变量 <code>GO111MODULE</code> 开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是 <code>auto</code>。</p><ul><li><code>GO111MODULE=off</code> 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li><li><code>GO111MODULE=on</code> 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 <code>go.mod</code> 下载依赖。</li><li><code>GO111MODULE=auto</code> 在 <code>$GOPATH/src</code> 外面且根目录有 <code>go.mod</code> 文件时，开启模块支持。</li></ul><h3 id="5-1-模块定义"><a href="#5-1-模块定义" class="headerlink" title="5.1 模块定义"></a>5.1 模块定义</h3><p>每个模块化的项目根目录下都应该有一个 <code>go.mod</code> 文件，这个文件不用手写，可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init xxx # xxx 是模块名</span><br></pre></td></tr></table></figure><p>生成。在项目目录下使用 <code>go get</code> 命令时会自动填写这个文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module agent</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/natefinch/lumberjack v2<span class="number">.0</span><span class="number">.0</span>+incompatible</span><br><span class="line"><span class="keyword">go</span>.uber.org/atomic v1<span class="number">.5</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line"><span class="keyword">go</span>.uber.org/multierr v1<span class="number">.4</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line"><span class="keyword">go</span>.uber.org/zap v1<span class="number">.13</span><span class="number">.0</span></span><br><span class="line">golang.org/x/lint v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20191125180803</span>-fdd1cda4f05f <span class="comment">// indirect</span></span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200114155413</span><span class="number">-6</span>afb5195e5aa</span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200115044656</span><span class="number">-831</span>fdb1e1868 <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是一个依赖列表，可以看到依赖中包含了依赖的版本号。</p><h3 id="5-2-版本规范"><a href="#5-2-版本规范" class="headerlink" title="5.2 版本规范"></a>5.2 版本规范</h3><p>Go 模块版本是有严格规范的，上面文件中很多依赖是不合规范的。详细规范可以参考<a href="https://blog.golang.org/v2-go-modules">Go Modules: v2 and Beyond</a>。简单而言，当需要更新模块的大版本号时，应当更改模块名，以保证兼容性。调用方也需要同步修改引用路径为大版本号。</p><blockquote><p>每次大版本更新都会更新module的路径，也就是说在module的后面修改相应的版本号，所以后面的大版本路径一般会如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;module xxx.com/arch/xxx.git/v3</span><br><span class="line">module xxx.com/arch/xxx.git/v4</span><br><span class="line">module xxx.com/arch/xxx.git/v5</span><br></pre></td></tr></table></figure><ul><li>如果遇上大版本更新，业务方接入时，需要修改自己的import路径</li><li>如果没有没有大版本更新，这不需要进行修改</li></ul></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>推荐两本书：</p><ol><li><a href="http://www.kancloud.cn:8080/hartnett/gopl-zh">Go 语言圣经</a></li><li><a href="https://draveness.me/golang/">Go 语言设计与实现</a></li><li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li></ol><p>参考文章：</p><ol><li><p><a href="https://www.cnblogs.com/wdliu/p/9272220.html">go语言之行–golang核武器goroutine调度原理、channel详解</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/74047342">Golang协程详解和应用</a></p></li><li><p><a href="http://morsmachine.dk/go-scheduler">The Go scheduler</a></p></li><li><p><a href="https://taohuawu.club/high-performance-implementation-of-goroutine-pool">Goroutine 并发调度模型深度解析之手撸一个高性能 goroutine 池</a></p></li><li><p><a href="https://my.oschina.net/renhc/blog/2249061">Go WaitGroup实现原理</a></p></li><li><p><a href="https://www.cnblogs.com/RyuGou/p/10776565.html">图解Go的channel底层原理</a></p></li><li><p><a href="https://blog.csdn.net/u010853261/article/details/85231944">Golang-Channel原理解析</a></p></li><li><p><a href="https://golang.org/doc/">https://golang.org/doc/</a></p></li><li><p><a href="https://blog.golang.org/">https://blog.golang.org/</a></p></li><li><p><a href="https://blog.golang.org/v2-go-modules">Go Modules: v2 and Beyond</a></p></li><li><p><a href="https://blog.cyeam.com/go/2019/03/12/go-version">Go module 如何发布 v2 及以上版本？</a></p></li><li><p><a href="https://blog.golang.org/context">Go Concurrency Patterns: Context</a></p></li><li><p><a href="https://blog.golang.org/codelab-share">Share Memory By Communicating</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      最近使用 Go 开发了一个新服务，第一次使用 Go 进行企业级服务开发，特总结经验如下。
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Go" scheme="http://moeyui1.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Spring CGLIB 动态代理子类导致的注解丢失</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/43a5efe7.html"/>
    <id>http://moeyui1.github.io/开发/43a5efe7.html</id>
    <published>2019-09-07T14:02:02.000Z</published>
    <updated>2021-02-08T10:12:18.753Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring 中可以使用类级别的<code>@Validated</code> 注解对整个类的方法做校验，实际运行时，Spring 会通过 CGLIB 生成基于类的代理，这个生成的代理是原始类的子类。而这个自动生成的子类不会继承原始类的注解，故在编写 Component 处理逻辑时检测不到原始类的注解。</p><span id="more"></span><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>如下的一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Component(&quot;abb&quot;)</span></span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cupCounter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Function(&quot;echo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Function</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用<code>@Validated</code>和<code>@CustomAnnotation</code>注解的类没有扫描到<code>@CustomAnnotation</code>注解，断点观察被<code>@Validated</code>注解的类注册到 Context 时的<code>beanType</code>并非原来的类型，而是 CGLIB 生成的子类。并且这个子类没有注解。</p><p><a href="https://imgchr.com/i/n1qlnK"><img data-src="https://s2.ax1x.com/2019/09/07/n1qlnK.md.png" alt="n1qlnK.md.png"></a></p><p><img data-src="https://s2.ax1x.com/2019/09/07/n1qact.png" alt="n1qact.png"></p><p>使用<code>@Validated</code>可以让Spring帮你做类的数据校验。猜想为了实现校验，Spring使用了CGLIB代理（当需要代理的类没有实现接口时，Spring 总是使用基于类的动态代理即CGLIB），注册的bean是一个CGLIB子类，所以丢失了注解信息。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然生成的代理类会丢失注解信息，那么 Spring 的注解如<code>@Controller</code>又是如何工作的呢？</p><p>翻阅一下 Spring 源码，参考<a href="https://zhuanlan.zhihu.com/p/33678399">SpringMVC源码之Controller查找原理</a>。</p><ul><li><p><code>AbstractHandlerMethodMapping#processCandidateBean</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里判断bean是否为一个 Handler</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>RequestMappingHandlerMapping#isHandler</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Expects a handler to have either a type-level @&#123;<span class="doctag">@link</span> Controller&#125;</span></span><br><span class="line"><span class="comment"> * annotation or a type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//逻辑上通过判断是否含 @Controller 注解，但这里使用了一个 AnnotatedElementUtils</span></span><br><span class="line">    <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AnnotatedElementUtils#hasAnnotation</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if an annotation of the specified &#123;<span class="doctag">@code</span> annotationType&#125;</span></span><br><span class="line"><span class="comment"> * is &lt;em&gt;available&lt;/em&gt; on the supplied &#123;<span class="doctag">@link</span> AnnotatedElement&#125; or</span></span><br><span class="line"><span class="comment"> * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the specified element.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If this method returns &#123;<span class="doctag">@code</span> true&#125;, then &#123;<span class="doctag">@link</span> #findMergedAnnotationAttributes&#125;</span></span><br><span class="line"><span class="comment"> * will return a non-null value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> AnnotatedElementUtils class-level javadoc&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element the annotated element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationType the annotation type to find</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if a matching annotation is present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isAnnotated(AnnotatedElement, Class)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(AnnotatedElement element, Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Shortcut: directly present on the element, with no processing needed?</span></span><br><span class="line">    <span class="comment">// 这是传统的判断方法</span></span><br><span class="line">    <span class="keyword">if</span> (element.isAnnotationPresent(annotationType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键在于 searchWithFindSemantics 方法</span></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(searchWithFindSemantics(element, annotationType, <span class="keyword">null</span>, alwaysTrueAnnotationProcessor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AnnotatedElementUtils#searchWithFindSemantics</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Search for annotations of the specified &#123;<span class="doctag">@code</span> annotationName&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> annotationType&#125; on the specified &#123;<span class="doctag">@code</span> element&#125;, following</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;find semantics&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element the annotated element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationType the annotation type to find</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationName the fully qualified class name of the annotation</span></span><br><span class="line"><span class="comment"> * type to find (as an alternative to &#123;<span class="doctag">@code</span> annotationType&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> processor the processor to delegate to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of the processor (potentially &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">searchWithFindSemantics</span><span class="params">(AnnotatedElement element,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> String annotationName, Processor&lt;T&gt; processor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有很多个重载方法，一直点进去看</span></span><br><span class="line"><span class="keyword">return</span> searchWithFindSemantics(element,</span><br><span class="line">(annotationType != <span class="keyword">null</span> ? Collections.singleton(annotationType) : Collections.emptySet()),</span><br><span class="line">annotationName, <span class="keyword">null</span>, processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 到这里可以看到对 bean class 进行判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">Class&lt;?&gt; clazz = (Class&lt;?&gt;) element;</span><br><span class="line"><span class="keyword">if</span> (!Annotation.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line"><span class="comment">// Search on interfaces</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : clazz.getInterfaces()) &#123;</span><br><span class="line">T result = searchWithFindSemantics(ifc, annotationTypes, annotationName,</span><br><span class="line">containerType, processor, visited, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Search on superclass</span></span><br><span class="line"><span class="comment">// 判断了父类，CGLIB 生成的子类父类是原始类，所以就能找到原来的注解</span></span><br><span class="line">Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line"><span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object.class) &#123;</span><br><span class="line">T result = searchWithFindSemantics(superclass, annotationTypes, annotationName,</span><br><span class="line">containerType, processor, visited, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></li></ul><p>这样就知道了<code>@Controller</code>是如何支持代理类了，故使用<code>AnnotatedElementUtils</code>来判断注解就OK了？</p><p>当然没那么简单，这样修改后，又出现了新问题：</p><h3 id="方法级别的注解也丢了"><a href="#方法级别的注解也丢了" class="headerlink" title="方法级别的注解也丢了"></a>方法级别的注解也丢了</h3><p><code>AnnotatedElementUtils</code>只能用于类级别注解，而 CGLIB 代理类中的方法注解也丢失了</p><p>别忘了Spring中还使用了方法级别注解<code>@RequestMapping</code>，于是又翻看源码，观察上面的源码找到 Handler 之后是如何处理方法级别注解的。</p><ul><li><p><code>AbstractHandlerMethodMapping#detectHandlerMethods</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for handler methods in the specified handler bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 在这里获取代理子类的原始类型</span></span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatMappings(userType, methods));</span><br><span class="line">&#125;</span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>ClassUtils#getUserClass(java.lang.Class&lt;?&gt;)</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the user-defined class for the given class: usually simply the given</span></span><br><span class="line"><span class="comment"> * class, but the original class in case of a CGLIB-generated subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz the class to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the user-defined class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getUserClass(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>由<code>ClassUtils</code>的注解可知，通过这个方法可以直接获取到原始类型，Spring在这之后直接处理原始类型的方法。</p><p>那为什么不在<code>@Controller</code>中也获取原始类型呢？通过上面的源码可以看到<code>isHandler</code>的判断逻辑非常的复杂，可能考虑到某些代理子类上可能会有<code>@Controller</code>注解？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断 Spring bean 的注解时，考虑到 bean 有可能是动态代理子类，使用<code>isAnnotationPresent</code>或<code>getAnnotation</code>等方法不能获取到原始类的注解。应该使用<code>AnnotatedElementUtils</code>来判断类级别注解，对于方法级别甚至参数级别注解，应使用<code>ClassUtils</code>获取原始类的 Class 进行判断。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Spring 中可以使用类级别的&lt;code&gt;@Validated&lt;/code&gt; 注解对整个类的方法做校验，实际运行时，Spring 会通过 CGLIB 生成基于类的代理，这个生成的代理是原始类的子类。而这个自动生成的子类不会继承原始类的注解，故在编写 Component 处理逻辑时检测不到原始类的注解。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Spring" scheme="http://moeyui1.github.io/tags/Spring/"/>
    
      <category term="Java" scheme="http://moeyui1.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190610</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/a647f20.html"/>
    <id>http://moeyui1.github.io/周报/a647f20.html</id>
    <published>2019-06-10T15:34:12.000Z</published>
    <updated>2021-02-08T10:12:18.757Z</updated>
    
    <content type="html"><![CDATA[<p>微软和 Red Hat 开源 KEDA；Fission 发布 1.3.0</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="10-THINGS-TO-KNOW-ABOUT-SERVERLESS-COMPUTING-—-BEFORE-YOU-MAKE-THE-LEAP"><a href="#10-THINGS-TO-KNOW-ABOUT-SERVERLESS-COMPUTING-—-BEFORE-YOU-MAKE-THE-LEAP" class="headerlink" title="10 THINGS TO KNOW ABOUT SERVERLESS COMPUTING — BEFORE YOU MAKE THE LEAP"></a><a href="http://techgenix.com/about-serverless-computing/">10 THINGS TO KNOW ABOUT SERVERLESS COMPUTING — BEFORE YOU MAKE THE LEAP</a></h3><p>无服务器计算的核心是隐藏虚拟化环境中开发人员的服务器。服务器资源不是在固定的基础上分配的，而是依赖于事件。这种理想的业务实现听起来相当令人愉快，并且可能也会降低价格。然而，在充分发挥其潜力之前，该技术必须首先克服一些误解。因此，让我们对下面的无服务器计算进行批判性讨论，在采用这项技术之前，你应该了解这 10 个方面的情况。</p><h3 id="Sequence-Numbering-in-Serverless-via-API-Gateway"><a href="#Sequence-Numbering-in-Serverless-via-API-Gateway" class="headerlink" title="Sequence Numbering in Serverless via API Gateway"></a><a href="https://medium.com/lego-engineering/sequence-numbering-in-serverless-via-api-gateway-40e5f6c83e93">Sequence Numbering in Serverless via API Gateway</a></h3><p>从传统应用迁移到无服务器应用时，我们可能会需要一种生成有序数字编号的简单方法，本文探讨了在AWS上使用无服务器应用程序时生成序列号的常用方法。</p><h3 id="Kubernetes-Failure-Stories-and-How-to-Crash-Your-Clusters-Henning-Jacobs-Zalando-SE"><a href="#Kubernetes-Failure-Stories-and-How-to-Crash-Your-Clusters-Henning-Jacobs-Zalando-SE" class="headerlink" title="Kubernetes Failure Stories and How to Crash Your Clusters - Henning Jacobs, Zalando SE"></a><a href="https://www.youtube.com/watch?v=6sDTB4eV4F8">Kubernetes Failure Stories and How to Crash Your Clusters - Henning Jacobs, Zalando SE</a></h3><p>链接为 Henning Jacobs, Zalando SE 在 KubeCon&amp;CloudNativeCon 上关于“基于 Serverless 的边缘计算”的分享。通过各种智能终端获取数据，在云上通过 Serverless 方式进行加工处理。对于边缘计算和 Serverless 产品化解决方案设计有很好借鉴参考价值。</p><h3 id="通过-Jets-框架在-AWS-Lambda-上实现无服务化-Ruby"><a href="#通过-Jets-框架在-AWS-Lambda-上实现无服务化-Ruby" class="headerlink" title="通过 Jets 框架在 AWS Lambda 上实现无服务化 Ruby"></a><a href="https://www.infoq.cn/article/FSPhFgYw769V*brbEyJW">通过 Jets 框架在 AWS Lambda 上实现无服务化 Ruby</a></h3><p>本文将构建一个 SMS 应用。为了让其更加有趣，本文将加入一些幽默元素。当用户在应用中打字时，它将会回复您一个由 <a href="https://icanhazdadjoke.com/">icanhazdadjoke</a> API 免费提供的笑话。该应用会展示如何上手 Jets，以及创建控制器、动作和线路。我们将构建一个单端点，当某个号码接收到 SMS 信息时，这个端点会对来自 Twilio 的 HTTP 请求做出反应。端点每次都会返回 <a href="https://www.twilio.com/docs/sms/twiml">TwiML</a>，以及一个随机的、令人爆笑的笑话。</p><h3 id="初识-Knative：跨平台的-Serverless-编排框架"><a href="#初识-Knative：跨平台的-Serverless-编排框架" class="headerlink" title="初识 Knative：跨平台的 Serverless 编排框架"></a><a href="https://mp.weixin.qq.com/s/Lt_3WheDI93WbQbBdOULZw">初识 Knative：跨平台的 Serverless 编排框架</a></h3><p>本文是阿里云智能事业群技术专家冬岛撰写的 Knative 系列文章的第一篇，介绍了 Knative 的相关概念。</p><blockquote><p>Knative 提供了一组中间件组件，它们对于“构建现代、源码中心化以及基于容器的应用至关重要”。</p></blockquote><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://cloudblogs.microsoft.com/opensource/2019/05/06/announcing-keda-kubernetes-event-driven-autoscaling-containers/?spm=a2c4e.11153940.blogcont703016.21.58982c26pVpRDx">Announcing KEDA: bringing event-driven containers and functions to Kubernetes</a>：微软和 Red Hat 构建的组件 KEDA 现已开源。 KEDA 可为任意 Kubernetes 工作负载提供 事件驱动能力。</p><p><a href="https://github.com/fission/fission/blob/master/CHANGELOG.md">Fission 发布 1.3.0</a>：包含 CI test 静态代码分析、readiness/liveness 探针等新特性和 bug fix.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微软和 Red Hat 开源 KEDA；Fission 发布 1.3.0&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190603</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/8a761fdb.html"/>
    <id>http://moeyui1.github.io/周报/8a761fdb.html</id>
    <published>2019-06-03T12:56:32.000Z</published>
    <updated>2021-02-08T10:12:18.757Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 所有版本存在文件系统越权漏洞；Kubernetes 发布 1.12.9</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="评估企业级-Kubernetes-使用方案的-18-个要素"><a href="#评估企业级-Kubernetes-使用方案的-18-个要素" class="headerlink" title="评估企业级 Kubernetes 使用方案的 18 个要素"></a><a href="https://www.infoq.cn/article/z1lTN*peI2H6tl4cd8YT">评估企业级 Kubernetes 使用方案的 18 个要素</a></h3><p>各个行业的数字化转型正在推动 IT 部门对云原生应用的支持。在这种趋势下，很多企业将采用 Kubernetes 作为云原生的有效方式，基于容器的架构模式，构建现代化的应用程序和 IT 基础架构。众所周知，Kubernetes 很难部署并大规模运维。本文是对 Kubernetes 产品功能的比较和思考。</p><h3 id="Workers-KV，基于边缘节点的无服务器式键值存储"><a href="#Workers-KV，基于边缘节点的无服务器式键值存储" class="headerlink" title="Workers KV，基于边缘节点的无服务器式键值存储"></a><a href="https://www.infoq.cn/article/DORvTEScirM_gzGhARcu">Workers KV，基于边缘节点的无服务器式键值存储</a></h3><p><a href="https://www.cloudflare.com/products/cloudflare-workers/">Cloudflare Workers</a>是一个无服务器平台，使开发人员能够将 JavaScript 代码和<a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/">WebAssembly APP</a>部署到 Cloudflare 广泛延伸的数据中心（截至如今，Cloudflare 已经在 80 个国家 180 多个城市搭建了其云网络数据中心）。Workers 可以扩展出数千个实例并拦截到站点的 HTTP 请求。这些实例不到 5 毫秒就可以完成启动，而实例完成运行最多只需 50 毫秒。到目前为止，如果一个 Worker 实例需要<a href="https://developers.cloudflare.com/workers/writing-workers/storing-data/">检索数据</a>，开发人员要么将数据存储在 Worker 实例本身的脚本中，要么从 Cloudflare 的缓存中加载数据文件。之前在 Cloudflare 团队的<a href="https://blog.cloudflare.com/workers-kv-is-ga/">一篇博客</a>中提及，在使用 Workers 平台后不久，一些客户就提出了需求，需要更好地存储持久性数据。这就是促使 Workers KV 诞生的源由。</p><h3 id="大盘点：-KubeCon-EU-2019-应用管理领域的新看点！"><a href="#大盘点：-KubeCon-EU-2019-应用管理领域的新看点！" class="headerlink" title="大盘点： KubeCon EU 2019 应用管理领域的新看点！"></a><a href="https://www.infoq.cn/article/bXcVGCgcLNwsv*uoaPMN">大盘点： KubeCon EU 2019 应用管理领域的新看点！</a></h3><p>KubeCon EU 2019 刚刚在巴塞罗那拉下帷幕，来自阿里巴巴经济体的讲师团，在大会上分享了互联网场景下规模化 Kubernetes 集群的各项落地经验和教训。所谓“独行速而众行远”，从不断发展壮大的社区中，我们看到越来越多的人拥抱开源，往标准演进，搭上了这趟开往云原生的高速列车。本文是 InfoQ 邀请阿里云容器平台技术专家、原 CoreOS 公司工程师、 K8s Operator 项目的核心作者之一邓洪超，为读者精选了此次会议“应用管理”领域的精华内容来一一进行分析与点评。</p><h3 id="热度-3-年猛增-20-倍，Serverless-amp-云开发的技术架构全解析"><a href="#热度-3-年猛增-20-倍，Serverless-amp-云开发的技术架构全解析" class="headerlink" title="热度 3 年猛增 20 倍，Serverless &amp; 云开发的技术架构全解析"></a><a href="https://www.infoq.cn/article/AGpW53A*13Z7zVjE8Jga">热度 3 年猛增 20 倍，Serverless &amp; 云开发的技术架构全解析</a></h3><p>作为一种云原生的架构，Serverless 与 BaaS、FaaS 之间有何“爱恨情仇”？冤家路窄却能完美解决前后端联调等开发痛点，解决方案又是如何？相较于传统开发模式，基于“无服务开发”理念的小程序·云开发模式又“新”在何处，有何利好？下面我们从 Serverless 的架构演进来具体分析。</p><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://duo.com/decipher/docker-bug-allows-root-access-to-host-file-system">Docker 所有版本存在同一漏洞，允许攻击者访问主机文件系统</a>：这个漏洞可以让攻击者获得主机服务器上所有路径的读写访问权限。据了解，之所以会出现该漏洞，主要是因为 Docker 软件处理某些符号链接的方式，而这些符号链接中往往会包含有到其他目录或文件的路径的文件。研究员 Aleksa Sarai 发现，在某些情况下，攻击者可以在路径解析时间和操作时间之间的短时间窗口将自己的符号链接插入到路径中。截止到目前（5.31）还没有关于 Docker 官方何时修复漏洞的消息。</p><p><a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.12.9">Kubernetes 发布 1.12.9</a>：Cluster Autoscaler 更新到 1.12.5；bug fix。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 所有版本存在文件系统越权漏洞；Kubernetes 发布 1.12.9&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190527</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/bd6b0719.html"/>
    <id>http://moeyui1.github.io/周报/bd6b0719.html</id>
    <published>2019-05-27T13:31:02.000Z</published>
    <updated>2021-02-08T10:12:18.756Z</updated>
    
    <content type="html"><![CDATA[<p>KubeCon Europe 2019 在巴塞罗那召开；阿里云前端工程师蒋航谈 Serverless 掀起新的前端技术变革；Serverless 框架企业版 0.10.0 发布。</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="Cloud-Run-Bringing-serverless-to-containers"><a href="#Cloud-Run-Bringing-serverless-to-containers" class="headerlink" title="Cloud Run: Bringing serverless to containers"></a><a href="https://cloud.google.com/blog/products/serverless/cloud-run-bringing-serverless-to-containers">Cloud Run: Bringing serverless to containers</a></h3><p>本文对新一代 Serverless 计算平台—— Cloud Run 进行了详尽的介绍。借助 Cloud Run，用户可以简单地将任何无状态的请求驱动容器托管在 Google Cloud 上。</p><h3 id="Building-the-cloud-native-future-at-Google-Cloud"><a href="#Building-the-cloud-native-future-at-Google-Cloud" class="headerlink" title="Building the cloud-native future at Google Cloud"></a><a href="https://cloud.google.com/blog/products/containers-kubernetes/building-the-cloud-native-future-at-google-cloud">Building the cloud-native future at Google Cloud</a></h3><p>本文介绍了如何在谷歌云上构建云原生的未来，涉及了谷歌云上的 Istio, Knative, gVisor 等热门产品。</p><h3 id="研发运维效率提升100-，机器成本下降50-，阿里巴巴在-Serverless-计算领域的探索"><a href="#研发运维效率提升100-，机器成本下降50-，阿里巴巴在-Serverless-计算领域的探索" class="headerlink" title="研发运维效率提升100%，机器成本下降50%，阿里巴巴在 Serverless 计算领域的探索"></a><a href="https://mp.weixin.qq.com/s/Gj_qPPTn6KN065qUu6e-mw">研发运维效率提升100%，机器成本下降50%，阿里巴巴在 Serverless 计算领域的探索</a></h3><p>本文将介绍阿里云中间件团队在探索 Serverless 过程中的思考以及正在做的事，目的是尽可能让开发者少改代码，甚至不改代码，就能具备 AWS Lambda 的技术优势。</p><h3 id="Serverless-掀起新的前端技术变革"><a href="#Serverless-掀起新的前端技术变革" class="headerlink" title="Serverless 掀起新的前端技术变革"></a><a href="https://zhuanlan.zhihu.com/p/65914436">Serverless 掀起新的前端技术变革</a></h3><p>最近关于 Serverless 的讨论越来越多。看似与前端关系不大的 Serverless，其实早已和前端有了渊源，并且将对前端开发模式产生变革性的影响。本文来自阿里云前端工程师蒋航在 QCon 北京 2019 的分享，他从前端开发模式的演进、基于 Serverless 的前端开发案例以及 Serverless 开发最佳实践等方面，与大家探讨 Serverless 中的前端开发模式。</p><h3 id="Serverless-Architecture-—-Complete-Reference-Guide-2019"><a href="#Serverless-Architecture-—-Complete-Reference-Guide-2019" class="headerlink" title="Serverless Architecture — Complete Reference Guide [2019]"></a><a href="https://medium.com/swlh/serverless-architecture-complete-reference-guide-2019-55363c08d1be">Serverless Architecture — Complete Reference Guide [2019]</a></h3><p>无服务器架构 - 完整参考指南，对serverless及其演进过程、使用场景、优缺点对比等方面进行了简要介绍。</p><h3 id="阿里蒋航：Serverless-将使前后端从分离再度走向融合"><a href="#阿里蒋航：Serverless-将使前后端从分离再度走向融合" class="headerlink" title="阿里蒋航：Serverless 将使前后端从分离再度走向融合"></a><a href="https://www.infoq.cn/article/bodZTULS2LQ-G4UIahjf">阿里蒋航：Serverless 将使前后端从分离再度走向融合</a></h3><p>阿里云前端工程师蒋航在 QCon 北京 2019 中的演讲从前端开发模式的演进、基于 Serverless 的前端开发案例以及 Serverless 开发最佳实践等方面，与大家分享了 Serverless 中的前端开发模式，本文是 InfoQ 对蒋航的采访。</p><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://www.infoq.cn/article/8kJpuLmv_yWiHiulzYKS">KubeCon Europe 2019</a>：2019 年 5 月 21 日至 23 日，KubeCon + CloudNativeCon 在巴塞罗那召开，云原生计算基金会（CNCF）及其成员宣布了围绕 Kubernetes（K8s）的许多改进和新功能。</p><p><a href="https://serverless.com/blog/deployment-profiles/">Serverless 框架企业版 0.10.0 发布</a>：添加对部署配置文件的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KubeCon Europe 2019 在巴塞罗那召开；阿里云前端工程师蒋航谈 Serverless 掀起新的前端技术变革；Serverless 框架企业版 0.10.0 发布。&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190520</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/230f92ba.html"/>
    <id>http://moeyui1.github.io/周报/230f92ba.html</id>
    <published>2019-05-20T13:32:09.000Z</published>
    <updated>2021-02-08T10:12:18.756Z</updated>
    
    <content type="html"><![CDATA[<p>Knative Serving 模块发布 v0.6.0; Kubernetes v1.14.2 发布; AWS Lambda 增加了对 Node.js v10 的支持；Lucet 生命周期及性能揭秘。</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="Bringing-serverless-convenience-to-containers"><a href="#Bringing-serverless-convenience-to-containers" class="headerlink" title="Bringing serverless convenience to containers"></a><a href="https://diginomica.com/bringing-serverless-convenience-containers">Bringing serverless convenience to containers</a></h3><p>更简洁的架构方法将 Kubernetes 的多平台可移植性与无服务器功能的使用简单性和部署即时性相结合。 Microsoft Azure 和 Red Hat 最近发布的一些声明，再加上 Google 和更广泛的容器开源社区的早期工作，为容器带来了无服务器的便利，并实现了基于容器和相关协调和服务管理生态系统的便携式多云应用环境。</p><h3 id="Why-Serverless-Won’t-Replace-Traditional-Servers"><a href="#Why-Serverless-Won’t-Replace-Traditional-Servers" class="headerlink" title="Why Serverless Won’t Replace Traditional Servers"></a><a href="https://www.business2community.com/tech-gadgets/why-serverless-wont-replace-traditional-servers-02199041">Why Serverless Won’t Replace Traditional Servers</a></h3><p>虽然每个企业在云基础架构方面都有不同的需求，但无服务器无法完全超越传统服务器的当前云基础架构。有太多用例无服务器不适用，或者不值得权衡控制（或者可能是成本）。但随着云服务提供商继续大力投资无服务器，可以公平地说，无服务器的使用将在未来几年继续增长。</p><h3 id="容器和函数：如何有效利用临时性基础设施"><a href="#容器和函数：如何有效利用临时性基础设施" class="headerlink" title="容器和函数：如何有效利用临时性基础设施"></a><a href="https://www.infoq.cn/article/iCow9Pfcj7cWwg_9eeHa">容器和函数：如何有效利用临时性基础设施</a></h3><p>随着容器、微服务和函数通过现代应用程序设计交织在一起，必须努力找出如何使用容器和函数作为应用程序打包技术的正确方法及如何使用后部署技术。本文探索了几个通用的最佳实践，以便能够在容器和函数的临时性世界中获得成功，还将详细介绍一些无服务器计算的恰当用法。</p><h3 id="CRI-O-An-Open-Source-Container-Runtime-for-Kubernetes"><a href="#CRI-O-An-Open-Source-Container-Runtime-for-Kubernetes" class="headerlink" title="CRI-O: An Open Source Container Runtime for Kubernetes"></a><a href="https://www.infoq.com/news/2019/05/cri-o-kubernetes-runtime">CRI-O: An Open Source Container Runtime for Kubernetes</a></h3><p>本文是对 CRI-O 的介绍。CRI-O 是一个由 Red Hat 创建的 <a href="https://www.opencontainers.org/">Open Container Initiative</a>(OCI)容器运行时，它使得 Kubernetes 支持 Docker, rkt 或 Moby.</p><h3 id="YOU-ARE-WRONG-ABOUT-SERVERLESS-VENDOR-LOCK-IN"><a href="#YOU-ARE-WRONG-ABOUT-SERVERLESS-VENDOR-LOCK-IN" class="headerlink" title="YOU ARE WRONG ABOUT SERVERLESS VENDOR LOCK-IN"></a><a href="https://lumigo.io/blog/you-are-wrong-about-serverless-vendor-lock-in/">YOU ARE WRONG ABOUT SERVERLESS VENDOR LOCK-IN</a></h3><p>在这篇文章中，Yan Cui 对 serverless 供应商绑定的观点提出了质疑。他认为在竞争日益激烈的当下，缺少对业务价值的专注远比与一个云提供商紧密绑定更严重。</p><h3 id="The-lifecycle-and-performance-of-a-Lucet-instance"><a href="#The-lifecycle-and-performance-of-a-Lucet-instance" class="headerlink" title="The lifecycle and performance of a Lucet instance"></a><a href="https://www.fastly.com/blog/lucet-performance-and-lifecycle">The lifecycle and performance of a Lucet instance</a></h3><p><a href="https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime">Lucet</a> 是一个原生 WebAssembly 编译器和运行时，一经发布就引起了社区的兴趣。它可以在50毫秒内实例化 WebAssembly 模块。在这篇文章中，作者将揭秘 Lucet 运行时系统的生命周期及各阶段的性能。</p><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://github.com/knative/serving/releases/tag/v0.6.0">Knative Serving 模块发布v0.6.0</a>：本次版本，无论是核心 API 或者是自动扩容等变化都算是比较大，具体内容请参考 ReleaseNote.</p><p><a href="https://groups.google.com/forum/#!topic/kubernetes-announce/NihkvaordbE">Kubernetes v1.14.2 正式发布</a>：更新 golang 版本至 v1.12.5，优化了 Kubernetes API server 的延迟。</p><p><a href="https://aws.amazon.com/cn/about-aws/whats-new/2019/05/aws_lambda_adds_support_for_node_js_v10/">AWS Lambda 增加了对 Node.js v10 的支持</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Knative Serving 模块发布 v0.6.0; Kubernetes v1.14.2 发布; AWS Lambda 增加了对 Node.js v10 的支持；Lucet 生命周期及性能揭秘。&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190513</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/912b90c3.html"/>
    <id>http://moeyui1.github.io/周报/912b90c3.html</id>
    <published>2019-05-13T13:42:44.000Z</published>
    <updated>2021-02-08T10:12:18.756Z</updated>
    
    <content type="html"><![CDATA[<p>Google 推出 Cloud Code；红帽发布 Red Hat Enterprise Linux 8；QCon 全球软件开发大会（北京站）2019 于 2019 年 5 月 6-10 日举办；<a href="https://serverless.com/blog/framework-release-v142/">Serverless 框架 v1.42.0</a> 发布。</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="Knative-系列（一）：基本概念和原理解读"><a href="#Knative-系列（一）：基本概念和原理解读" class="headerlink" title="Knative 系列（一）：基本概念和原理解读"></a><a href="https://www.infoq.cn/article/PEOIcPk4lZRg-fAwry8H">Knative 系列（一）：基本概念和原理解读</a></h3><p>由华为云容器服务团队编写的 Knative 系列博客，深入浅出地介绍了 Knative 的基本概念。</p><h3 id="专访阿里亚顿：Serverless-正在颠覆开发模式，包括对工种的定义"><a href="#专访阿里亚顿：Serverless-正在颠覆开发模式，包括对工种的定义" class="headerlink" title="专访阿里亚顿：Serverless 正在颠覆开发模式，包括对工种的定义"></a><a href="https://www.infoq.cn/article/8JE5FgHt1PIM*eqSUMfw">专访阿里亚顿：Serverless 正在颠覆开发模式，包括对工种的定义</a></h3><p>在 7 月 12 日深圳 ArchSummit 全球架构师峰会上，来自阿里的高级前端专家亚顿将分享《BFF in Serverless》话题，在此之前，亚顿老师把他在实践 Serverless 过程中的一些技术解决思路分享给大家，以飨读者。</p><h3 id="Kube-OVN：基于-OVN-的开源-Kubernetes-网络实践"><a href="#Kube-OVN：基于-OVN-的开源-Kubernetes-网络实践" class="headerlink" title="Kube-OVN：基于 OVN 的开源 Kubernetes 网络实践"></a><a href="https://www.infoq.cn/article/2Pr39j0jJcbWpu7K*prP">Kube-OVN：基于 OVN 的开源 Kubernetes 网络实践</a></h3><p>近日，灵雀云发布了基于 OVN 的 Kubernetes 网络组件 Kube-OVN，并正式将其在 Github 上开源。Kube-OVN 提供了大量目前 Kubernetes 不具备的网络功能，并在原有基础上进行增强。通过将 OpenStack 领域成熟的网络功能平移到 Kubernetes，来应对更加复杂的基础环境和应用合规性要求。OVS 是一个单机的虚拟网络交换机，同时支持 OpenFlow 可以实现复杂的网络流量编程，这也是网络虚拟化的基础。通过 OVS 和 OpenFlow 可以实现细粒度的流量控制。如果做个类比，OVS 相当于网络虚拟化里的 Docker.</p><h3 id="Serverless-moves-the-responsibility-of-performance-monitoring-to-developers"><a href="#Serverless-moves-the-responsibility-of-performance-monitoring-to-developers" class="headerlink" title="Serverless moves the responsibility of performance monitoring to developers"></a><a href="https://sdtimes.com/softwaredev/serverless-moves-the-responsibility-of-performance-monitoring-to-developers/">Serverless moves the responsibility of performance monitoring to developers</a></h3><p>无服务器将性能监控的责任转移给开发人员。在性能方面，为了在 function 被阻止或者运行不正常时不会浪费钱，开发人员需要确保他们的功能正在运行并且健康。使用传统软件并不是那么重要，因为无论应用程序是否正常运行，服务器都在运行，因此不会增加成本。但是对于无服务器，您需要为使用付费，应用程序始终按原样运行非常重要。</p><h3 id="InfoQ-访谈：Docker-生态系统的安全形势及最佳实践"><a href="#InfoQ-访谈：Docker-生态系统的安全形势及最佳实践" class="headerlink" title="InfoQ 访谈：Docker 生态系统的安全形势及最佳实践"></a><a href="https://www.infoq.cn/article/FotqtmDrBB0eHzD_8PUB">InfoQ 访谈：Docker 生态系统的安全形势及最佳实践</a></h3><p>作为其<a href="https://snyk.io/opensourcesecurity-2019/">开源安全现状年度报告</a>的一部分，安全公司<a href="https://snyk.io/">Snyk</a>发布了一份特别针对<a href="https://bit.ly/dockerreport19">Docker</a><a href="https://bit.ly/dockerreport19">的</a><a href="https://bit.ly/dockerreport19">安全报告</a>，该报告显示容器镜像中的漏洞广泛存在。InfoQ 就此问题采访了 Snyk 开发人员倡导者 Liran Tal.</p><h3 id="基于-Kubernetes-的-GPU-类型调度实现"><a href="#基于-Kubernetes-的-GPU-类型调度实现" class="headerlink" title="基于 Kubernetes 的 GPU 类型调度实现"></a><a href="https://www.infoq.cn/article/ypP*1sbAuBAD1KL1qB4K">基于 Kubernetes 的 GPU 类型调度实现</a></h3><p>基于 Kubernetes 的云原生技术为人工智能提供了一种新的工作模式。但是，Kubernetes 作为新一代 AI 开发基础也存在缺陷。<strong>为训练任务分配算力资源时，它通常是随机分配容器所在节点的 GPU，而不能指定使用某类 GPU 类型</strong>。因此，在这篇文章中，作者将介绍才云科技在这一点上的经验，谈一谈他们如何基于 Kubernetes 灵活实现 GPU 类型的调度。</p><h3 id="Google-Cloud-Run详细介绍"><a href="#Google-Cloud-Run详细介绍" class="headerlink" title="Google Cloud Run详细介绍"></a><a href="https://skyao.io/post/201905-google-cloud-run-detail/">Google Cloud Run详细介绍</a></h3><p>来自蚂蚁金服的高级专家<a href="https://skyao.io/">敖小剑</a>在本文中对 Google Cloud Next 2019 大会上发布的 Cloud Run 进行了深入剖析。</p><h3 id="Advancing-the-developer-experience-for-serverless-apps-with-Azure-Functions"><a href="#Advancing-the-developer-experience-for-serverless-apps-with-Azure-Functions" class="headerlink" title="Advancing the developer experience for serverless apps with Azure Functions"></a><a href="https://azure.microsoft.com/en-gb/blog/advancing-the-developer-experience-for-serverless-apps-with-azure-functions/">Advancing the developer experience for serverless apps with Azure Functions</a></h3><p>本文介绍了Azure Functions 如何从以下几个方面改进 Serverless 应用的开发体验：</p><ul><li>一种在 Kubernetes 环境中托管 Azure Functions 的新方式；</li><li>有状态实体与 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview">Durable Functions</a> ；</li><li>.NET 应用与依赖注入；</li><li>通过 Azure DevOps 流水线部署；</li><li>通过 Azure API 管理改进集成。</li></ul><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://www.infoq.cn/article/J1BKATTezCy-9gaJs5Cc">Google 推出 Cloud Code</a>：扩展 IntelliJ 和 Visual Studio Code 支持 Kubernetes 应用。</p><p>红帽发布 Red Hat Enterprise Linux 8：波士顿时间 2019 年 5 月 7 日，红帽峰会（Red Hat Summit）如期举办，InfoQ 第一时间对峰会的重要亮点进行了报道，这是 IBM 宣布收购红帽之后的第一次峰会，因此备受关注。会上，红帽发布 RHEL 8（Red Hat Enterprise Linux 8），这是整场峰会最重大的发布之一。虽然被 IBM 收购后可能不会导致 RHEL 这一名称发生改变，但这依旧被认为是 Red Hat Linux 操作系统最后一个独立且纯粹的发行版（预计收购于今年下半年最终完成）。</p><p>QCon 全球软件开发大会（北京站）2019 于 2019 年 5 月 6-10 日举办，蚂蚁金服首席执行官程立 (鲁肃）、腾讯玄武实验室总监于旸（TK）、百度搜索公司首席架构师祁安龙等 180 余位专家策划呈现议题，针对行业内编程语言、业务架构、前端前沿技术以及新生态等重点命题，进行了全方位观点输出；蚂蚁金服副 CTO 胡喜、百度副总裁侯震宇、 W3C Web 技术总负责人 Philippe Le Hégaret 做主题演讲分享最新技术趋势。</p><p><a href="https://serverless.com/blog/framework-release-v142/">Serverless 框架发布 v1.42.0</a>：API Gateway Logs, Binary Media Type Responses, Request Body Validations &amp; More.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google 推出 Cloud Code；红帽发布 Red Hat Enterprise Linux 8；QCon 全球软件开发大会（北京站）2019 于 2019 年 5 月 6-10 日举办；&lt;a href=&quot;https://serverless.com/blog/framework-release-v142/&quot;&gt;Serverless 框架 v1.42.0&lt;/a&gt; 发布。&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190506</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/f85a550d.html"/>
    <id>http://moeyui1.github.io/周报/f85a550d.html</id>
    <published>2019-05-06T12:59:08.000Z</published>
    <updated>2021-02-08T10:12:18.756Z</updated>
    
    <content type="html"><![CDATA[<p>Now 推出用于本地调试 Serverless 应用的 <code>now dev</code>；2019 是属于容器技术的时代？</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="TO-VPC-OR-NOT-TO-VPC-PROS-AND-CONS-IN-AWS-LAMBDA"><a href="#TO-VPC-OR-NOT-TO-VPC-PROS-AND-CONS-IN-AWS-LAMBDA" class="headerlink" title="TO VPC OR NOT TO VPC? PROS AND CONS IN AWS LAMBDA"></a><a href="https://lumigo.io/blog/to-vpc-or-not-to-vpc-in-aws-lambda/">TO VPC OR NOT TO VPC? PROS AND CONS IN AWS LAMBDA</a></h3><p><a href="https://epsagon.com/author/yan/?post_id=2208">Yan Cui</a>，经验丰富的 <a href="https://aws.amazon.com/developer/community/heroes/yan-cui/">AWS Serverless Hero</a>， 在这篇文章中深入分析了 <code>VPC</code>（virtual private cloud） 对 Lambda 是否真的有所意义。</p><h3 id="Empower-your-AI-Platform-trained-serverless-endpoints-with-machine-learning-on-Google-Cloud-Functions"><a href="#Empower-your-AI-Platform-trained-serverless-endpoints-with-machine-learning-on-Google-Cloud-Functions" class="headerlink" title="Empower your AI Platform-trained serverless endpoints with machine learning on Google Cloud Functions"></a><a href="https://cloud.google.com/blog/products/ai-machine-learning/empower-your-ai-platform-trained-serverless-endpoints-with-machine-learning-on-google-cloud-functions">Empower your AI Platform-trained serverless endpoints with machine learning on Google Cloud Functions</a></h3><p>Hannes Hapke，来自 <a href="https://www.caravelapp.com/">Caravel</a>，介绍了云函数如何基于 Serverless 基础设施加速生产环境中为对话AI构建机器学习模型的过程。</p><h3 id="为什么说-2019，是属于容器技术的时代？"><a href="#为什么说-2019，是属于容器技术的时代？" class="headerlink" title="为什么说 2019，是属于容器技术的时代？"></a><a href="https://www.infoq.cn/article/R1p3H3_29f4TYImExsyw">为什么说 2019，是属于容器技术的时代？</a></h3><p>本文追溯了容器技术的历史发展，提出 2019 是属于容器技术的时代，应用交付的革命不会停止。</p><h3 id="Serverless-computing-pros-and-cons-5-benefits-and-3-drawbacks"><a href="#Serverless-computing-pros-and-cons-5-benefits-and-3-drawbacks" class="headerlink" title="Serverless computing pros and cons: 5 benefits and 3 drawbacks"></a><a href="https://www.techrepublic.com/article/serverless-computing-pros-and-cons-5-benefits-and-3-drawbacks/">Serverless computing pros and cons: 5 benefits and 3 drawbacks</a></h3><p>无服务器计算非常适合某些应用程序，但在首先进入无服务器深度端之前需要考虑一些缺点。</p><h3 id="Building-Serverless-Pipelines-with-Amazon-CloudWatch-Events"><a href="#Building-Serverless-Pipelines-with-Amazon-CloudWatch-Events" class="headerlink" title="Building Serverless Pipelines with Amazon CloudWatch Events"></a><a href="https://aws.amazon.com/cn/blogs/aws/building-serverless-pipelines-with-amazon-cloudwatch-events/">Building Serverless Pipelines with Amazon CloudWatch Events</a></h3><p>使用 Amazon CloudWatch Events 构建 Serverless 流水线。本文介绍了如何通过 CloudWatch Events 构建事件驱动的 Serverless 应用程序。由 <a href="https://www.trek10.com/"><em>Trek10</em></a> 的高级云架构师 <a href="https://aws.amazon.com/developer/community/heroes/forrest-brazeal/"><em>Forrest Brazeal</em></a> 撰写。</p><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://gravitational.com/blog/announcing_wormhole/">Gravitational Wormhole</a> 是一个 Kubernetes 网络插件，提供网络通信加密功能。</p><p><a href="https://zeit.co/now">Now</a> 是一个小而美的 Serverless 平台，近日推出了 <a href="https://zeit.co/blog/now-dev?utm_source=newsletter&utm_medium=email&utm_campaign=now-dev">now dev</a> ——用于本地调试 Serverless 应用的新特性。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="http://www.servicemesher.com/getting-started-with-knative/">《Knative入门——构建基于 Kubernetes 的现代化Serverless应用》</a>：本书译自《Getting Started with Knative - Building Modern Serverless Workloads on KubernetesGetting Started with Knative》 ，是一本由 Pivotal 公司赞助 O’Reilly 出品的免费电子书。<code>Knative</code> 是一个基于 Kubernetes 的，用于构建、部署和管理现代 Serverless 应用的平台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Now 推出用于本地调试 Serverless 应用的 &lt;code&gt;now dev&lt;/code&gt;；2019 是属于容器技术的时代？&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190429</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/5b114029.html"/>
    <id>http://moeyui1.github.io/周报/5b114029.html</id>
    <published>2019-04-29T12:58:24.000Z</published>
    <updated>2021-02-08T10:12:18.755Z</updated>
    
    <content type="html"><![CDATA[<p>中国信通院发布云原生白皮书；CNCF联合阿里巴巴提供免费云原生课程；Serverless Framework 1.41发布。</p><span id="more"></span><h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="Google-Cloud-Run-一瞥"><a href="#Google-Cloud-Run-一瞥" class="headerlink" title="Google Cloud Run 一瞥"></a><a href="https://blog.fleeto.us/post/a-first-look-at-google-cloud-run/">Google Cloud Run 一瞥</a></h3><p>Google 在 Cloud Next’19 上发布了基于 Docker 容器的的 Serverless 新方案。目前可以肯定的是，这是 Serverless 的重要进步——在 Cloud Run 上进行部署比在 Kubernetes 上运行容器简单多了。而且和 Lambda 不同，这一方案没有语言绑定的问题。</p><h3 id="Serverless-Can-It-Simplify-Data-Science-Projects"><a href="#Serverless-Can-It-Simplify-Data-Science-Projects" class="headerlink" title="Serverless: Can It Simplify Data Science Projects?"></a><a href="https://towardsdatascience.com/serverless-can-it-simplify-data-science-projects-8821369bf3bd">Serverless: Can It Simplify Data Science Projects?</a></h3><p>数据科学家花费大量时间在数据收集、构建基础设施、开发和集成等工作上，而真正用在模型开发和测试的时间少之又少，本文介绍了如何借助Serverless来帮助数据科学家专注数学科学逻辑，提高工作效率。</p><h3 id="kubeCDN：一个基于-Kubernetes-的自托管-CDN"><a href="#kubeCDN：一个基于-Kubernetes-的自托管-CDN" class="headerlink" title="kubeCDN：一个基于 Kubernetes 的自托管 CDN"></a><a href="https://www.infoq.cn/article/trfu-uB4FPhAB4uLvL4R">kubeCDN：一个基于 Kubernetes 的自托管 CDN</a></h3><p>在本篇博文中，作者主要讨论了 kubeCDN 的设计和实现，这个工具旨在简化 Kubernetes 集群的跨地域复制，以便在全球范围内部署高可用的 CDN（内容分发网络）服务。</p><h3 id="Deploy-and-monitor-Docker-containers-using-AWS-Elastic-Beanstalk-in-3-steps"><a href="#Deploy-and-monitor-Docker-containers-using-AWS-Elastic-Beanstalk-in-3-steps" class="headerlink" title="Deploy and monitor Docker containers using AWS Elastic Beanstalk in 3 steps"></a><a href="https://read.acloud.guru/docker-on-elastic-beanstalk-tips-e1a4e6b70ff2">Deploy and monitor Docker containers using AWS Elastic Beanstalk in 3 steps</a></h3><p>当Cloud Run崭露头角时，它的诸多特性让我们不得不同AWS珠玉在前的资源托管服务Beanstalk联系在一起。本文将会带领大家了解如何使用Beantalks。对本文而言，使用者应当关注它的形态是否符合Serverless的需求；而开发者应当思考，Cloud Run或者Beanstalk，它们的内在异同。</p><h3 id="AO-com-the-path-to-Serverless-First"><a href="#AO-com-the-path-to-Serverless-First" class="headerlink" title="AO.com: the path to Serverless First"></a><a href="https://serverless.com/blog/ao-serverless-first/">AO.com: the path to Serverless First</a></h3><p>AO.com 是来自英国的领先在线电器零售商。本文介绍了 AO.com 如何为了顺应 GDPR 法规，将服务 Serverless 化，并在 AWS Lambda 上实现他们的数据流水线。本文由 Nick Gottlieb，Serverless公司发展副总裁撰写。</p><h3 id="云原生的新思考：为什么说容器已经无处不在了？"><a href="#云原生的新思考：为什么说容器已经无处不在了？" class="headerlink" title="云原生的新思考：为什么说容器已经无处不在了？"></a><a href="https://www.infoq.cn/article/hhk37_UC1FgJFCQyIk7c">云原生的新思考：为什么说容器已经无处不在了？</a></h3><p>4 月 24 日，中国信息通信研究院主办的首届云原生产业大会在北京举行，在《云原生数字引领未来》的主题演讲中，阿里云容器服务总监易立表示：“云原生不但可以很好的支持互联网应用，也在深刻影响着新的计算架构、新的智能数据应用。以容器、服务网格、微服务、Serverless 为代表的云原生技术，带来一种全新的方式来构建应用。”本文根据易立演讲内容整理而成。</p><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://www.toutiao.com/i6684024971481580039/">中国信通院发布云原生白皮书</a>：4月24日，国内最权威、最大规模的云原生应用大会——2019云原生产业大会在北京召开。本次大会上，中国信息通信研究院重磅发布了《云原生行业应用实践白皮书》和《无服务架构技术白皮书》两份白皮书。《云原生行业应用实践白皮书》系统阐述了云原生架构的主要技术、云原生技术的行业落地实践、云原生应用发展趋势和标准化建议。在金融行业落地实践中，蚂蚁金服的分布式架构技术SOFAStack和云原生应用平台APaaS助力网商银行成为中国第一家将核心系统架构在金融云上的银行，就是其中的典型应用案例。据悉，在2018年双11期间，网商银行采用云原生技术进行底层架构的全面升级，不仅提供了如丝般顺滑的服务体验，而且支撑的整体业务容量和峰值TPS增长了400%。《无服务架构技术白皮书》则系统阐述了Serverless的技术生态现状、Serverless架构适用场景、技术发展趋势与落地应用案例。作为落地应用案例代表之一，蚂蚁金服采用Serverless架构这种更高效、简单的方式快速实现安全、稳定、可靠的支付宝小程序后台服务，可以大幅提升研发效率、提供高可用的服务能力、提供专业的安全管控，并实现低成本高收益。蚂蚁金服Serverless应用服务（SAS）为小程序提供了后端无服务器产品平台和解决方案。</p><p><a href="https://mp.weixin.qq.com/s/y2V3PwOK5qbdmjFsuNTGkg">CNCF与阿里巴巴联手为中国开发人员提供免费云原生课程</a>：“CNCF x 阿里巴巴云原生课程”的目标在于指导开发人员使用云原生技术，包括 Kubernetes、etcd、containerd 和 Envoy。此外，这门课程还将介绍促进云计算兴起的各方面因素。课程完全免费，不用注册。</p><p><a href="https://www.infoq.com/news/2019/04/nimbus-serverless-java-framework">Nimbus: New Framework for Building Java Serverless Applications</a>：Nimbus框架是一个Java框架，旨在简化云中功能即服务（FaaS）应用程序的开发，测试和部署。 Nimbus提供与云无关的通用接口，用于与云提供商的无服务器功能进行交互。</p><p><a href="https://serverless.com/blog/framework-release-v141/">Serverless 框架 v1.41 版本发布</a>：添加了对 AWS API Gateway 的 <a href="https://docs.aws.amazon.com/xray/index.html">X-Ray</a> 支持，优化了 Docker 本地调用等功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国信通院发布云原生白皮书；CNCF联合阿里巴巴提供免费云原生课程；Serverless Framework 1.41发布。&lt;/p&gt;
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190422</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/ccc399a1.html"/>
    <id>http://moeyui1.github.io/周报/ccc399a1.html</id>
    <published>2019-04-22T12:50:13.000Z</published>
    <updated>2021-02-08T10:12:18.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h2><h3 id="The-Good-and-the-Bad-of-Google-Cloud-Run"><a href="#The-Good-and-the-Bad-of-Google-Cloud-Run" class="headerlink" title="The Good and the Bad of Google Cloud Run"></a><a href="https://read.acloud.guru/the-good-and-the-bad-of-google-cloud-run-34455e673ef5">The Good and the Bad of Google Cloud Run</a></h3><p>本文讨论了 Google Cloud Run 与 Faas 和全托管 API 服务的关系，并通过与 AWS Lambda 的对比，分析了 Google Cloud Run 的利与弊。</p><h3 id="选择FaaS还是微服务？"><a href="#选择FaaS还是微服务？" class="headerlink" title="选择FaaS还是微服务？"></a><a href="http://www.servicemesher.com/blog/faas-vs-microservices/">选择FaaS还是微服务？</a></h3><p>Serverless 和 Faas 概念越来越火，它们是否是下一代微服务？我们是否应当跳过微服务，直接采用 Serverless？</p><h3 id="Best-Practices-for-AWS-Lambda-Container-Reuse"><a href="#Best-Practices-for-AWS-Lambda-Container-Reuse" class="headerlink" title="Best Practices for AWS Lambda Container Reuse"></a><a href="https://medium.com/capital-one-tech/best-practices-for-aws-lambda-container-reuse-6ec45c74b67e">Best Practices for AWS Lambda Container Reuse</a></h3><p>AWS Lambda 容器复用最佳实践，介绍了如何优化 Lambda 连接外部服务。</p><h3 id="基于-Kata-Containers-与-iSulad-的云容器实践解析"><a href="#基于-Kata-Containers-与-iSulad-的云容器实践解析" class="headerlink" title="基于 Kata Containers 与 iSulad 的云容器实践解析"></a><a href="https://www.infoq.cn/article/wcSmEKasstv*AdEPZE61">基于 Kata Containers 与 iSulad 的云容器实践解析</a></h3><p>Kata Containers 是融合传统虚拟化技术与容器技术创造的高安全性容器，本文由华为云容器服务团队撰写，解析 Kata Containers 在华为 iSula 容器平台的实践。</p><h3 id="In-a-Serverless-World-We-Still-Need-State"><a href="#In-a-Serverless-World-We-Still-Need-State" class="headerlink" title="In a Serverless World, We Still Need State"></a><a href="https://www.infoq.com/news/2019/04/serverless-needs-state">In a Serverless World, We Still Need State</a></h3><p>serverless 的编程模型不应只关注无状态函数，这限制了 serverless 的使用场景；因此，Jonas Bonér 指出在 serverless 2.0 版本必须关注状态，使得用户在构建分布式通用应用程序的同时受益于无服务器的优势。</p><h3 id="Creating-a-Chat-App-with-Serverless-WebSockets-and-Python-A-Tutorial"><a href="#Creating-a-Chat-App-with-Serverless-WebSockets-and-Python-A-Tutorial" class="headerlink" title="Creating a Chat App with Serverless, WebSockets, and Python: A Tutorial"></a><a href="https://levelup.gitconnected.com/creating-a-chat-app-with-serverless-websockets-and-python-a-tutorial-54cbc432e4f">Creating a Chat App with Serverless, WebSockets, and Python: A Tutorial</a></h3><p>教程：基于Serverless框架构，利用AWS Lambda、API Gateway和简单的Django客户端，使用Python语言开发了“聊天”应用程序</p><h3 id="Using-advanced-Kubernetes-autoscaling-with-Vertical-Pod-Autoscaler-and-Node-Auto-Provisioning"><a href="#Using-advanced-Kubernetes-autoscaling-with-Vertical-Pod-Autoscaler-and-Node-Auto-Provisioning" class="headerlink" title="Using advanced Kubernetes autoscaling with Vertical Pod Autoscaler and Node Auto Provisioning"></a><a href="https://cloud.google.com/blog/products/containers-kubernetes/using-advanced-kubernetes-autoscaling-with-vertical-pod-autoscaler-and-node-auto-provisioning">Using advanced Kubernetes autoscaling with Vertical Pod Autoscaler and Node Auto Provisioning</a></h3><p>本文由 Jerzy Foryciarz，谷歌云产品管理主任撰写，介绍了 VPA 和 Node Auto Provisioning 这两个 GKE 中高级特性的使用。</p><h3 id="破除对-AWS-Fargate-的幻觉"><a href="#破除对-AWS-Fargate-的幻觉" class="headerlink" title="破除对 AWS Fargate 的幻觉"></a><a href="https://linux.cn/article-10740-1.html">破除对 AWS Fargate 的幻觉</a></h3><p>AWS Fargate，用它你就可以无需管理底层节点而运行你的 Docker 容器。文中提到了笔者亲身体验 Fargate 的经历，并提出了“<strong>真的没有看到任何超过 Kubernetes 平台的好处</strong>”这样的观点。</p><blockquote><p>Fargate 是一项出色的技术，AWS 团队对 ECS/Fargate 所做的工作确实非常出色。然而，我的观点是，这绝对不比 Kubernetes “更容易”，只是……难点不同</p></blockquote><h2 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h2><p><a href="https://www.infoq.com/news/2019/04/open-policy-agent-cncf">Open Policy Agent 被接纳为 CNCF 孵化器项目</a>：OPA 是一个开源的，为整个架构提供灵活的权限控制的通用策略引擎。</p><p><a href="https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-advanced-enhanced-reliability-simplicity-and-scale-for-enterprise-workloads">Google Kubernetes Engine 高级版发布</a>：GKE 高级版对比标准版包括诸如更好的SLA、简化的自动化、额外的保护层等高级特性。</p>]]></content>
    
    <summary type="html">
    
      每周一期，分享最新的 Serverless 新闻和优秀文章。
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless 每周小报-20190415</title>
    <link href="http://moeyui1.github.io/%E5%91%A8%E6%8A%A5/57c40a44.html"/>
    <id>http://moeyui1.github.io/周报/57c40a44.html</id>
    <published>2019-04-15T13:04:12.000Z</published>
    <updated>2021-02-08T10:12:18.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客精选"><a href="#博客精选" class="headerlink" title="博客精选"></a>博客精选</h3><h4 id="以-CNCF-的方式实现云原生意味着什么？"><a href="#以-CNCF-的方式实现云原生意味着什么？" class="headerlink" title="以 CNCF 的方式实现云原生意味着什么？"></a><a href="https://www.infoq.cn/article/YLC*o3eK76aj7zjSEvwY">以 CNCF 的方式实现云原生意味着什么？</a></h4><p>人们在讨论<strong>数字化转型</strong>和<strong>现代应用程序开发</strong>时，其中经常出现的术语之一是云原生（Cloud-Native）。但是，云原生究竟意味着什么呢？本文将带领读者深入了解云原生的方法，以及用 CNCF 方式实现云原生的方法。</p><h4 id="Quarkus-Java-Framework-Q-amp-A-with-John-Clingan-and-Mark-Little"><a href="#Quarkus-Java-Framework-Q-amp-A-with-John-Clingan-and-Mark-Little" class="headerlink" title="Quarkus Java Framework: Q&amp;A with John Clingan and Mark Little"></a><a href="https://www.infoq.com/news/2019/04/redhat-quarkus-qa">Quarkus Java Framework: Q&amp;A with John Clingan and Mark Little</a></h4><p>Red Hat 最近发布了 Quarkus, 一个为 GraalVM 和 OpenJDK HotSpot 定制的 Kubernetes 原生的 Java 框架 文章是对 Red Hat 高级首席产品经理 John Clingan 和工程副总裁 Mark Little 的采访。</p><h4 id="Serverless-Architecture-Market-Analysis-to-Reach-18-04-Billion-Globally-By-2024"><a href="#Serverless-Architecture-Market-Analysis-to-Reach-18-04-Billion-Globally-By-2024" class="headerlink" title="Serverless Architecture Market Analysis to Reach 18.04 Billion, Globally By 2024"></a><a href="http://industrynewscenter.com/14941/serverless-architecture-market-analysis-to-reach-18-04-billion-globally-by-2024/">Serverless Architecture Market Analysis to Reach 18.04 Billion, Globally By 2024</a></h4><p>无服务器架构市场将实现快速增长，到2024年全球将达到180.4亿。</p><h4 id="Overview-of-serverless-compute-products-on-Google-Cloud-Platform"><a href="#Overview-of-serverless-compute-products-on-Google-Cloud-Platform" class="headerlink" title="Overview of serverless compute products on Google Cloud Platform"></a><a href="https://medium.com/google-cloud/overview-of-serverless-compute-products-on-google-cloud-platform-f4aa47a14ecb">Overview of serverless compute products on Google Cloud Platform</a></h4><p>文章对App Engine、Cloud Functions、Cloud Run三款Serverless产品在Google Cloud Platform的差异性进行了比较。</p><h4 id="开发者可能低估了容器部署的复杂性"><a href="#开发者可能低估了容器部署的复杂性" class="headerlink" title="开发者可能低估了容器部署的复杂性"></a><a href="https://www.infoq.cn/article/F2-E4eMP1VyjlGicsXmI">开发者可能低估了容器部署的复杂性</a></h4><p>很多中小型公司往往低估了大型企业对容器反应平淡背后的复杂性，应用在 VMware 的容器中运行，就是云原生的吗？</p><h3 id="业界要闻"><a href="#业界要闻" class="headerlink" title="业界要闻"></a>业界要闻</h3><p><a href="https://www.infoq.cn/article/e8bqYSghNl-rXRAbNdPg">谷歌 Cloud Code：让开发者轻松构建 Kubernetes 应用</a>。在Google Cloud NEXT 2019的大会现场，谷歌正式发布了 Cloud Code，这是一组 IntelliJ 和 VS Code 编辑器上的新插件，可利用已有工具为软件开发生命周期的每个阶段实现自动化，目的是让开发者在 IDE 环境下也可以开发云原生 Kubernetes 应用程序，而不需要改变编码习惯和环境，几乎适用于所有主流编程语言，包括 .NET Core。</p><p><a href="https://www.infoq.cn/article/ewdNjHzM7owpSXCS-9vz">CRI-O 进入 CNCF 孵化阶段，或将挑战 Docker 在容器界的地位</a>：CRI-O(Container Runtime Interface Orchestrator) 是一个轻量级的，专门对 Kubernetes 进行优化的容器运行时环境。CRI 最初是作为 API 来定义对容器运行时的调用，这允许用户开发 Kubernetes 友好的轻量级容器运行时程序。CRI-O 是第一个与 Kubernetes CRI 兼容的容器运行时，由 Google、Red Hat、英特尔、SUSE 和 IBM 联合开发。</p><p><a href="https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack">Announcing Cloud Run, the newest member of our serverless compute stack</a>：Google Cloud 宣布推出名为 Cloud Run 的新 Serverless 计算产品的测试版，它允许您运行无状态HTTP驱动的容器，而无需担心基础架构。 Cloud Run 是一种完全无服务器的产品：它负责所有基础架构管理，包括配置、伸缩、扩展和管理服务器。它会在几秒钟内自动向上或向下扩展，甚至可以根据流量降至零，确保您只需为实际使用的资源付费。</p><p><a href="https://rockset.com/">Rockset</a> 是一个 Serverless 为原生数据提供高效 SQL 的搜索和分析引擎，使得开发者和数据科学家可以不用任何数据流水线或数据准备，以构建应用或验证假设。</p><p><a href="https://serverless.com/blog/framework-release-v140/">Serverless 框架1.40版本发布</a>：改进了 invoke local 支持，现在可以在本地模拟任何 Runtime 的调用。</p><p><a href="https://www.infoq.cn/article/rkCUSWctOM5wC5*KOwAC">Mozilla 发布 WASI 计划</a>：可在所有设备上运行 WebAssembly。Docker 联合创始人 Solomon Hikes 对此评论道：</p><blockquote><p>如果 2008 年就有 WASM+WASI，那么，我们就不需要创造 Docker 了。这就它的重要性所在。服务器上的 WebAssembly 是计算的未来。一个标准化的系统接口就是其缺失的环节。希望 WASI 能胜任这项任务！</p></blockquote><p><img data-src="https://ws3.sinaimg.cn/large/006tNc79ly1g23gz9m921j30u014qjum.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      每周一期，分享最新的 Serverless 新闻和优秀文章。
    
    </summary>
    
      <category term="周报" scheme="http://moeyui1.github.io/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>通过Knative在Kubernetes上策划一次从源码到URL的部署</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/7184eb1f.html"/>
    <id>http://moeyui1.github.io/开发/7184eb1f.html</id>
    <published>2019-03-09T14:35:11.000Z</published>
    <updated>2021-02-08T10:12:18.761Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于 knative 文档中的 <a href="https://github.com/knative/docs/blob/master/serving/samples/source-to-url-go/README.md#orchestrating-a-source-to-url-deployment-on-kubernetes">Orchestrating a source-to-URL deployment on Kubernetes</a> 的简单例子，通过从源码到 URL 的部署流程一窥 Knative 给 Kubernetes 带来的改变。</p><span id="more"></span><h2 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h2><ul><li>一个安装了 Knative 的 Kubernetes 集群。如果你需要创建一个，按照<a href="https://github.com/knative/docs/blob/master/install/README.md">安装步骤</a>来。</li><li>安装并配置了 Go。这是可选的，仅当你想要在本地运行示例应用时需要。</li></ul><h2 id="配置-Knative"><a href="#配置-Knative" class="headerlink" title="配置 Knative"></a>配置 Knative</h2><p>源码的构建是由 Knative build 子系统完成的，通常我们需要在构建配置中定义一些构建步骤(step)，通过这些构建步骤一步步地处理源码，详细可以参考 <a href="https://github.com/knative/docs/blob/master/build/builds.md#knative-build-resources">Knative Build resources</a>。但 Knative 也支持使用多种构建模板，下文就介绍如何使用 kaniko 构建模板完成示例代码的构建。</p><h3 id="安装-kaniko-构建模板"><a href="#安装-kaniko-构建模板" class="headerlink" title="安装 kaniko 构建模板"></a>安装 kaniko 构建模板</h3><p>本示例借助 <a href="https://github.com/knative/build-templates/tree/master/kaniko">kaniko build template</a> 来在你的 Kubernetes 集群上执行一次“从源码到容器”的构建。</p><blockquote><p><a href="https://github.com/GoogleCloudPlatform/kaniko">kaniko</a> 是谷歌开源的用于从 Dockerfile 构建容器镜像的工具。它的特点在于不依赖 Docker daemon，并在用户空间内执行 Dockerfile 中的每一行命令。这使得在一些不能方便地或安全地运行 Docker daemon 的环境中，如标准 Kubernetes 集群中，也能构建容器镜像。</p></blockquote><p>使用 kubectl 来安装 kaniko：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply --filename https://raw.githubusercontent.com/knative/build-templates/master/kaniko/kaniko.yaml</span><br></pre></td></tr></table></figure><h3 id="填写-Docker-Hub-的密钥"><a href="#填写-Docker-Hub-的密钥" class="headerlink" title="填写 Docker Hub 的密钥"></a>填写 Docker Hub 的密钥</h3><p>为了将从源代码构建得到的容器推送到 Docker Hub，需要在 Kubernetes 上登记密钥用于认证 Docker Hub。</p><p>关于 Knative 中的认证，这是<a href="https://github.com/knative/docs/blob/master/build/auth.md#basic-authentication-docker">详细的说明</a>，下面是几个关键步骤：</p><ol><li><p>创建一个 <code>Secret</code> 配置，用于存放你的 Docker Hub 认证信息。将文件保存为 <code>docker-secret.yaml</code>：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">basic-user-pass</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">build.knative.dev/docker-0:</span> <span class="string">https://index.docker.io/v1/</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/basic-auth</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># Use &#x27;echo -n &quot;username&quot; | base64&#x27; to generate this string</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">BASE64_ENCODED_USERNAME</span></span><br><span class="line">  <span class="comment"># Use &#x27;echo -n &quot;password&quot; | base64&#x27; to generate this string</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">BASE64_ENCODED_PASSWORD</span></span><br></pre></td></tr></table></figure></li><li><p>上面的配置中，<code>username</code> 和 <code>password</code> 都是需要 base64 加密的。在 macOS 或 Linux 系统中，用下面的命令可以生成 base64 编码的值：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;username&quot;</span> | base64 -w 0</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;password&quot;</span> | base64 -w 0</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果在 macOS 上提示 “invalid option -w” 错误，试着改成<code>base64 -b 0</code>。</p></blockquote></li><li><p>创建一个<code>Service Account</code>配置，用于将构建进程链接到<code>Secret</code>。将文件保存为<code>service-account.yaml</code>：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build-bot</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">basic-user-pass</span></span><br></pre></td></tr></table></figure></li><li><p>创建好配置文件后，通过<code>kubectl</code>将它们应用到你的集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f docker-secret.yaml</span><br><span class="line">kubectl apply -f service-account.yaml</span><br></pre></td></tr></table></figure></li></ol><h2 id="部署示例"><a href="#部署示例" class="headerlink" title="部署示例"></a>部署示例</h2><p>本示例使用 <a href="https://github.com/mchmarny/simple-app">github.com/mchmarny/simple-app</a> 作为一个基础 Go 应用，但你也可以替换为你自己的 GitHub 项目。唯一要注意的是，项目必须包含一个<code>Dockerfile</code>来描述如何为应用构建一个容器。</p><ol><li><p>需要创建一个 service 配置来定义服务如何部署，包括源代码在哪儿、使用哪个构建模板。创建<code>service.yaml</code>并复制如下定义。将<code>&#123;DOCKER_USERNAME&#125;</code>替换为你自己的 Docker Hub 用户名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-from-source</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">runLatest:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">build.knative.dev/v1alpha1</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">serviceAccountName:</span> <span class="string">build-bot</span></span><br><span class="line">          <span class="attr">source:</span></span><br><span class="line">            <span class="attr">git:</span></span><br><span class="line">              <span class="attr">url:</span> <span class="string">https://github.com/mchmarny/simple-app.git</span></span><br><span class="line">              <span class="attr">revision:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">template:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">kaniko</span></span><br><span class="line">            <span class="attr">arguments:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">IMAGE</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">docker.io/&#123;DOCKER_USERNAME&#125;/app-from-source:latest</span></span><br><span class="line">      <span class="attr">revisionTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">container:</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">docker.io/&#123;DOCKER_USERNAME&#125;/app-from-source:latest</span></span><br><span class="line">            <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">            <span class="attr">env:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SIMPLE_MSG</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">&quot;Hello from the sample app!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>kubectl</code>应用配置，并观察结果：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f service.yaml</span><br><span class="line">kubectl get po --watch</span><br></pre></td></tr></table></figure><p> 输出类似于：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NAME                          READY     STATUS       RESTARTS   AGE</span><br><span class="line">app-from-source-00001-zhddx   0/1       Init:2/3     0          7s</span><br><span class="line">app-from-source-00001-zhddx   0/1       PodInitializing   0         37s</span><br><span class="line">app-from-source-00001-zhddx   0/1       Completed   0         38s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   0/3       Pending   0         0s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   0/3       Pending   0         0s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   0/3       Init:0/1   0         0s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   0/3       Init:0/1   0         2s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   0/3       PodInitializing   0         3s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   2/3       Running   0         6s</span><br><span class="line">app-from-source-00001-deployment-6d6ff665f9-xfhm5   3/3       Running   0         11s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 能看到先是<code>app-from-source-00001</code>启动，执行“从源码到镜像”的过程，再启动<code>app-from-source-00001-deployment</code>拉取镜像，提供服务。</p><p> 需要特别说明的是，笔者这个步骤失败了多次，都是<code>app-from-source-00001</code>初始化过程意外退出。通过<code>kubectl describe</code>查看详细信息，提示构建超时（默认构建超时是10分钟）。构建过程需要拉取一些镜像，推测可能由于网络原因，该步骤耗时过长。可以在构建过程中，通过<code>kubectl describe po app-from-source-00001-zhddx</code>查看相关 Event，找到构建具体是在哪一步耗时过长。笔者最后多试几次成功了:)</p></li><li><p>当你看到 deployment pod 变为<code>Running</code>状态时，<code>Ctrl+C</code>退出观察。此时你的容器已经完成构建和部署了！</p></li><li><p>要检查服务的状态，可以</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ksvc app-from-source --output yaml</span><br></pre></td></tr></table></figure></li><li><p>当你创建服务时，Knative 随即执行以下步骤：</p><ul><li>从 GitHub 拉取<code>revision</code>指定的代码并构建到容器中</li><li>将容器推送到 Docker Hub</li><li>为当前应用的版本创建一个新的不可变的<code>revision</code></li><li>通过网络编程为你的应用创建<code>route</code>、<code>ingress</code>、<code>service</code>和负载均衡服务</li><li>自动伸缩你的 pods（包括缩至0个活动 pods）</li></ul></li><li><p>要获取你的集群的入口 IP，使用如下命令。如果你的集群是新建的，服务获取一个外部 IP 地址可能会花一些时间：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In Knative 0.2.x and prior versions, the `knative-ingressgateway` service was used instead of `istio-ingressgateway`.</span></span><br><span class="line">INGRESSGATEWAY=knative-ingressgateway</span><br><span class="line"></span><br><span class="line"><span class="comment"># The use of `knative-ingressgateway` is deprecated in Knative v0.3.x.</span></span><br><span class="line"><span class="comment"># Use `istio-ingressgateway` instead, since `knative-ingressgateway`</span></span><br><span class="line"><span class="comment"># will be removed in Knative v0.4.</span></span><br><span class="line"><span class="keyword">if</span> kubectl get configmap config-istio -n knative-serving &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    INGRESSGATEWAY=istio-ingressgateway</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">kubectl get svc <span class="variable">$INGRESSGATEWAY</span> --namespace istio-system</span><br></pre></td></tr></table></figure><p> 需要注意的是，minikube 搭建的集群通过上面的方式是获取不到外部 IP 的。应该执行：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(minikube ip):$(kubectl get svc <span class="variable">$INGRESSGATEWAY</span> --namespace istio-system --output <span class="string">&#x27;jsonpath=&#123;.spec.ports[?(@.port==80)].nodePort&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>要找到服务的 URL，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ksvc app-from-source  --output=custom-columns=NAME:.metadata.name,DOMAIN:.status.domain</span><br></pre></td></tr></table></figure></li><li><p>现在你可以向你的应用发送一个请求来看看结果。将<code>&#123;IP_ADDRESS&#125;</code>替换为你上一步获得的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Host: app-from-source.default.example.com&quot;</span> http://&#123;IP_ADDRESS&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="清理示例应用部署"><a href="#清理示例应用部署" class="headerlink" title="清理示例应用部署"></a>清理示例应用部署</h2><p>要从你的集群移除示例应用，删除服务记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f service.yaml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于 knative 文档中的 &lt;a href=&quot;https://github.com/knative/docs/blob/master/serving/samples/source-to-url-go/README.md#orchestrating-a-source-to-url-deployment-on-kubernetes&quot;&gt;Orchestrating a source-to-URL deployment on Kubernetes&lt;/a&gt; 的简单例子，通过从源码到 URL 的部署流程一窥 Knative 给 Kubernetes 带来的改变。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="kubernetes" scheme="http://moeyui1.github.io/tags/kubernetes/"/>
    
      <category term="serverless" scheme="http://moeyui1.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 国外镜像的网络问题</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/57c40a44.html"/>
    <id>http://moeyui1.github.io/开发/57c40a44.html</id>
    <published>2019-02-20T13:24:28.000Z</published>
    <updated>2021-02-08T10:12:18.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用 Docker 或 K8s 时，经常需要拉取国外镜像，从 dockerhub 拉的镜像姑且不论，k8s 经常需要从 gcr.io 拉取镜像。手动搭建 k8s 集群时，从 gcr.io 拉取镜像由于众所周知的网络问题，经常会失败。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决这种问题的一个办法是，将镜像复制一份到自己的仓库中，如 dockerhub 就为个人用户提供了免费的镜像仓库。</p><p>当然镜像并没有简单的复制功能。常规思路是，先在畅通的网络环境下（如搭建了代理的本地环境），执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull gcr.io/xxx</span><br><span class="line"><span class="comment"># 改名为 docker.io 的用户名下的镜像</span></span><br><span class="line">docker tag gcr.io/xxx username/xxx</span><br><span class="line"><span class="comment"># 推送到远端镜像仓库</span></span><br><span class="line">docker push username/xxx</span><br></pre></td></tr></table></figure><h2 id="通过-Github-自动构建"><a href="#通过-Github-自动构建" class="headerlink" title="通过 Github 自动构建"></a>通过 Github 自动构建</h2><p>其实 dockerhub 支持联动 Github，通过指定 Github 上的 dockerfile 来自动构建镜像，省去了对代理网络环境的需要，可以使流程更简化。</p><h3 id="建立-Github-仓库"><a href="#建立-Github-仓库" class="headerlink" title="建立 Github 仓库"></a>建立 Github 仓库</h3><p>首先建立一个 Github 仓库，用于存放 dockerfile，名字随意，如 “gcr-image”。然后直接在 Github 网页上 Create new file，内容只有一行，即直接引用目标镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> gcr.io/xxx</span><br></pre></td></tr></table></figure><p>这个仓库可以存放多个 dockerfile，构建时按名字区分即可。</p><h3 id="新建-Repository"><a href="#新建-Repository" class="headerlink" title="新建 Repository"></a>新建 Repository</h3><p>接下来在 hub.docker.com 上点击 <strong>Create Repository</strong>（<em>没有账户的先注册账户</em>），然后在 Build Settings 中点击 Github 图标，关联 Github 账户：<br><img data-src="https://user-gold-cdn.xitu.io/2019/2/20/16909b212fd45c9b?w=1382&h=962&f=jpeg&s=86167" alt=""><br>选定自己的 Github Repository，然后在 BUILD RULES 中填写镜像相关信息。根据需要修改 <strong>Dockerfile location</strong> 为 Github 中对应 dockerfile 文件。建议修改 Docker Tag 与 gcr.io 中目标镜像同步。<br><img data-src="https://user-gold-cdn.xitu.io/2019/2/20/16909b483a0a42bc?w=1280&h=278&f=jpeg&s=30566" alt=""><br>最后 Create &amp; Build 就好了，需要等待 dockerhub 构建一会儿。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>构建完毕后，使用时将配置文件中 gcr.io 镜像改为 dockerhub 上的镜像就可以了。dockerhub 上个人镜像一般是 <code>docker.io/yourusername/xxx</code> 的形式。同时,每次对 Github Repository 的变更，都会触发 dockerhub 自动构建镜像，在变更镜像版本的时候尤为方便。</p>]]></content>
    
    <summary type="html">
    
      使用 Docker 或 K8s 时，经常需要拉取国外镜像，从 dockerhub 拉的镜像姑且不论，k8s 经常需要从 gcr.io 拉取镜像。手动搭建 k8s 集群时，从 gcr.io 拉取镜像由于众所周知的网络问题，经常会失败。
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="kubernetes" scheme="http://moeyui1.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Envoy 热重启实践</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/c193b63f.html"/>
    <id>http://moeyui1.github.io/开发/c193b63f.html</id>
    <published>2019-01-29T13:02:31.000Z</published>
    <updated>2021-02-08T10:12:18.751Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.envoyproxy.io/">Envoy</a> 是一个高性能的开源服务代理。本文主要介绍热重启的实践和官方热重启包装器的使用。</p><p>Envoy 支持热重启，并且为了兼容进程管理器（例如 monit、runit 等）提供了一个 Python 写的热重启包装器 <code>restart/hot-restarter.py</code>。</p><p>但是官方文档讲得不是很清楚，一开始误解了包装器的使用方式，疯狂碰壁。。。</p><h1 id="手动热重启"><a href="#手动热重启" class="headerlink" title="手动热重启"></a>手动热重启</h1><p>如果不使用包装器，手动热重启时，需要在新进程启动参数中添加 –restart-epoch x ，x表示重启纪元，按1递增。不传默认为0，故第一次启动可以不传。</p><blockquote><p>restart epoch 应该按1递增，因为在 Envoy 源码中，会按照 epoch -1 计算和 epoch +1 计算 parent address 和 child address</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HotRestartImpl::<span class="built_in">HotRestartImpl</span>(Options&amp; options)</span><br><span class="line">    : <span class="built_in">options_</span>(options), <span class="built_in">stats_set_options_</span>(<span class="built_in">blockMemHashOptions</span>(options.<span class="built_in">maxStats</span>())),</span><br><span class="line">      <span class="built_in">shmem_</span>(SharedMemory::<span class="built_in">initialize</span>(</span><br><span class="line">          RawStatDataSet::<span class="built_in">numBytes</span>(stats_set_options_, options_.<span class="built_in">statsOptions</span>()), options_)),</span><br><span class="line">      <span class="built_in">log_lock_</span>(shmem_.log_lock_), <span class="built_in">access_log_lock_</span>(shmem_.access_log_lock_),</span><br><span class="line">      <span class="built_in">stat_lock_</span>(shmem_.stat_lock_), <span class="built_in">init_lock_</span>(shmem_.init_lock_) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// We must hold the stat lock when attaching to an existing memory segment</span></span><br><span class="line">    <span class="comment">// because it might be actively written to while we sanityCheck it.</span></span><br><span class="line">    <span class="function">Thread::LockGuard <span class="title">lock</span><span class="params">(stat_lock_)</span></span>;</span><br><span class="line">    stats_set_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RawStatDataSet</span>(stats_set_options_, options.<span class="built_in">restartEpoch</span>() == <span class="number">0</span>,</span><br><span class="line">                                        shmem_.stats_set_data_, options_.<span class="built_in">statsOptions</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  my_domain_socket_ = <span class="built_in">bindDomainSocket</span>(options.<span class="built_in">restartEpoch</span>());</span><br><span class="line">  <span class="comment">// 这里计算 child address</span></span><br><span class="line">  child_address_ = <span class="built_in">createDomainSocketAddress</span>((options.<span class="built_in">restartEpoch</span>() + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">initDomainSocketAddress</span>(&amp;parent_address_);</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="built_in">restartEpoch</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里计算 parent address</span></span><br><span class="line">    parent_address_ = <span class="built_in">createDomainSocketAddress</span>((options.<span class="built_in">restartEpoch</span>() + <span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If our parent ever goes away just terminate us so that we don&#x27;t have to rely on ops/launching</span></span><br><span class="line">  <span class="comment">// logic killing the entire process tree. We should never exist without our parent.</span></span><br><span class="line">  <span class="keyword">int</span> rc = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">  <span class="built_in">RELEASE_ASSERT</span>(rc != <span class="number">-1</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包装器热重启"><a href="#包装器热重启" class="headerlink" title="包装器热重启"></a>包装器热重启</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了兼容各种进程管理，最好是用包装器将 Envoy 管理起来。这里主要介绍官方的 Python 包装器。</p><p>使用包装器即把 Envoy 的生命周期管理委托给包装器， <a href="https://istio.io/">Istio</a> 中的 <a href="https://istio.io/docs/concepts/what-is-istio/#pilot">Pilot-agent</a> 也是这样做的。启动时应启动包装器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python restart/hot-restarter.py start_envoy.sh</span><br></pre></td></tr></table></figure><p>其中 start_envoy.sh 为用户自定义的启动脚本，包装器会在每次热重启时调用这个脚本。可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">exec</span> /code/envoy-bin/envoy  -c /code/envoy.yaml --restart-epoch <span class="variable">$RESTART_EPOCH</span> </span><br></pre></td></tr></table></figure><p>其中 <code>--restart-epoch $RESTART_EPOCH</code> 参数是必要的，而 <code>$RESTART_EPOCH</code> 这个变量会由包装器设置，不需要用户理会。</p><p>包装器启动后就会把 Envoy 拉起来。包装器支持信号处理：</p><ul><li><p><strong>SIGTERM</strong>：将干净地终止所有子进程并退出。用于结束整个流程。</p></li><li><p><strong>SIGHUP</strong>：将重新调用作为第一个参数传递给热重启程序的脚本，来进行热重启。</p></li><li><p><strong>SIGCHLD</strong>：如果任何子进程意外关闭，那么重启脚本将关闭所有内容并退出以避免处于意外状态。随后，控制进程管理器应该重新启动重启脚本以再次启动 Envoy。这个信号通常又 Envoy 传递给包装器。</p></li><li><p><strong>SIGUSR1</strong>：将作为重新打开所有访问日志的信号，转发给 Envoy。可用于原子移动以及重新打开日志轮转。</p></li></ul><p>故使用时，可以通过向包装器发送信号来控制 Envoy 的生命周期。热重启时，可以通过 <code>kill -1 pid</code> 向包装器进程发送 <strong>sighup</strong> 信号，让其热重启。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>首先看 main 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot; Script main. This script is designed so that a process watcher like runit or monit can watch</span></span><br><span class="line"><span class="string">      this process and take corrective action if it ever goes away. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;starting hot-restarter with target: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(sys.argv[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">  signal.signal(signal.SIGTERM, sigterm_handler)</span><br><span class="line">  signal.signal(signal.SIGHUP, sighup_handler)</span><br><span class="line">  signal.signal(signal.SIGCHLD, sigchld_handler)</span><br><span class="line">  signal.signal(signal.SIGUSR1, sigusr1_handler)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Start the first child process and then go into an endless loop since everything else happens via</span></span><br><span class="line">  <span class="comment"># signals.</span></span><br><span class="line">  fork_and_exec()</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>再看 <code>fork_and_exec</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># 文件头定义了一个全局变量保存 epoch</span></span><br><span class="line">restart_epoch = <span class="number">0</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fork_and_exec</span>():</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot; This routine forks and execs a new child process and keeps track of its PID. Before we fork,</span></span><br><span class="line"><span class="string">      set the current restart epoch in an env variable that processes can read if they care. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 引用全局变量</span></span><br><span class="line">  <span class="keyword">global</span> restart_epoch</span><br><span class="line">  <span class="comment"># 设置环境变量，主要是为了后续脚本使用</span></span><br><span class="line">  os.environ[<span class="string">&#x27;RESTART_EPOCH&#x27;</span>] = <span class="built_in">str</span>(restart_epoch)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;forking and execing new child process at epoch &#123;&#125;&quot;</span>.<span class="built_in">format</span>(restart_epoch))</span><br><span class="line">  restart_epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  child_pid = os.fork()</span><br><span class="line">  <span class="keyword">if</span> child_pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># Child process</span></span><br><span class="line">    <span class="comment"># 执行脚本</span></span><br><span class="line">    os.execl(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Parent process</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;forked new child process with PID=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(child_pid))</span><br><span class="line">    <span class="comment"># 将 pid 保存起来，退出时全部 kill 掉</span></span><br><span class="line">    pid_list.append(child_pid)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/hot_restart.html">官方文档</a> 关于热重启；</li><li><a href="https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5">Envoy hot restart</a> 关于热重启设计的官方文档；</li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/operations/hot_restarter">官方文档</a> 关于热重启包装器。</li></ol>]]></content>
    
    <summary type="html">
    
      Envoy 支持热重启，本文主要介绍热重启的实践和官方热重启包装器的使用
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="envoy" scheme="http://moeyui1.github.io/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>Envoy service mesh、Prometheus和Grafana下的微服务监控（翻译）</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/5b9f8a4a.html"/>
    <id>http://moeyui1.github.io/开发/5b9f8a4a.html</id>
    <published>2018-11-25T11:05:34.000Z</published>
    <updated>2021-02-08T10:12:18.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://medium.com/@dnivra26/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana-a1c26a8595fc">https://medium.com/@dnivra26/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana-a1c26a8595fc</a></p></blockquote><p>如果你刚接触“Service Mesh“和“Envoy”，我<a href="https://medium.com/@dnivra26/service-mesh-with-envoy-101-e6b2131ee30b">这里</a>有一篇文章可以帮你入门。</p><p>这是<strong>Envoy service mesh下的可观测性</strong>系列的第二篇文章，你可以在<a href="https://medium.com/@dnivra26/distributed-tracing-with-envoy-service-mesh-jaeger-c365b6191592">这里</a>阅读第一篇关于分布式追踪的文章。</p><p>在微服务中谈及监控时，你可不能被蒙在鼓里，至少要知道问题出在哪儿了。</p><p>让我们看看Envoy是怎样帮助我们了解我们的服务运行状况的。在service mesh下，所有的通信都会通过mesh，这意味着没有任何服务会与其它服务直接通信，服务向Envoy发起调用请求，然后Envoy将调用请求路由到目标服务，所以Envoy将持有传入和传出流量的上下文。Envoy通常提供关于<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/stats">传入</a>请求、<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/cluster_manager/cluster_stats">传出</a>请求和<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/statistics">Envoy实例状态</a>的指标。</p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>这是我们将要构建的系统概览。</p><p><img data-src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwx6wg1dscj30m90cg0sy.jpg" alt="overall setup"></p><h2 id="Statsd"><a href="#Statsd" class="headerlink" title="Statsd"></a>Statsd</h2><p>Envoy支持通过两到三种格式来暴露指标，但本文中我们将使用<a href="https://github.com/b/statsd_spec">statsd</a>格式。</p><p>所以流程将是这样，首先Envoy推送指标到statsd，然后我们用<a href="https://github.com/prometheus">prometheus</a>（一个时序数据库）从statsd拉取指标，最后通过<a href="https://github.com/grafana/grafana">grafana</a>可视化这些指标。</p><p>在准备概览图中，我提到了statsd exporter而不是statsd，这是因为我们并不会直接使用statsd，而是使用一个接收statsd格式数据，并将其以prometheus格式输出的转换器（服务）。下面让我们来搞定它吧。</p><p>Envoy的指标主要分为两类：</p><ol><li>Counter（计数器）：一个只增不减的指标。如：请求总数</li><li>Gauge（量表）：一个可增可减的指标，类似于一个瞬时值。如：当前CPU使用量</li></ol><p>让我们看一个包含stats sink的Envoy配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">&quot;/tmp/admin_access.log&quot;</span></span><br><span class="line">  <span class="attr">address:</span> </span><br><span class="line">    <span class="attr">socket_address:</span> </span><br><span class="line">      <span class="attr">address:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      <span class="attr">port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">stats_sinks:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;envoy.statsd&quot;</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">tcp_cluster_name:</span> <span class="string">&quot;statsd-exporter&quot;</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">front-envoy</span>    </span><br><span class="line"><span class="attr">static_resources:</span> </span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">    <span class="bullet">-</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;http_listener&quot;</span></span><br><span class="line">      <span class="attr">address:</span> </span><br><span class="line">        <span class="attr">socket_address:</span> </span><br><span class="line">          <span class="attr">address:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">          <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">filter_chains:</span></span><br><span class="line">          <span class="attr">filters:</span> </span><br><span class="line">            <span class="bullet">-</span> </span><br><span class="line">              <span class="attr">name:</span> <span class="string">&quot;envoy.http_connection_manager&quot;</span></span><br><span class="line">              <span class="attr">config:</span></span><br><span class="line">                <span class="attr">use_remote_address:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">add_user_agent:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">access_log:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.file_access_log</span></span><br><span class="line">                  <span class="attr">config:</span></span><br><span class="line">                    <span class="attr">path:</span> <span class="string">/dev/stdout</span></span><br><span class="line">                    <span class="attr">format:</span> <span class="string">&quot;[ACCESS_LOG][%START_TIME%] \&quot;%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\&quot; %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% \&quot;%REQ(X-FORWARDED-FOR)%\&quot; \&quot;%REQ(USER-AGENT)%\&quot; \&quot;%REQ(X-REQUEST-ID)%\&quot; \&quot;%REQ(:AUTHORITY)%\&quot; \&quot;%UPSTREAM_HOST%\&quot; \&quot;%DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT%\&quot;\n&quot;</span></span><br><span class="line">                <span class="attr">stat_prefix:</span> <span class="string">&quot;ingress_443&quot;</span></span><br><span class="line">                <span class="attr">codec_type:</span> <span class="string">&quot;AUTO&quot;</span></span><br><span class="line">                <span class="attr">generate_request_id:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">route_config:</span> </span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;local_route&quot;</span></span><br><span class="line">                  <span class="attr">virtual_hosts:</span> </span><br><span class="line">                    <span class="bullet">-</span> </span><br><span class="line">                      <span class="attr">name:</span> <span class="string">&quot;http-route&quot;</span></span><br><span class="line">                      <span class="attr">domains:</span> </span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                      <span class="attr">routes:</span> </span><br><span class="line">                        <span class="bullet">-</span> </span><br><span class="line">                          <span class="attr">match:</span> </span><br><span class="line">                            <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                          <span class="attr">route:</span></span><br><span class="line">                            <span class="attr">cluster:</span> <span class="string">&quot;service_a&quot;</span></span><br><span class="line">                <span class="attr">http_filters:</span></span><br><span class="line">                  <span class="bullet">-</span> </span><br><span class="line">                    <span class="attr">name:</span> <span class="string">&quot;envoy.router&quot;</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;statsd&quot;</span></span><br><span class="line">      <span class="attr">connect_timeout:</span> <span class="string">&quot;0.25s&quot;</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">&quot;strict_dns&quot;</span></span><br><span class="line">      <span class="attr">lb_policy:</span> <span class="string">&quot;ROUND_ROBIN&quot;</span></span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span></span><br><span class="line">          <span class="attr">socket_address:</span></span><br><span class="line">            <span class="attr">address:</span> <span class="string">&quot;statsd_exporter&quot;</span></span><br><span class="line">            <span class="attr">port_value:</span> <span class="number">9125</span></span><br><span class="line">    <span class="bullet">-</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;service_a&quot;</span></span><br><span class="line">      <span class="attr">connect_timeout:</span> <span class="string">&quot;0.25s&quot;</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">&quot;strict_dns&quot;</span></span><br><span class="line">      <span class="attr">lb_policy:</span> <span class="string">&quot;ROUND_ROBIN&quot;</span></span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> </span><br><span class="line">          <span class="attr">socket_address:</span> </span><br><span class="line">            <span class="attr">address:</span> <span class="string">&quot;service_a_envoy&quot;</span></span><br><span class="line">            <span class="attr">port_value:</span> <span class="number">8786</span></span><br></pre></td></tr></table></figure><p>第8-13行告诉Envoy我们需要statsd格式的指标、我们的统计信息前缀（通常是你的服务名）是什么和statsd sink的地址。</p><p>第55-63行配置了我们的环境中的statsd sink。</p><p>这就是让Envoy输出统计信息所需要的所有配置。现在让我们来看看第2-7行做了哪些事情：</p><ol><li>Envoy在9901端口暴露了一个管理端，你可以通过它动态地改变日志级别，查看当前配置、统计数据等</li><li>Envoy也可以生成与nginx类似的访问日志，你可以通过它了解服务间的通信状况。访问日志的格式也是可配置的，如第29-33行</li></ol><p>你需要将相同的配置添加到系统中的其它Envoy sidecar上（是的，每个服务都有自己的Envoy sidecar）。</p><p>这些服务本身是用go写的，它们做的事情很简单，仅仅是通过Envoy调用其它服务。你可以在<a href="https://github.com/dnivra26/envoy_monitoring">这里</a>查看服务和Envoy的配置。</p><p>现在，虽然我们只有图中的statsd exporter，但有了它，如果我们运行docker容器（docker-compose build &amp; docker-compose up），然后向Front Envoy（localhost:8080）发送一些流量，Envoy 将把这些流量的指标发送到statsd exporter，随后statsd exporter会把这些指标转换成prometheus格式，并将其暴露在9102端口。</p><p>Statsd exporter中的统计信息格式如下图所示</p><p><img data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwxf9t7t5bj318g0azgof.jpg" alt="来自statsd exporter的prometheus格式的指标"></p><p>这里边将有上百个指标，同时，在上面的截图中我们能看到Service A和Service B之间的通信延迟指标。上图的指标是遵循prometheus格式的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric_name [&quot;&#123;&quot; label_name &quot;=&quot; `&quot;` label_value `&quot;` &#123; &quot;,&quot; label_name &quot;=&quot; `&quot;` label_value `&quot;` &#125; [ &quot;,&quot; ] &quot;&#125;&quot;] value [ timestamp ]</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md">这里</a>了解更多。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>我们将使用<a href="https://prometheus.io/">Prometheus</a>作为时序数据库来保存我们的指标。Prometheus不仅是一个时序数据库，它本身还是一个监控系统，但本文我们只用它来存储指标数据。需要注意的是，prometheus是一个通过主动拉取来获取指标的系统，这意味着你必须告诉prometheus从何处拉取指标，在我们的例子中是从statsd exporter处拉取。</p><p>将Prometheus添加到系统中非常简单而又直接，我们只需要将拉取目标（statsd exporter）作为配置文件传递给Prometheus就可以了。配置看起来是这样的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>  <span class="string">15s</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;statsd&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;statsd_exporter:9102&#x27;</span>]</span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">&#x27;services&#x27;</span></span><br></pre></td></tr></table></figure><p>scrape_interval的值表示Prometheus从目标处拉取配置的频率。</p><p>现在启动Prometheus，里面应该有一些数据了。让我们打开localhost:9090来看一看</p><p><img data-src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwy55z3klmj31jk0f6gmd.jpg" alt="prometheus查询页面"></p><p>如图所示，可以看到我们的指标。你能做的可不仅仅是选择已有的指标，从<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">这里</a>可以阅读关于prometheus查询语言的更多信息。它还可以基于查询结果绘制图表，除此之外还有一个报警系统。</p><p>如果我们打开prometheus的targets页面，将能看到所有的拉取目标和它们的健康状态</p><p><img data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwy5occy0pj31jk0gbjs6.jpg" alt="prometheus目标"></p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana是一个很棒的监控可视化解决方案，它支持Prometheus，Graphite，InfluxDB，ElasticSearch等多种后端。</p><p>Grafana有两大主要组件需要我们配置</p><ol><li><p>数据源（Datasource）：指定grafana从哪个后端获取指标。你可以通过配置文件来配置数据源，代码如下所示</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datasources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">access:</span> <span class="string">Server</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://prometheus:9090</span></span><br><span class="line">    <span class="attr">editable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">isDefault:</span></span><br></pre></td></tr></table></figure></li><li><p>仪表盘（Dashboard）：你可以从仪表盘查看来自数据源的指标。Grafana支持多种可视化元素，如Graphs，Single Stats，Heatmaps……你可以继承这些元素并使用插件来构造自己的元素。</p></li></ol><p>我在使用Grafana时遇到的唯一一个问题是，缺少一种标准的方法来用代码开发那些仪表盘。所幸有一些第三方的库提供了支持，我们将使用来自weaveworks的<a href="https://github.com/weaveworks/grafanalib">grafanalib</a>。</p><p>下面是我们通过 python 代码尝试构建的一个仪表盘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> grafanalib.core <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dashboard = Dashboard(</span><br><span class="line">    title=<span class="string">&quot;Services Dashboard&quot;</span>,</span><br><span class="line">    templating=Templating(</span><br><span class="line">        [</span><br><span class="line">            Template(</span><br><span class="line">                name=<span class="string">&quot;source&quot;</span>,</span><br><span class="line">                dataSource=<span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">                query=<span class="string">&quot;metrics(.*_cluster_.*_upstream_rq_2xx)&quot;</span>,</span><br><span class="line">                regex=<span class="string">&quot;/(.*)_cluster_.*_upstream_rq_2xx/&quot;</span>,</span><br><span class="line">                default=<span class="string">&quot;service_a&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            Template(</span><br><span class="line">                name=<span class="string">&quot;destination&quot;</span>,</span><br><span class="line">                dataSource=<span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">                query=<span class="string">&quot;metrics(.*_cluster_.*_upstream_rq_2xx)&quot;</span>,</span><br><span class="line">                regex=<span class="string">&quot;/.*_cluster_(.*)_upstream_rq_2xx/&quot;</span>,</span><br><span class="line">                default=<span class="string">&quot;service_b&quot;</span></span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">    rows=[</span><br><span class="line">        Row(</span><br><span class="line">            panels=[</span><br><span class="line">                Graph(</span><br><span class="line">                    title=<span class="string">&quot;2XX&quot;</span>,</span><br><span class="line">                    transparent=<span class="literal">True</span>,</span><br><span class="line">                    dataSource=<span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">                    targets=[</span><br><span class="line">                        Target(</span><br><span class="line">                            expr=<span class="string">&quot;[[source]]_cluster_[[destination]]_upstream_rq_2xx - [[source]]_cluster_[[destination]]_upstream_rq_2xx offset $__interval&quot;</span>,</span><br><span class="line">                            legendFormat=<span class="string">&quot;2xx&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                    ]</span><br><span class="line">                ),</span><br><span class="line">                Graph(</span><br><span class="line">                    title=<span class="string">&quot;5XX&quot;</span>,</span><br><span class="line">                    transparent=<span class="literal">True</span>,</span><br><span class="line">                    dataSource=<span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">                    targets=[</span><br><span class="line">                        Target(</span><br><span class="line">                            expr=<span class="string">&quot;[[source]]_cluster_[[destination]]_upstream_rq_5xx - [[source]]_cluster_[[destination]]_upstream_rq_5xx offset $__interval&quot;</span>,</span><br><span class="line">                            legendFormat=<span class="string">&quot;5xx&quot;</span></span><br><span class="line">                        ),</span><br><span class="line">                    ]</span><br><span class="line">                ),</span><br><span class="line">                Graph(</span><br><span class="line">                    title=<span class="string">&quot;Latency&quot;</span>,</span><br><span class="line">                    transparent=<span class="literal">True</span>,</span><br><span class="line">                    dataSource=<span class="string">&quot;prometheus&quot;</span>,</span><br><span class="line">                    targets=[</span><br><span class="line">                        Target(</span><br><span class="line">                            expr=<span class="string">&quot;[[source]]_cluster_[[destination]]_upstream_rq_time&quot;</span>,</span><br><span class="line">                            legendFormat=<span class="string">&quot;&#123;&#123;quantile&#125;&#125;&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                    ]</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">    ]</span><br><span class="line">).auto_panel_ids()</span><br></pre></td></tr></table></figure><p>在这段代码中，我们为2xx，5xx和延迟数据构建了图表。其中第5-22行很重要，它从我们的设置中提取可用的service names作为grafana的变量，为我们创建一个动态的仪表盘，这意味着我们能够选择性地查看特定源服务和目标服务的统计数据。如果想了解更多关于变量的内容请参考<a href="http://docs.grafana.org/reference/templating/">这里</a>。</p><p>你需要通过grafanalib命令来从上述python文件生成仪表盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate-dashboard -o dashboard.json service-dashboard.py</span><br></pre></td></tr></table></figure><p>注意这里生成的dashboard.json可不容易阅读。</p><p>所以，启动Grafana时我们只需要传递仪表盘和数据源就好了。当访问http:localhost:3000时，你将看到：</p><p><img data-src="https://ws4.sinaimg.cn/large/006tNbRwly1fx6n732mrdj31jk0h7jsc.jpg" alt="grafana仪表盘"></p><p>现在你应该能看到2xx，5xx和延迟的图表，同时还能看到一个下拉菜单，你可以通过它选择源服务和目标服务。关于Grafana还有许多内容我们没有讨论到，包括强大的查询编辑器和告警系统。更重要的是，这一切都是可以通过插件和应用扩展的，可以参考<a href="https://github.com/grafana/kubernetes-app">这里</a>的例子。如果你正想可视化常见服务如redis，rabbitmq等的指标，grafana有一个<a href="https://grafana.com/dashboards">公共仪表盘</a>库，你只需要导入它们就可以使用了。使用Grafana 还有一个好处，你可以通过配置文件和代码创建和管理所有东西，而不需要过多地通过UI来操作。</p><p>我建议你试用一下prometheus和grafana以了解更多信息。感谢阅读，如有建议和意见，请写在评论中。</p><p>在<a href="https://github.com/dnivra26/envoy_monitoring/">这里</a>可以找到所有代码和配置文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@dnivra26/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana-a1c26a8595fc&quot;&gt;https://medium.com/@dnivra26/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana-a1c26a8595fc&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你刚接触“Service Mesh“和“Envoy”，我&lt;a href=&quot;https://medium.com/@dnivra26/service-mesh-with-envoy-101-e6b2131ee30b&quot;&gt;这里&lt;/a&gt;有一篇文章可以帮你入门。&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;Envoy service mesh下的可观测性&lt;/strong&gt;系列的第二篇文章，你可以在&lt;a href=&quot;https://medium.com/@dnivra26/distributed-tracing-with-envoy-service-mesh-jaeger-c365b6191592&quot;&gt;这里&lt;/a&gt;阅读第一篇关于分布式追踪的文章。&lt;/p&gt;
&lt;p&gt;在微服务中谈及监控时，你可不能被蒙在鼓里，至少要知道问题出在哪儿了。&lt;/p&gt;
&lt;p&gt;让我们看看Envoy是怎样帮助我们了解我们的服务运行状况的。在service mesh下，所有的通信都会通过mesh，这意味着没有任何服务会与其它服务直接通信，服务向Envoy发起调用请求，然后Envoy将调用请求路由到目标服务，所以Envoy将持有传入和传出流量的上下文。Envoy通常提供关于&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/stats&quot;&gt;传入&lt;/a&gt;请求、&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/cluster_manager/cluster_stats&quot;&gt;传出&lt;/a&gt;请求和&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/statistics&quot;&gt;Envoy实例状态&lt;/a&gt;的指标。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="service mesh" scheme="http://moeyui1.github.io/tags/service-mesh/"/>
    
      <category term="Envoy" scheme="http://moeyui1.github.io/tags/Envoy/"/>
    
      <category term="翻译" scheme="http://moeyui1.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>gRPC Bidirectional（双向流）源码分析</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/d1717587.html"/>
    <id>http://moeyui1.github.io/开发/d1717587.html</id>
    <published>2018-10-13T11:26:28.000Z</published>
    <updated>2021-02-08T10:12:18.754Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 是一个优秀的开源 RPC 框架，它能够实现双向流式调用。本文从源码的角度出发，分层剖析 gRPC 流式调用的实现。</p><p><img data-src="https://s1.ax1x.com/2018/10/13/iN7ZfU.png" alt="iN7ZfU.png"></p><span id="more"></span><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>从高层上看，gRPC 可分为三层: <strong>Stub/桩</strong>, <strong>Channel/通道</strong> &amp; <strong>Transport/传输</strong>.</p><h2 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h2><blockquote><p>The Stub layer is what is exposed to most developers and provides type-safe bindings to whatever datamodel/IDL/interface you are adapting. gRPC comes with a <a href="https://github.com/google/grpc-java/blob/master/compiler">plugin</a> to the protocol-buffers compiler that generates Stub interfaces out of .protofiles, but bindings to other datamodel/IDL are easy and encouraged.</p></blockquote><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote><p>The Channel layer is an abstraction over Transport handling that is suitable for interception/decoration and exposes more behavior to the application than the Stub layer. It is intended to be easy for application frameworks to use this layer to address cross-cutting concerns such as logging, monitoring, auth, etc.</p></blockquote><p>Channel 层是 Transport 层处理上的抽象，适合 interception/decoration ，并暴露更多行为给应用（相比 Stub 层）。它的目的是为了使应用框架利用改成方便地实现 address cross-cutting 例如日志、监控、鉴权等。</p><h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>The Transport layer does the heavy lifting of putting and taking bytes off the wire. The interfaces to it are abstract just enough to allow plugging in of different implementations. Note the transport layer API is considered internal to gRPC and has weaker API guarantees than the core API under package io.grpc.</p><p>gRPC 自带3种 Transport 实现:</p><ol><li>Netty-based transport 是主要的 transport 实现，基于 Netty。为客户端和服务端使用。</li><li>OkHttp-based transport 是一个轻量级的 transport，基于 OkHttp。这主要被用在 Android 上，只能用在客户端。</li><li>In-Process transport 是为服务端和客户端在同一进程时准备的。它对测试很有用，在生产环境也很安全。</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>以 gRPC 官方的 examples 为例看下表层的情况。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Bi-directional example, which can only be asynchronous. Send some chat messages, and print any</span></span><br><span class="line"><span class="comment">  * chat messages that are sent from the server.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">routeChat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   info(<span class="string">&quot;*** RouteChat&quot;</span>);</span><br><span class="line">   <span class="keyword">final</span> CountDownLatch finishLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">   StreamObserver&lt;RouteNote&gt; requestObserver =</span><br><span class="line">       <span class="comment">// 方法调用还未开始，从这里获得一个 StreamObserver，用于传递请求流</span></span><br><span class="line">       asyncStub.routeChat(<span class="keyword">new</span> StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">         <span class="comment">// 自实现 StreamObserver，gRPC 会在适当时机调用下面的方法</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(RouteNote note)</span> </span>&#123;</span><br><span class="line">           info(<span class="string">&quot;Got message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;</span>, note.getMessage(), note.getLocation()</span><br><span class="line">               .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">           warning(<span class="string">&quot;RouteChat Failed: &#123;0&#125;&quot;</span>, Status.fromThrowable(t));</span><br><span class="line">           finishLatch.countDown();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           info(<span class="string">&quot;Finished RouteChat&quot;</span>);</span><br><span class="line">           finishLatch.countDown();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     RouteNote[] requests =</span><br><span class="line">         &#123;newNote(<span class="string">&quot;First message&quot;</span>, <span class="number">0</span>, <span class="number">0</span>), newNote(<span class="string">&quot;Second message&quot;</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">             newNote(<span class="string">&quot;Third message&quot;</span>, <span class="number">1</span>, <span class="number">0</span>), newNote(<span class="string">&quot;Fourth message&quot;</span>, <span class="number">1</span>, <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (RouteNote request : requests) &#123;</span><br><span class="line">       info(<span class="string">&quot;Sending message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;</span>, request.getMessage(), request.getLocation()</span><br><span class="line">           .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">       <span class="comment">// 通过 StreamObserver 不断发送请求流</span></span><br><span class="line">       requestObserver.onNext(request);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">     <span class="comment">// Cancel RPC</span></span><br><span class="line">     requestObserver.onError(e);</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Mark the end of requests</span></span><br><span class="line">   requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// return the latch while receiving happens asynchronously</span></span><br><span class="line">   <span class="keyword">return</span> finishLatch;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Receives a stream of message/location pairs, and responds with a stream of all previous</span></span><br><span class="line"><span class="comment">    * messages at each of those locations.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> responseObserver an observer to receive the stream of previous messages.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an observer to handle requested message/location pairs.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="comment">// 传入参数是由 gRPC 生成的一个 StreamObserver，通过它可以实现流式响应</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StreamObserver&lt;RouteNote&gt; <span class="title">routeChat</span><span class="params">(<span class="keyword">final</span> StreamObserver&lt;RouteNote&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 这个 StreamObserver 在适当时机被 gRPC 调用</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(RouteNote note)</span> </span>&#123;</span><br><span class="line">         List&lt;RouteNote&gt; notes = getOrCreateNotes(note.getLocation());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Respond with all previous notes at this location.</span></span><br><span class="line">         <span class="keyword">for</span> (RouteNote prevNote : notes.toArray(<span class="keyword">new</span> RouteNote[<span class="number">0</span>])) &#123;</span><br><span class="line">           responseObserver.onNext(prevNote);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Now add the new note to the list</span></span><br><span class="line">         notes.add(note);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">         logger.log(Level.WARNING, <span class="string">&quot;routeChat cancelled&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         responseObserver.onCompleted();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="StreamObserver"><a href="#StreamObserver" class="headerlink" title="StreamObserver"></a>StreamObserver</h2><p>看了上面的代码可以知道，StreamObserver 正是 gRPC 在 Stub 层提供的一个流式 Observer，通过它可以实现接收和发送流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.grpc.stub;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Receives notifications from an observable stream of messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is used by both the client stubs and service implementations for sending or receiving</span></span><br><span class="line"><span class="comment"> * stream messages. It is used for all &#123;<span class="doctag">@link</span> io.grpc.MethodDescriptor.MethodType&#125;, including</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> UNARY&#125; calls.  For outgoing messages, a &#123;<span class="doctag">@code</span> StreamObserver&#125; is provided by the GRPC</span></span><br><span class="line"><span class="comment"> * library to the application. For incoming messages, the application implements the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> StreamObserver&#125; and passes it to the GRPC library for receiving.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations are not required to be thread-safe (but should be</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;http://www.ibm.com/developerworks/library/j-jtp09263/&quot;&gt;thread-compatible&lt;/a&gt;).</span></span><br><span class="line"><span class="comment"> * Separate &#123;<span class="doctag">@code</span> StreamObserver&#125;s do</span></span><br><span class="line"><span class="comment"> * not need to be synchronized together; incoming and outgoing directions are independent.</span></span><br><span class="line"><span class="comment"> * Since individual &#123;<span class="doctag">@code</span> StreamObserver&#125;s are not thread-safe, if multiple threads will be</span></span><br><span class="line"><span class="comment"> * writing to a &#123;<span class="doctag">@code</span> StreamObserver&#125; concurrently, the application must synchronize calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamObserver</span>&lt;<span class="title">V</span>&gt;  </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Receives a value from the stream.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Can be called many times but is never called after &#123;<span class="doctag">@link</span> #onError(Throwable)&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * #onCompleted()&#125; are called.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Unary calls must invoke onNext at most once.  Clients may invoke onNext at most once for</span></span><br><span class="line"><span class="comment">   * server streaming calls, but may receive many onNext callbacks.  Servers may invoke onNext at</span></span><br><span class="line"><span class="comment">   * most once for client streaming calls, but may receive many onNext callbacks.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If an exception is thrown by an implementation the caller is expected to terminate the</span></span><br><span class="line"><span class="comment">   * stream by calling &#123;<span class="doctag">@link</span> #onError(Throwable)&#125; with the caught exception prior to</span></span><br><span class="line"><span class="comment">   * propagating it.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value passed to the stream</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(V value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Receives a terminating error from the stream.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;May only be called once and if called it must be the last method called. In particular if an</span></span><br><span class="line"><span class="comment">   * exception is thrown by an implementation of &#123;<span class="doctag">@code</span> onError&#125; no further calls to any method are</span></span><br><span class="line"><span class="comment">   * allowed.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;&#123;<span class="doctag">@code</span> t&#125; should be a &#123;<span class="doctag">@link</span> io.grpc.StatusException&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * io.grpc.StatusRuntimeException&#125;, but other &#123;<span class="doctag">@code</span> Throwable&#125; types are possible. Callers should</span></span><br><span class="line"><span class="comment">   * generally convert from a &#123;<span class="doctag">@link</span> io.grpc.Status&#125; via &#123;<span class="doctag">@link</span> io.grpc.Status#asException()&#125; or</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> io.grpc.Status#asRuntimeException()&#125;. Implementations should generally convert to a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> Status&#125; via &#123;<span class="doctag">@link</span> io.grpc.Status#fromThrowable(Throwable)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> t the error occurred on the stream</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Receives a notification of successful stream completion.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;May only be called once and if called it must be the last method called. In particular if an</span></span><br><span class="line"><span class="comment">   * exception is thrown by an implementation of &#123;<span class="doctag">@code</span> onCompleted&#125; no further calls to any method</span></span><br><span class="line"><span class="comment">   * are allowed.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h1><p>整个实现是建立在复杂的监听模式基础上的。以 Client 端为视角：</p><p><img data-src="https://oeoiy7i1f.qnssl.com/gRPC%E5%8F%8C%E5%90%91%E6%B5%81/drawio.svg" alt="drawio"></p><p>Server 端视角可触类旁通。</p><h1 id="分层分析"><a href="#分层分析" class="headerlink" title="分层分析"></a>分层分析</h1><p>上面的一图比较多比较乱，下面来逐层分析。</p><h2 id="Stub-层"><a href="#Stub-层" class="headerlink" title="Stub 层"></a>Stub 层</h2><p>这一层关注 <code>StreamObserver</code>，它的代码上文已经贴过了。使用者就是通过它实现流式通信。结合上文的源码分析，可以得到以下结论：</p><ul><li>对于客户端来说，resp 由 gRPC 生成并返回，req 则是客户端自行实现 <code>StreamObserver</code>。</li><li>对于服务端来说，req 由 gRPC 生成并作为入参交给服务端方法，resp 则是服务端自己实现并返回给 gRPC。</li></ul><p>模糊的地方就在 gRPC 如何生成一个 <code>StreamObserver</code>。以客户端为例分析：</p><p><img data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw5gx3xqspj30ds0843yj.jpg" alt=""></p><p>发起请求时，首先通过 Channel 获得一个 <code>ClientCall</code>，这个 call 是 Channel 层的，在 Stub 层客户端需要使用 <code>StreamObserver</code>，故使用了一个 <code>CallToStreamObserverAdapter</code> 来将 call 包起来返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallToStreamObserverAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ClientCallStreamObserver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> frozen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientCall&lt;T, ?&gt; call;</span><br><span class="line">    <span class="keyword">private</span> Runnable onReadyHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> autoFlowControlEnabled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non private to avoid synthetic class</span></span><br><span class="line">    CallToStreamObserverAdapter(ClientCall&lt;T, ?&gt; call) &#123;</span><br><span class="line">      <span class="keyword">this</span>.call = call;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">freeze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.frozen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      call.sendMessage(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">      call.cancel(<span class="string">&quot;Cancelled by client with StreamObserver.onError()&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      call.halfClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> call.isReady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnReadyHandler</span><span class="params">(Runnable onReadyHandler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (frozen) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot alter onReadyHandler after call started&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.onReadyHandler = onReadyHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableAutoInboundFlowControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (frozen) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot disable auto flow control call started&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      autoFlowControlEnabled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      call.request(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageCompression</span><span class="params">(<span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">      call.setMessageCompression(enable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="meta">@Nullable</span> String message, <span class="meta">@Nullable</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">      call.cancel(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看了 <code>CallToStreamObserverAdapter</code> 的源码，就知道客户端在调用 <code>StreamObserver.next(value)</code> 方法时，实际就是调用了 <code>call.sendMessage(value)</code> 发送消息。其实 <code>CallToStreamObserverAdapter</code> 就是 <code>ClientCall</code> 在 Stub 层的适配器。</p><p>上面说的都是请求的 <code>StreamObserver</code>，那响应的 <code>StreamObserver</code> 呢？因为客户端已经在自实现的 <code>StreamObserver</code> 中实现了对响应的处理方法，所以客户端后续已经不需要与响应的 <code>StreamObserver</code> 交互了，所以这个自实现的 <code>StreamObserver</code> 直接被传到了 Channel 层。</p><h2 id="Channel-层"><a href="#Channel-层" class="headerlink" title="Channel 层"></a>Channel 层</h2><p>这一层逻辑开始复杂，也是本文主要关注的层级。这层主要关注一个 ClientCallImpl 和一个 StreamObserverToCallListenerAdapter。</p><p><img data-src="https://ws1.sinaimg.cn/large/006tNbRwgy1fw5h0qf5vvj30et09yjrj.jpg" alt=""></p><p>先看 ClientCallImpl，它是 ClientCall 的实现类，它内部持有一个 ClientCall.Listener，这是用来监听什么的呢？</p><p>上面 Stub 层末尾讲到响应的 StreamObserver 传到了 Channel 层，实际就是到了 StreamObserverToCallListenerAdapter 的 observer 中。<em>gRPC 的命名都很直白。</em>而其中的 adapter 就是 stub 层的 CallToStreamObserverAdapter。它持有两个 StreamObserver 想干啥？</p><p>实际上 StreamObserverToCallListenerAdapter 接管了两个 StreamObserver 的监听，合并成一个 ClientCall.Listener 去监听 ClientCallImpl，到这里，自定义的监听终于和请求绑定在一起了。</p><p>ClientCallImpl 内部封装了诸如消息发送等网络细节，通过它持有的 ClientStream 类型引用实现。这是 Transport 层的概念了。</p><h2 id="Transport-层"><a href="#Transport-层" class="headerlink" title="Transport 层"></a>Transport 层</h2><p>这一层就更复杂些，可对接多种实现，本文不做讨论<del>（偷懒了</del>。</p><h2 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h2><p>gRPC 基于 Http2，多路复用是 Http2 的一大特性。这一特性得益于 frame 的设计，<strong>frame 的 Header 中标识了它属于的流</strong>。</p><p><img data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw5h2ljh83j314w06it9j.jpg" alt=""></p><h1 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h1><p>流式消息必然存在消息顺序性的问题，在 <code>ClientCall.java</code> 中提到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests up to the given number of messages from the call to be delivered to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Listener#onMessage(Object)&#125;. No additional messages will be delivered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Message delivery is guaranteed to be sequential in the order received. In addition, the</span></span><br><span class="line"><span class="comment"> * listener methods will not be accessed concurrently. While it is not guaranteed that the same</span></span><br><span class="line"><span class="comment"> * thread will always be used, it is guaranteed that only a single thread will access the listener</span></span><br><span class="line"><span class="comment"> * at a time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If it is desired to bypass inbound flow control, a very large number of messages can be</span></span><br><span class="line"><span class="comment"> * specified (e.g. &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If called multiple times, the number of messages able to delivered will be the sum of the</span></span><br><span class="line"><span class="comment"> * calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is safe to call from multiple threads without external synchronization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numMessages the requested number of messages to be delivered to the listener. Must be</span></span><br><span class="line"><span class="comment"> *                    non-negative.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if call is not &#123;<span class="doctag">@code</span> start()&#125;ed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if numMessages is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> numMessages)</span></span>;</span><br></pre></td></tr></table></figure><p>由此可得 gRPC 遵守消息到达顺序。</p><h1 id="流式消息中的背压（不存在）"><a href="#流式消息中的背压（不存在）" class="headerlink" title="流式消息中的背压（不存在）"></a>流式消息中的背压（不存在）</h1><p>流式消息必然涉及到这样的问题，当请求发送速度远大于服务端对请求处理速度时，持续的请求可能会压垮服务端。这时可以阻塞请求，来达到降低请求发送速度的目的，可称为背压。但 gRPC 中没有背压。？？？有点诧异。</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>但这并不是说 gRPC 没有处理这种问题的能力。首先确认下客户端发送请求是否有可能阻塞。一路跟踪代码下探到 transport 层，在 Stream.java#writeMessage(msg) 的注释中提到：</p><blockquote><p><em>This method will always return immediately and will not wait for the write to complete.</em></p></blockquote><p>故客户端发送是不会阻塞的。</p><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>但是 gRPC 是基于 Http2 的，Http2 有流控的机制，简单来说，接收端可以给发送端设定一个窗口值。以此，可以限制客户端发送的速度，但是没有背压就意味着没法限制用户，这样可能导致客户端的待发送缓存爆掉，问题还是没法解决。</p><h2 id="onReady"><a href="#onReady" class="headerlink" title="onReady"></a>onReady</h2><p>别着急，看下 <code>CallStreamObserver.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If &#123;<span class="doctag">@code</span> true&#125;, indicates that the observer is capable of sending additional messages</span></span><br><span class="line"><span class="comment"> * without requiring excessive buffering internally. This value is just a suggestion and the</span></span><br><span class="line"><span class="comment"> * application is free to ignore it, however doing so may result in excessive buffering within the</span></span><br><span class="line"><span class="comment"> * observer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a &#123;<span class="doctag">@link</span> Runnable&#125; that will be executed every time the stream &#123;<span class="doctag">@link</span> #isReady()&#125; state</span></span><br><span class="line"><span class="comment"> * changes from &#123;<span class="doctag">@code</span> false&#125; to &#123;<span class="doctag">@code</span> true&#125;.  While it is not guaranteed that the same</span></span><br><span class="line"><span class="comment"> * thread will always be used to execute the &#123;<span class="doctag">@link</span> Runnable&#125;, it is guaranteed that executions</span></span><br><span class="line"><span class="comment"> * are serialized with calls to the &#x27;inbound&#x27; &#123;<span class="doctag">@link</span> StreamObserver&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On client-side this method may only be called during &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ClientResponseObserver#beforeStart&#125;. On server-side it may only be called during the initial</span></span><br><span class="line"><span class="comment"> * call to the application, before the service returns its &#123;<span class="doctag">@code</span> StreamObserver&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the handler may be called some time after &#123;<span class="doctag">@link</span> #isReady&#125; has transitioned to</span></span><br><span class="line"><span class="comment"> * true as other callbacks may still be executing in the &#x27;inbound&#x27; observer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onReadyHandler to call when peer is ready to receive more messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOnReadyHandler</span><span class="params">(Runnable onReadyHandler)</span></span>;</span><br></pre></td></tr></table></figure><p>可看到作为替代，用户可以使用 onReady 的监听，这样可以避免待发送消息爆掉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>gRPC 这个方案看似比背压更复杂，但实际上更合理。首先依靠 Http2 从网络上控制请求的频率，将异常和问题拦截在客户端，锅分得合理。然后在客户端，提供了解决问题的方案，并允许设定 handler，对客户端来说也是简单方便的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/grpc/grpc-java">gRpc-java Readme</a>.</li><li><a href="https://www.nihaoshijie.com.cn/index.php/archives/698/">HTTP2.0关于多路复用的研究</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gRPC 是一个优秀的开源 RPC 框架，它能够实现双向流式调用。本文从源码的角度出发，分层剖析 gRPC 流式调用的实现。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://s1.ax1x.com/2018/10/13/iN7ZfU.png&quot; alt=&quot;iN7ZfU.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="源码分析" scheme="http://moeyui1.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="gRPC" scheme="http://moeyui1.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Envoy 统计数据子系统源码分析</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/7c949937.html"/>
    <id>http://moeyui1.github.io/开发/7c949937.html</id>
    <published>2018-09-24T16:10:42.000Z</published>
    <updated>2021-02-08T10:12:18.752Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Envoy 监控的相关概念可以参考<a href="https://blog.envoyproxy.io/envoy-stats-b65c7f363342">官方博客</a>。不过这篇博客有点旧，一些概念应以最新的代码为准。下面简单介绍一些基本概念。</p><h1 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h1><p>关于为何 envoy 要设计一套复杂的统计子系统，这里直接引用官方的 blog 内容：</p><ul><li><p>在任意数量工作线程下保持大致线性的吞吐量。换一种说法，在稳定状态下使用统计时，应该是没有跨线程抢占的。</p><blockquote><p>Roughly linear throughput that scales with any number of worker threads. Said another way: at steady state there should be zero cross-thread contention when using stats. </p></blockquote></li><li><p>当使用热重启时，统计应该是逻辑上一致的。这意味着即使有两个Envoy线程在运行，所有的 counters、gauges 和 histograms 在逻辑上当作是一个进程内时，都应该是一致的。</p><blockquote><p>When using hot restart, stats should be logically consistent. This means that even when there are two Envoy processes running, all of the counters, gauges, and histograms should be consistent when logically considered as a single process. (See the <a href="https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5">hot restart post</a> for more information on this). </p></blockquote></li><li><p>统计信息应包含在域（scopes）中，并以组为单位释放。域是包含共同前缀统计信息的逻辑分组。例如：<code>http.admin.*</code>。这一点由于Envoy的动态性而十分重要。Envoy支持多种管理APIs诸如监听器发现服务（LDS）和集群发现服务（CDS）APIs。为了不占满内存，Envoy 需要清理已经用不到的统计数据。</p><blockquote><p>Stats should be contained within <em>scopes</em> and freed as a group. A scope is a logical grouping of stats with a common prefix. For example: http.admin.*. This is important because of the dynamic nature of Envoy. Envoy supports various <a href="https://lyft.github.io/envoy/docs/intro/arch_overview/dynamic_configuration.html">management APIs</a> such as the Listener Discovery Service (LDS) and Cluster Discovery Service (CDS) APIs. In order to not run out of memory Envoy needs to clean up stats that are no longer used. </p></blockquote></li><li><p>统计域应该能覆盖和正确地进行引用计数.举个例子，域A使用了 <code>foo.bar.baz</code> ，域B也用了 <code>foo.bar.baz</code>，那么底层的 <code>foo.bar.baz</code> 应该引用计数为2。这对于热重启（某个时间段两个进程都会写同一个统计数据）和动态管理接口（某个时间段一个已更新的 listener 或 cluster 会与未更新的 listener 或 cluster 引用同一个统计数据）是必要的。</p><blockquote><p>Stat scopes should be capable of being <em>overlapped</em> and properly reference counted. This means that if scope A uses a stat called <em>foo.bar.baz</em> and scope B also uses <em>foo.bar.baz</em>, the underlying <em>foo.bar.baz</em> stat should have a reference count of two. This is required both for hot restart (both processes will write to the same stats for some period of time) as well as for the dynamic management APIs (for some period of time an updated listener or cluster will reference the same stats as the old listener or cluster). </p></blockquote></li><li><p>对高低频统计数据的分别优化。</p><blockquote><p>The stat subsystem should perform well for stats that may not be known until data plane processing starts. Many stats are essentially “fixed” and can be created when the configuration is loaded or the dynamic APIs reconfigure the data plane (e.g., cluster.foo.upstream_rq_5xx). These are both low frequency events. Other stats, such as detailed HTTP response code metrics (e.g., cluster.foo.upstream_rq_503), are not known until data starts flowing. Using “dynamic” stats is never going to be as fast as using “fixed” stats but performance should still be adequate even when processing 10’s of thousands of requests per second per core.</p></blockquote></li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>首先介绍开源界监控的一般解决方案，以 dogstatd 为例：</p><p><a href="https://imgchr.com/i/iulKMV"><img data-src="https://s1.ax1x.com/2018/09/23/iulKMV.png" alt="iulKMV.png"></a></p><p>其中 DogStatsd 单独部署，负责聚合、收集统计数据，为 Envoy 中 Sink 一角。下文主要讨论处于 DogStatsd 下游的应用代码中的实现，探究 Envoy 如何处理统计数据，并将它们发给 Sink 的。</p><p>Envoy 目前支持3种监控指标类型：</p><ul><li>Counters（计数器）：无符号整数只增不减，如总请求数；</li><li>Gauges（量表）：无符号整数可增可减，如目前有效请求数；</li><li>Histograms（直方图）：作为值流的一部分的无符号整数，然后由收集器进行汇总以最终生成汇总百分点值。 例如，上游请求时间。</li></ul><p>在内部，计数器和计量器被分批并定期冲洗以提高性能。直方图会在收到时写入。 注意：以前称为定时器的内容已成为直方图，因为这两种表示法之间的唯一区别就是单位（秒和毫秒）。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><a href="https://imgchr.com/i/iul8IJ"><img data-src="https://s1.ax1x.com/2018/09/23/iul8IJ.png" alt="iul8IJ.png"></a></p><p>上图是统计系统的大体结构。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><blockquote><p>The stat store is a singleton within Envoy and provides a simple interface by which the rest of the code can obtain handles to scopes, counters, gauges, and histograms. Calling code is responsible for maintaining ownership semantics of any created scopes. When a scope is destroyed, all of the contained stats have their reference count decreased by one. If any stats reach a reference count of zero they will be freed.</p></blockquote><p>由于 Store 的实现比较贴近底层，主要考虑内存管理、锁方面的问题，故本文不做深入分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A store for all known counters, gauges, and timers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> :</span> <span class="keyword">public</span> Scope &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a list of all known counters.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::vector&lt;CounterSharedPtr&gt; <span class="title">counters</span><span class="params">()</span> <span class="keyword">const</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a list of all known gauges.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::vector&lt;GaugeSharedPtr&gt; <span class="title">gauges</span><span class="params">()</span> <span class="keyword">const</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a list of all known histograms.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::vector&lt;ParentHistogramSharedPtr&gt; <span class="title">histograms</span><span class="params">()</span> <span class="keyword">const</span> PURE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h2><p>As described previously, stats include counters, gauges, and histograms. From an end user perspective, these interfaces are very simple to use. For example, counters and gauges include an inc() and dec() method while only gauges include a set() method. Any underlying storage complexity is hidden from the programmer.</p><h2 id="Flusher"><a href="#Flusher" class="headerlink" title="Flusher"></a>Flusher</h2><p>To achieve high performance, Envoy internally buffers all stat changes using atomic CPU instructions. At a configurable interval all of the counters and gauges are flushed to the sinks. Note that in the current architecture <em>histogram values are sent directly to the sinks</em>. This will be described in more detail below. The flusher runs on the main thread.</p><h2 id="Sinks"><a href="#Sinks" class="headerlink" title="Sinks"></a>Sinks</h2><p>A stat sink is an interface that takes generic stat data and translates it into a backend-specific wire format. All sinks utilize TLS so that there is no contention when flushing output. In practice however, only the main thread currently flushes counters and gauges. All threads flush histograms.</p><p>Currently, Envoy only supports the TCP and UDP <a href="https://github.com/b/statsd_spec">statsd</a> protocol. statsd is an incredibly simple but very widely supported transport format. In the future it is very likely that other native stat sinks will be implemented, such as <a href="https://prometheus.io/">Prometheus</a>, <a href="https://www.wavefront.com/">Wavefront</a>, and <a href="https://www.influxdata.com/">InfluxDB</a>. Note also that Envoy does not currently support <em>dimensional</em> or <em>tagged</em> stats. This will be discussed further in the future work section below.</p><p>The built-in stats sinks are:</p><ul><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-statsdsink">envoy.statsd</a></li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-dogstatsdsink">envoy.dog_statsd</a></li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/metrics_service.proto#envoy-api-msg-config-metrics-v2-metricsserviceconfig">envoy.metrics_service</a></li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-hystrixsink">envoy.stat_sinks.hystrix</a></li></ul><h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><p>From an operations perspective, it is incredibly useful to be able to get onto a node and dump the current stats in realtime. Envoy enables this via the /stats <a href="https://lyft.github.io/envoy/docs/operations/admin.html#get--stats">admin endpoint</a>. The admin endpoint looks directly into the store to load all of the counters and gauges and print them. This endpoint does not currently output any histogram data. This again is due to the fact that in the current implementation histogram values are written directly to the sinks so the store does not know about them.</p><h1 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><h3 id="数据推送"><a href="#数据推送" class="headerlink" title="数据推送"></a>数据推送</h3><p>流程复杂又繁琐，整理了一下<a href="https://oeoiy7i1f.qnssl.com/envoy_stats.xmind">思维导图</a>。粗略地讲，就是定时调用 <code>Stats::Sink</code> 的 flush 方法，将 <code>Stats::Source</code> 中的统计数据推给 sink。</p><h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><p>envoy 这一套抽象得很好，在埋点的时候使用的实际是 <code>Stats::Store</code>，将数据存到本地的 cache 中，再通过上文的“数据推送”定时推到后端的 sink。下面以 <code>envoy/source/extensions/filters/network/ratelimit/ratelimit.cc</code> 为例追踪下埋点的源码实现，比较复杂繁琐，可以选择性跳过，简单来说就是埋点处对 store 层数据进行修改。</p><h4 id="Network-FilterStatus-Filter-onNewConnection"><a href="#Network-FilterStatus-Filter-onNewConnection" class="headerlink" title="Network::FilterStatus Filter::onNewConnection()"></a>Network::FilterStatus Filter::onNewConnection()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (status_ == Status::NotStarted) &#123;</span><br><span class="line">    status_ = Status::Calling;</span><br><span class="line">    config_-&gt;<span class="built_in">stats</span>().active_.<span class="built_in">inc</span>();</span><br><span class="line">    config_-&gt;<span class="built_in">stats</span>().total_.<span class="built_in">inc</span>();</span><br><span class="line">    calling_limit_ = <span class="literal">true</span>;</span><br><span class="line">    client_-&gt;<span class="built_in">limit</span>(*<span class="keyword">this</span>, config_-&gt;<span class="built_in">domain</span>(), config_-&gt;<span class="built_in">descriptors</span>(), Tracing::NullSpan::<span class="built_in">instance</span>());</span><br><span class="line">    calling_limit_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>该方法中有一处埋点，调用了 <code>config_</code> 变量的 <code>stats()</code> 方法。<code>config_</code> 实际上是一个 <code>RateLimitFilter::Config</code> 类型的实例。<code>stats()</code> 返回 <code>config_</code> 持有的一个 <code>InstanceStats</code> 类型的引用。下面看 <code>InstanceStats</code> 的代码。</p><h4 id="RateLimitFilter-InstanceStats"><a href="#RateLimitFilter-InstanceStats" class="headerlink" title="RateLimitFilter::InstanceStats"></a>RateLimitFilter::InstanceStats</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Struct definition for all tcp rate limit stats. @see stats_macros.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceStats</span> &#123;</span></span><br><span class="line">  <span class="built_in">ALL_TCP_RATE_LIMIT_STATS</span>(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点懵逼，这货是一个结构体。。。还用了几个莫名其妙的宏。。。先看 <code>ALL_TCP_RATE_LIMIT_STATS</code> 写的啥：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All tcp rate limit stats. @see stats_macros.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL_TCP_RATE_LIMIT_STATS(COUNTER, GAUGE)                                         \</span></span><br><span class="line"><span class="meta">  COUNTER(total)                                                                         \</span></span><br><span class="line"><span class="meta">  COUNTER(<span class="meta-keyword">error</span>)                                                                         \</span></span><br><span class="line"><span class="meta">  COUNTER(over_limit)                                                                    \</span></span><br><span class="line"><span class="meta">  COUNTER(ok)                                                                            \</span></span><br><span class="line"><span class="meta">  COUNTER(failure_mode_allowed)                                                          \</span></span><br><span class="line"><span class="meta">  COUNTER(cx_closed)                                                                     \</span></span><br><span class="line"><span class="meta">  GAUGE  (active)</span></span><br><span class="line"><span class="comment">// clang-format on</span></span><br></pre></td></tr></table></figure><p>丫的是个嵌套宏，，，大意是执行传入参数 COUNTER, GAUGE 的宏。注释提到了 <code>stats_macros.h</code> ，看下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;envoy/stats/histogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;envoy/stats/stats.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Envoy &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * These are helper macros for allocating &quot;fixed&quot; stats throughout the code base in a way that</span></span><br><span class="line"><span class="comment"> * is also easy to mock and test. The general flow looks like this:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Define a block of stats like this:</span></span><br><span class="line"><span class="comment"> *   #define MY_COOL_STATS(COUNTER, GAUGE, HISTOGRAM) \</span></span><br><span class="line"><span class="comment"> *     COUNTER(counter1)</span></span><br><span class="line"><span class="comment"> *     GAUGE(gauge1)</span></span><br><span class="line"><span class="comment"> *     HISTOGRAM(histogram1)</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Now actually put these stats somewhere, usually as a member of a struct:</span></span><br><span class="line"><span class="comment"> *   struct MyCoolStats &#123;</span></span><br><span class="line"><span class="comment"> *     MY_COOL_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT)</span></span><br><span class="line"><span class="comment"> *   &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally, when you want to actually instantiate the above struct using a Stats::Pool, you do:</span></span><br><span class="line"><span class="comment"> *   MyCoolStats stats&#123;</span></span><br><span class="line"><span class="comment"> *     MY_COOL_STATS(POOL_COUNTER(...), POOL_GAUGE(...), POOL_HISTOGRAM(...))&#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATE_COUNTER_STRUCT(NAME) Stats::Counter&amp; NAME##_;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATE_GAUGE_STRUCT(NAME) Stats::Gauge&amp; NAME##_;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATE_HISTOGRAM_STRUCT(NAME) Stats::Histogram&amp; NAME##_;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINISH_STAT_DECL_(X) + std::string(#X)),</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_COUNTER_PREFIX(POOL, PREFIX) (POOL).counter(PREFIX FINISH_STAT_DECL_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_GAUGE_PREFIX(POOL, PREFIX) (POOL).gauge(PREFIX FINISH_STAT_DECL_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_HISTOGRAM_PREFIX(POOL, PREFIX) (POOL).histogram(PREFIX FINISH_STAT_DECL_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_COUNTER(POOL) POOL_COUNTER_PREFIX(POOL, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_GAUGE(POOL) POOL_GAUGE_PREFIX(POOL, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_HISTOGRAM(POOL) POOL_HISTOGRAM_PREFIX(POOL, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line">&#125; <span class="comment">// namespace Envoy</span></span><br></pre></td></tr></table></figure><p>大体意思看注释就知道了，这个宏主要是方便生成一个统计的数据结构。那将 <code>InstanceStats</code> 理解为一个数据结构即可，它的成员有 <code>Stats::Counter</code> 和 <code>Stats::Gauge</code> 。</p><h4 id="Stats-Counter"><a href="#Stats-Counter" class="headerlink" title="Stats::Counter"></a>Stats::Counter</h4><p>以 Counter 为例看下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An always incrementing counter with latching capability. Each increment is added both to a</span></span><br><span class="line"><span class="comment"> * global counter as well as periodic counter. Calling latch() returns the periodic counter and</span></span><br><span class="line"><span class="comment"> * clears it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Metric &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">uint64_t</span> amount)</span> PURE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> PURE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">latch</span><span class="params">()</span> PURE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> PURE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> PURE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一看，执行流程就明白了。回过头来 <code>InstanceStat</code> 是如何被初始化的呢？这个 Counter 的具体实现是什么？</p><h4 id="InstanceStat-初始化"><a href="#InstanceStat-初始化" class="headerlink" title="InstanceStat 初始化"></a>InstanceStat 初始化</h4><p><code>envoy/source/extensions/filters/network/ratelimit/ratelimit.cc</code> 下有一段代码生成 <code>InstanceStat</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InstanceStats <span class="title">Config::generateStats</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, Stats::Scope&amp; scope)</span> </span>&#123;</span><br><span class="line">  std::string final_prefix = fmt::format(<span class="string">&quot;ratelimit.&#123;&#125;.&quot;</span>, name);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">ALL_TCP_RATE_LIMIT_STATS</span>(<span class="built_in">POOL_COUNTER_PREFIX</span>(scope, final_prefix),</span><br><span class="line">                                   <span class="built_in">POOL_GAUGE_PREFIX</span>(scope, final_prefix))&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前面 <code>stats_macros.h</code> 的源码来看，实际调用了 <code>scope.counter()</code> 方法。看下 scope 代码。</p><h4 id="Stats-Scope"><a href="#Stats-Scope" class="headerlink" title="Stats::Scope"></a>Stats::Scope</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;envoy/common/pure.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;envoy/stats/histogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;envoy/stats/stats_options.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Envoy &#123;</span><br><span class="line"><span class="keyword">namespace</span> Stats &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gauge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Histogram</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scope</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatsOptions</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::unique_ptr&lt;Scope&gt; ScopePtr;</span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;Scope&gt; ScopeSharedPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A named scope for stats. Scopes are a grouping of stats that can be acted on as a unit if needed</span></span><br><span class="line"><span class="comment"> * (for example to free/delete all of them).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scope</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Scope</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocate a new scope. <span class="doctag">NOTE:</span> The implementation should correctly handle overlapping scopes</span></span><br><span class="line"><span class="comment">   * that point to the same reference counted backing stats. This allows a new scope to be</span></span><br><span class="line"><span class="comment">   * gracefully swapped in while an old scope with the same name is being destroyed.</span></span><br><span class="line"><span class="comment">   * @param name supplies the scope&#x27;s namespace prefix.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ScopePtr <span class="title">createScope</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Deliver an individual histogram value to all registered sinks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deliverHistogramToSinks</span><span class="params">(<span class="keyword">const</span> Histogram&amp; histogram, <span class="keyword">uint64_t</span> value)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a counter within the scope&#x27;s namespace.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Counter&amp; <span class="title">counter</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a gauge within the scope&#x27;s namespace.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Gauge&amp; <span class="title">gauge</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a histogram within the scope&#x27;s namespace with a particular value type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Histogram&amp; <span class="title">histogram</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return a reference to the top-level StatsOptions struct, containing information about the</span></span><br><span class="line"><span class="comment">   * maximum allowable object name length and stat suffix length.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Stats::StatsOptions&amp; <span class="title">statsOptions</span><span class="params">()</span> <span class="keyword">const</span> PURE</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Stats</span></span><br><span class="line">&#125; <span class="comment">// namespace Envoy</span></span><br></pre></td></tr></table></figure><p>可看到获取的是 scope 下的一个 counter，具体实现的 scope 是 <code>Stats::IsolatedScopeImpl</code> 。</p><h4 id="Stats-IsolatedScopeImpl"><a href="#Stats-IsolatedScopeImpl" class="headerlink" title="Stats::IsolatedScopeImpl"></a>Stats::IsolatedScopeImpl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsolatedScopeImpl</span> :</span> <span class="keyword">public</span> Scope &#123;</span><br><span class="line">  <span class="built_in">IsolatedScopeImpl</span>(IsolatedStoreImpl&amp; parent, <span class="keyword">const</span> std::string&amp; prefix)</span><br><span class="line">      : <span class="built_in">parent_</span>(parent), <span class="built_in">prefix_</span>(Utility::<span class="built_in">sanitizeStatsName</span>(prefix)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stats::Scope</span></span><br><span class="line">  <span class="function">ScopePtr <span class="title">createScope</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ScopePtr&#123;<span class="keyword">new</span> <span class="built_in">IsolatedScopeImpl</span>(parent_, prefix_ + name)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deliverHistogramToSinks</span><span class="params">(<span class="keyword">const</span> Histogram&amp;, <span class="keyword">uint64_t</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function">Counter&amp; <span class="title">counter</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> parent_.<span class="built_in">counter</span>(prefix_ + name); &#125;</span><br><span class="line">  <span class="function">Gauge&amp; <span class="title">gauge</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> parent_.<span class="built_in">gauge</span>(prefix_ + name); &#125;</span><br><span class="line">  <span class="function">Histogram&amp; <span class="title">histogram</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent_.<span class="built_in">histogram</span>(prefix_ + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Stats::StatsOptions&amp; <span class="title">statsOptions</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> parent_.<span class="built_in">statsOptions</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  IsolatedStoreImpl&amp; parent_;</span><br><span class="line">  <span class="keyword">const</span> std::string prefix_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可看到实际用了 <code>IsolatedStoreImpl</code> 的 <code>counter(name)</code> 方法。</p><h4 id="Stats-IsolatedStoreImpl"><a href="#Stats-IsolatedStoreImpl" class="headerlink" title="Stats::IsolatedStoreImpl"></a>Stats::IsolatedStoreImpl</h4><p><code>IsolatedStoreImpl</code> 是 <code>Stats::Store</code> 的一个子类，结合前文的概念，就知道这里终于走到了 store 层。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsolatedStoreImpl</span> :</span> <span class="keyword">public</span> Store &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IsolatedStoreImpl</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stats::Scope</span></span><br><span class="line">  <span class="function">Counter&amp; <span class="title">counter</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> counters_.<span class="built_in">get</span>(name); &#125;</span><br><span class="line">  <span class="function">ScopePtr <span class="title">createScope</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deliverHistogramToSinks</span><span class="params">(<span class="keyword">const</span> Histogram&amp;, <span class="keyword">uint64_t</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function">Gauge&amp; <span class="title">gauge</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> gauges_.<span class="built_in">get</span>(name); &#125;</span><br><span class="line">  <span class="function">Histogram&amp; <span class="title">histogram</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Histogram&amp; histogram = histograms_.<span class="built_in">get</span>(name);</span><br><span class="line">    <span class="keyword">return</span> histogram;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Stats::StatsOptions&amp; <span class="title">statsOptions</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> stats_options_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stats::Store</span></span><br><span class="line">  <span class="function">std::vector&lt;CounterSharedPtr&gt; <span class="title">counters</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> counters_.<span class="built_in">toVector</span>(); &#125;</span><br><span class="line">  <span class="function">std::vector&lt;GaugeSharedPtr&gt; <span class="title">gauges</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> gauges_.<span class="built_in">toVector</span>(); &#125;</span><br><span class="line">  <span class="function">std::vector&lt;ParentHistogramSharedPtr&gt; <span class="title">histograms</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::vector&lt;ParentHistogramSharedPtr&gt;&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  HeapStatDataAllocator alloc_;</span><br><span class="line">  IsolatedStatsCache&lt;Counter&gt; counters_;</span><br><span class="line">  IsolatedStatsCache&lt;Gauge&gt; gauges_;</span><br><span class="line">  IsolatedStatsCache&lt;Histogram&gt; histograms_;</span><br><span class="line">  <span class="keyword">const</span> StatsOptionsImpl stats_options_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>counter(name)</code> 方法其实就是从一个 vector 中获取对应 counter。</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>先介绍下 <code>Stats::Source</code> ，通过这个类，可以访问缓存中的统计数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides cached access to a particular store&#x27;s stats.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Source</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Source</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns all known counters. Will use cached values if already accessed and clearCache() hasn&#x27;t</span></span><br><span class="line"><span class="comment">   * been called since.</span></span><br><span class="line"><span class="comment">   * @return std::vector&lt;CounterSharedPtr&gt;&amp; all known counters. Note: reference may not be valid</span></span><br><span class="line"><span class="comment">   * after clearCache() is called.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> std::vector&lt;CounterSharedPtr&gt;&amp; <span class="title">cachedCounters</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns all known gauges. Will use cached values if already accessed and clearCache() hasn&#x27;t</span></span><br><span class="line"><span class="comment">   * been called since.</span></span><br><span class="line"><span class="comment">   * @return std::vector&lt;GaugeSharedPtr&gt;&amp; all known gauges. Note: reference may not be valid after</span></span><br><span class="line"><span class="comment">   * clearCache() is called.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> std::vector&lt;GaugeSharedPtr&gt;&amp; <span class="title">cachedGauges</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns all known parent histograms. Will use cached values if already accessed and</span></span><br><span class="line"><span class="comment">   * clearCache() hasn&#x27;t been called since.</span></span><br><span class="line"><span class="comment">   * @return std::vector&lt;ParentHistogramSharedPtr&gt;&amp; all known histograms. Note: reference may not be</span></span><br><span class="line"><span class="comment">   * valid after clearCache() is called.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> std::vector&lt;ParentHistogramSharedPtr&gt;&amp; <span class="title">cachedHistograms</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resets the cache so that any future calls to get cached metrics will refresh the set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> PURE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>上面的流程追踪到 <code>sink-&gt;flush(source)</code> 方法，这里的 sink 实际是 <code>Stats::Sink</code> 的子类，具体的实现类在 <code>envoy/source/extensions/stat_sinks</code> 文件夹下，有</p><ul><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-statsdsink">envoy.statsd</a> 支持 TCP/UDP</li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-dogstatsdsink">envoy.dog_statsd</a></li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/metrics_service.proto#envoy-api-msg-config-metrics-v2-metricsserviceconfig">envoy.metrics_service</a> 后端接一个符合某种标准的 grpc sink；</li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/stats.proto#envoy-api-msg-config-metrics-v2-hystrixsink">envoy.stat_sinks.hystrix</a> 暴露一个 url ，提供流式信息输出</li></ul><p>其中 statsd 和 dog_statsd 都是基于 statsd 格式，故使用 <code>stat_sinks/common/statsd</code> 下的共通代码。下面以 <code>envoy/source/extensions/stat_sinks/common/statsd/statsd.cc</code> 为例分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UdpStatsdSink::flush</span><span class="params">(Stats::Source&amp; source)</span> </span>&#123;</span><br><span class="line">  Writer&amp; writer = tls_-&gt;getTyped&lt;Writer&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Stats::CounterSharedPtr&amp; counter : source.<span class="built_in">cachedCounters</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;<span class="built_in">used</span>()) &#123;</span><br><span class="line">      <span class="keyword">uint64_t</span> delta = counter-&gt;<span class="built_in">latch</span>();</span><br><span class="line">      writer.<span class="built_in">write</span>(fmt::format(<span class="string">&quot;&#123;&#125;.&#123;&#125;:&#123;&#125;|c&#123;&#125;&quot;</span>, prefix_, <span class="built_in">getName</span>(*counter), delta,</span><br><span class="line">                               <span class="built_in">buildTagStr</span>(counter-&gt;<span class="built_in">tags</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Stats::GaugeSharedPtr&amp; gauge : source.<span class="built_in">cachedGauges</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gauge-&gt;<span class="built_in">used</span>()) &#123;</span><br><span class="line">      writer.<span class="built_in">write</span>(fmt::format(<span class="string">&quot;&#123;&#125;.&#123;&#125;:&#123;&#125;|g&#123;&#125;&quot;</span>, prefix_, <span class="built_in">getName</span>(*gauge), gauge-&gt;<span class="built_in">value</span>(),</span><br><span class="line">                               <span class="built_in">buildTagStr</span>(gauge-&gt;<span class="built_in">tags</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>如上是一个 Sink 子类的 flush 方法实现。可看到 statsd 是如何从 source 中取出所需数据的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回过头来看 envoy 为何这么设计，实际上与本文开头的设计初衷对应：</p><ul><li><strong>Linear throughput（线性吞吐）:</strong> At steady state, all stat allocations occur via the scope TLS cache. This requires no locks and scales very well to a high number of workers.</li><li><strong>Logically consistent during hot restart（热重启期间的逻辑一致）</strong>: Ultimately, all stats with the same name use the same backing storage in shared memory. This creates logical consistency between processes.</li><li><strong>Stats are contained within a scope, can be freed as a group, and can be overlapped（以scope为单位保存，以组为单位释放，可覆盖）</strong>: Scope 是具有相同前缀统计数据的逻辑集合。Scopes have completely independent central caches and TLS caches, along with independent per-stat reference counting. A scope can be removed and all of its stats will have their reference counts decremented and will potentially be freed.</li><li><strong>Adequate performance for dynamic stats</strong>: Lookups for dynamic stats happen via the scope TLS cache and use an O(1) hash table.</li></ul>]]></content>
    
    <summary type="html">
    
      Envoy 中包含了一个精心设计的统计子系统，本文将从源码角度分析该子系统的设计目标及特点。
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="envoy" scheme="http://moeyui1.github.io/tags/envoy/"/>
    
      <category term="service mesh" scheme="http://moeyui1.github.io/tags/service-mesh/"/>
    
      <category term="源码分析" scheme="http://moeyui1.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Istio学习之Pilot-Discovery</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/ff55e9f.html"/>
    <id>http://moeyui1.github.io/开发/ff55e9f.html</id>
    <published>2018-09-09T06:20:34.000Z</published>
    <updated>2021-02-08T10:12:18.752Z</updated>
    
    <content type="html"><![CDATA[<p>Pilot 是 Istio 中一个重要的组件，它主要分为 Agent 和 Discovery Services 两部分。本文着重介绍负责注册信息和配置信息管理的 Discovery Service.</p><p><img data-src="https://camo.githubusercontent.com/919e2e3cd8e4267a00035b813df53902864a3388/68747470733a2f2f63646e2e7261776769742e636f6d2f697374696f2f70696c6f742f6d61737465722f646f632f70696c6f742e737667" alt="Pilot"></p><span id="more"></span><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ol><li>Istio 控制面信息监控与处理</li><li>服务注册信息监控与处理</li><li>Envoy控制面信息服务：XDS Server</li></ol><p><img data-src="https://i.loli.net/2018/09/09/5b94b7a12b30f.png" alt="Discovery Service 初始化.png"></p><h2 id="Config-Controller"><a href="#Config-Controller" class="headerlink" title="Config Controller"></a>Config Controller</h2><p><img data-src="https://i.loli.net/2018/09/09/5b94b7a0cb075.png" alt="config controller.png"></p><p>config controller包含以下3个部分：</p><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>client是一个rest client集合，用于连接Kubernetes apiserver，实现对istio CRD资源的 <a href="https://km.sankuai.com/page/69543931">list/watch</a>。具体而言，为每个CRD资源的group version (如config.istio.io/v1alpha2、networking.istio.io/v1alpha3)创建一个rest client。该rest client里包含了连接Kubernetes apiserver需要用到的apimachinary、client-go等库里的对象，如GroupVersion、RESTClient等。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>用于缓存istio CRD资源对象（如virtual-service、route-rule等）的Add、Update、Delete事件的队列，等待后续由config controller处理。详见本文后续描述</p><h2 id="kinds"><a href="#kinds" class="headerlink" title="kinds"></a>kinds</h2><p>为每种CRD资源（如virtual-service、route-rule等）创建一个用于list/watch的SharedIndexInformer（Kubernetes client-go库里的概念）。</p><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><p>config controller主循环主要包括两方面：</p><ol><li>利用client-go库里的SharedIndexInformer实现对CRD资源的 list/watch，为每种CRD资源的Add、Update、Delete事件创建处理统一的流程框架。 这个流程将Add、Update、Delete事件涉及到的CRD资源对象封装为一个 Task 对象，并将之push到config controller的 queue 成员里。Task对象除了包含CRD资源对象之外，还包含事件类型（如Add、Update、Delete等），以及处理函数 ChainHandler。ChainHandler支持多个处理函数的串联。</li><li>启动协程逐一处理CRD资源事件（queue.run），处理方法是调用每个从 queue 中取出的 Task 对象上的 ChainHandler</li></ol><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>a) 事件涉及的资源对象</p><p> b) 事件类型：Add、Update和Delete</p><p> c) Handler：ChainHandler。ChainHandler支持多个处理函数的串联</p><h2 id="Service-Controller"><a href="#Service-Controller" class="headerlink" title="Service Controller"></a>Service Controller</h2><p>大体同 Config Controller。</p><h1 id="XDS"><a href="#XDS" class="headerlink" title="XDS"></a>XDS</h1><h2 id="CDS"><a href="#CDS" class="headerlink" title="CDS"></a>CDS</h2><p>cds，即cluster discovery service，是pilot-discovery为Envoy动态提供cluster相关信息的协议。Envoy可以向pilot-discovery的gRPC server发送一个DiscoveryRequest，并将需要获取的配置信息类型（TypeUrl）设置为cds。discovery server，即ads服务的实现类，在收到DiscoveryRequest后，将Abstract Model中保存的相关信息组装成cluster，然后封装在DiscoveryResponse返回给Envoy。</p><p>discovery server为了组装出cluster信息，需要从Abstract Model中提取以下两类信息类型；</p><ol><li>服务注册信息：如从Kubernetes中的服务注册信息转化而来的service</li><li>通过istioctl提供的配置信息，如DestinationRule</li></ol><p>discovery server将这两类信息组装成cluster信息的流程大致如下：</p><p>略</p><h2 id="EDS"><a href="#EDS" class="headerlink" title="EDS"></a>EDS</h2><p>discovery server处理eds类型的DiscoveryRequest的逻辑相对简单，流程如下：</p><ol><li>根据cluster的名称，把对应Kubernetes中service对象的name和所属的namespace解析出来。使用Kubernetes的client-go库中的SharedIndexInformer获取Kubernetes中的service对象。</li><li>使用SharedIndexInformer获取 Kubernetes 中的endpoint所有对象（SharedIndexInformer包含了本地缓机制，所以并非每次处理eds类型的DiscoveryRequest都需要从Kubernetes同步大量数据），选择其中name和namespace匹配的endpoint。</li><li>使用subset中的label(不知道subset中的label代表什么意思的同学，请回忆前面分析cds中关于subcluster构建过程)，比如version=v1，再次过滤上步被筛选过的endpoint</li><li>获取endpoint的ip、端口和可用域（availability zone）等信息。其中的可用域由endpoint对应的pod所运行的node上的两个“著名”label的value构成（中间用”/“分隔），label的key分别为：”failure-domain.beta.kubernetes.io/region”和”failure-domain.beta.kubernetes.io/zone”。</li><li>根据可用域信息（locality）将endpoint分组，每个locality对应一个LocalityLbEndpoints对象</li></ol><p>discovery server在获取endpoint之后，将他们封装在DiscoveryResponse中，将DiscoveryResponse的类型（即TypeUrl）设置为type.googleapis.com/envoy.api.v2.ClusterLoadAssignment，Nonce设置为当前时间（nonce的解释见本文前面部分）, 启动单独的协程通过与Envoy建立的双向stream gRPC连接发送给Envoy，发送超时为5秒</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateCluster is called from the event (or global cache invalidation) to update</span></span><br><span class="line"><span class="comment">// the endpoints for the cluster.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">updateCluster</span><span class="params">(clusterName <span class="keyword">string</span>, edsCluster *EdsCluster)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> should we lock this as well ? Once we move to event-based it may not matter.</span></span><br><span class="line"><span class="keyword">var</span> hostname model.Hostname</span><br><span class="line"><span class="comment">//var ports model.PortList</span></span><br><span class="line"><span class="keyword">var</span> labels model.LabelsCollection</span><br><span class="line"><span class="keyword">var</span> instances []*model.ServiceInstance</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> strings.Index(clusterName, <span class="string">&quot;outbound&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">strings.Index(clusterName, <span class="string">&quot;inbound&quot;</span>) == <span class="number">0</span> &#123; <span class="comment">//new style cluster names</span></span><br><span class="line"><span class="keyword">var</span> p <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> subsetName <span class="keyword">string</span></span><br><span class="line">_, subsetName, hostname, p = model.ParseSubsetKey(clusterName)</span><br><span class="line">labels = edsCluster.discovery.env.IstioConfigStore.SubsetToLabels(subsetName, hostname)</span><br><span class="line">instances, err = edsCluster.discovery.env.ServiceDiscovery.InstancesByPort(hostname, p, labels)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(instances) == <span class="number">0</span> &#123;</span><br><span class="line">s.env.PushStatus.Add(model.ProxyStatusClusterNoInstances, clusterName, <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">//adsLog.Infof(&quot;EDS: no instances %s (host=%s ports=%v labels=%v)&quot;, clusterName, hostname, p, labels)</span></span><br><span class="line">&#125;</span><br><span class="line">edsInstances.With(prometheus.Labels&#123;<span class="string">&quot;cluster&quot;</span>: clusterName&#125;).Set(<span class="keyword">float64</span>(<span class="built_in">len</span>(instances)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">adsLog.Warnf(<span class="string">&quot;endpoints for service cluster %q returned error %q&quot;</span>, clusterName, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">locEps := localityLbEndpointsFromInstances(instances)</span><br><span class="line"></span><br><span class="line"><span class="comment">// There is a chance multiple goroutines will update the cluster at the same time.</span></span><br><span class="line"><span class="comment">// This could be prevented by a lock - but because the update may be slow, it may be</span></span><br><span class="line"><span class="comment">// better to accept the extra computations.</span></span><br><span class="line"><span class="comment">// We still lock the access to the LoadAssignments.</span></span><br><span class="line">edsCluster.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> edsCluster.mutex.Unlock()</span><br><span class="line">edsCluster.LoadAssignment = &amp;xdsapi.ClusterLoadAssignment&#123;</span><br><span class="line">ClusterName: clusterName,</span><br><span class="line">Endpoints:   locEps,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(locEps) &gt; <span class="number">0</span> &amp;&amp; edsCluster.NonEmptyTime.IsZero() &#123;</span><br><span class="line">edsCluster.NonEmptyTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol><li><h2 id="对k8s的-list-watch-是什么意思？"><a href="#对k8s的-list-watch-是什么意思？" class="headerlink" title="对k8s的 list/watch 是什么意思？"></a>对k8s的 list/watch 是什么意思？</h2><p>k8s提供的基于发布订阅模型的资源变更通知，详见<a href="https://km.sankuai.com/page/69543931">apiserver-list/watch</a>。</p></li><li><h2 id="Istio-如何处理-k8s-中的服务注册信息，并传递给-Proxy"><a href="#Istio-如何处理-k8s-中的服务注册信息，并传递给-Proxy" class="headerlink" title="Istio 如何处理 k8s 中的服务注册信息，并传递给 Proxy?"></a>Istio 如何处理 k8s 中的服务注册信息，并传递给 Proxy?</h2><p>k8s 中的服务注册信息一般指 k8s Service 信息，但 Envoy 发起请求时并不走 k8s Service ，而是直接定向到一个 Endpoint，这与 k8s 的思想稍有不同。Istio 会监控 k8s 中的 Services, Endpoint, Node 和 Pod信息，然后<strong>自行按照自己的条件将 Endpoint 划分为 subset</strong>（Istio 自己的一个概念，k8s Service 的子集）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewController creates a new Kubernetes controller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(client kubernetes.Interface, options ControllerOptions)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">log.Infof(<span class="string">&quot;Service controller watching namespace %q for service, endpoint, nodes and pods, refresh %d&quot;</span>,</span><br><span class="line">options.WatchedNamespace, options.ResyncPeriod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue requires a time duration for a retry delay after a handler error</span></span><br><span class="line">out := &amp;Controller&#123;</span><br><span class="line">domainSuffix: options.DomainSuffix,</span><br><span class="line">client:       client,</span><br><span class="line">queue:        NewQueue(<span class="number">1</span> * time.Second),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out.services = out.createInformer(&amp;v1.Service&#123;&#125;, <span class="string">&quot;Service&quot;</span>, options.ResyncPeriod,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Services(options.WatchedNamespace).List(opts)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Services(options.WatchedNamespace).Watch(opts)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">out.endpoints = out.createInformer(&amp;v1.Endpoints&#123;&#125;, <span class="string">&quot;Endpoints&quot;</span>, options.ResyncPeriod,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Endpoints(options.WatchedNamespace).List(opts)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Endpoints(options.WatchedNamespace).Watch(opts)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">out.nodes = out.createInformer(&amp;v1.Node&#123;&#125;, <span class="string">&quot;Node&quot;</span>, options.ResyncPeriod,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Nodes().List(opts)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Nodes().Watch(opts)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">out.pods = newPodCache(out.createInformer(&amp;v1.Pod&#123;&#125;, <span class="string">&quot;Pod&quot;</span>, options.ResyncPeriod,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Pods(options.WatchedNamespace).List(opts)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Pods(options.WatchedNamespace).Watch(opts)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.servicemesher.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin">Service Mesh深度学习系列part2—istio源码分析之pilot-discovery模块分析</a></li><li><a href="http://www.servicemesher.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2">Service Mesh深度学习系列part3—istio源码分析之pilot-discovery模块分析（续）</a></li><li><a href="https://km.sankuai.com/page/68516093#id-Envoy">Service Mesh相关-Istio调研&amp;&amp;学习</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pilot 是 Istio 中一个重要的组件，它主要分为 Agent 和 Discovery Services 两部分。本文着重介绍负责注册信息和配置信息管理的 Discovery Service.&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://camo.githubusercontent.com/919e2e3cd8e4267a00035b813df53902864a3388/68747470733a2f2f63646e2e7261776769742e636f6d2f697374696f2f70696c6f742f6d61737465722f646f632f70696c6f742e737667&quot; alt=&quot;Pilot&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Istio" scheme="http://moeyui1.github.io/tags/Istio/"/>
    
      <category term="meituan" scheme="http://moeyui1.github.io/tags/meituan/"/>
    
      <category term="service mesh" scheme="http://moeyui1.github.io/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>Istio学习之Pilot-agent</title>
    <link href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/760a5082.html"/>
    <id>http://moeyui1.github.io/开发/760a5082.html</id>
    <published>2018-09-09T06:09:06.000Z</published>
    <updated>2021-02-08T10:12:18.753Z</updated>
    
    <content type="html"><![CDATA[<p>Pilot 是 Istio 中一个重要的组件，它主要分为 Agent 和 Discovery Services 两部分。本文着重介绍下承担 Envoy 保姆一职的 Agent。</p><p><img data-src="https://camo.githubusercontent.com/919e2e3cd8e4267a00035b813df53902864a3388/68747470733a2f2f63646e2e7261776769742e636f6d2f697374696f2f70696c6f742f6d61737465722f646f632f70696c6f742e737667" alt="Pilot"></p><span id="more"></span><h1 id="功能简述"><a href="#功能简述" class="headerlink" title="功能简述"></a>功能简述</h1><p>在proxy镜像中，pilot-agent 负责的工作包括：</p><ol><li>生成envoy的配置：指的是生成 Envoy 的启动配置</li><li>启动envoy</li><li>监控并管理envoy的运行状况，比如envoy出错时pilot-agent负责重启envoy，或者envoy配置变更后reload envoy</li></ol><p>而 envoy 负责接受所有发往该pod的网络流量，分发所有从pod中发出的网络流量。</p><blockquote><p>根据代码中的<code>sidecar-injector-configmap.yaml</code>（用来配置如何自动化地inject istio sidecar），inject过程中，除了proxy镜像作为sidecar之外，每个pod还会带上initcontainer（Kubernetes中的概念），具体镜像为proxy_init。proxy_init通过注入iptables规则改写流入流出pod的网络流量规则，使得流入流出pod的网络流量重定向到proxy的监听端口，而应用对此无感。</p></blockquote><p><img data-src="https://i.loli.net/2018/09/09/5b94b1c621c56.png" alt="istio-pilot-proxy (2).png"></p><p>注意上图中 Envoy 处于 Istio/proxy 的内层。这是因为 Istio 并非直接使用 Envoy ，而是在其之上有一层定制，具体可见 <a href="https://github.com/istio/proxy">Istio/proxy</a> 这个项目。</p><blockquote><p>The Istio proxy contains extensions to the Envoy proxy (in the form of Envoy filters), that allow the proxy to delegate policy enforcement decisions to Mixer.</p><p>Istio/proxy 项目包含 Envoy 扩展（由 Envoy filters 构成），允许 proxy 将策略强制决策委托给 Mixer。</p></blockquote><p>这就解释了 Proxy 是如何与 Mixer 交互的。</p><h1 id="部署存在形式"><a href="#部署存在形式" class="headerlink" title="部署存在形式"></a>部署存在形式</h1><p>pilot-agent在pilot/cmd包下面，<strong>是个单独的二进制</strong>。</p><p>pilot-agent<strong>跟 envoy 打包在同一个docker镜像里</strong>，镜像由<code>Dockerfile.proxy</code>定义。Makefile（include了<code>tools/istio-docker.mk</code>）把这个dockerfile build成了<code>$&#123;HUB&#125;/proxyv2:$&#123;TAG&#125;</code>镜像，也就是 Kubernetes 里跟应用放在同一个pod下的sidecar。</p><p><em>非Kubernetes情况下需要把pilot-agent、envoy跟应用部署在一起，惊了。</em></p><h1 id="生成envoy的配置"><a href="#生成envoy的配置" class="headerlink" title="生成envoy的配置"></a>生成envoy的配置</h1><p>略</p><h1 id="Envoy-的监控和管理"><a href="#Envoy-的监控和管理" class="headerlink" title="Envoy 的监控和管理"></a>Envoy 的监控和管理</h1><p>为envoy生成好配置文件之后，pilot-agent还要负责envoy进程的监控与管理工作，包括：</p><ol><li>创建envoy对象，结构体包含proxyConfig（前面步骤中为envoy生成的配置信息），role.serviceNode(似乎是agent唯一标识符），loglevel和pilotsan（service account name）</li><li>创建agent对象，包含前面创建的envoy结构体，一个epochs的map，3个channel：configCh, statusCh和abortCh</li><li>创建watcher并启动协程执行watcher.Run watcher.Run首先启动协程执行agent.Run（<strong>agent的主循环</strong>），然后调用watcher.Reload(kickstart the proxy with partial state (in case there are no notifications coming))，<strong>Reload会调用agent.ScheduleConfigUpdate，并最终导致第一个envoy进程启动，见后面分析</strong>。然后监控各种证书，如果证书文件发生变化，则调用ScheduleConfigUpdate来reload envoy，然后watcher.retrieveAZ(TODO)</li><li>创建context，调用cmd.WaitSignal以等待进程接收到SIGINT, SIGTERM信号，接受到信号之后通过context通知agent，agent接到通知后调用terminate来kill所有envoy进程，并退出agent进程</li></ol><blockquote><p>上面的pilot/pkg/proxy包下的agent中采用Proxy接口管理pilot/pkg/proxy/envoy包下的envoy对象，从理论上来说也可以把envoy换成其他proxy实现管理。不过此事还牵扯discovery service等其他组件。</p></blockquote><p>上面第三步启动协程执行的agent.Run是agent的主循环，会一直通过监听以下几个channel来监控envoy进程：</p><ol><li>agent的configCh:如果配置文件，<strong>主要是那些证书文件发生变化</strong>，则调用agent.reconcile来reload envoy</li><li>statusCh:这里的status其实就是exitStatus，处理envoy进程退出状态，处理流程如下：<ol><li>把刚刚退出的epoch从agent维护的两个map里删了，后面会讲到这两个map。把agent.currentConfig置为agent.latestEpoch对应的config，因为agent在reconcile的过程中只有在desired config和current config不同的时候才会创建新的epoch，所以这里把currentConfig设置为上一个config之后，必然会造成下一次reconcile的时候current与desired不等，从而创建新的envoy</li><li>如果exitStatus.err是errAbort，表示是agent让envoy退出的（这个error是调用agent.abortAll时发出的），这时只要log记录epoch序列号为xxx的envoy进程退出了</li><li>如果exitStatus.err并非errAbort，则log记录epoch异常退出，并给所有当前正在运行的其他epoch进程对应的abortCh发出errAbort，所以后续其他envoy进程也都会被kill掉，并全都往agent.statusCh写入exitStatus，当前的流程会全部再为每个epoch进程走一遍</li><li>如果是其他exitStatus（什么时候会进入这个否则情况？比如exitStatus.err是wait epoch进程得到的正常退出信息，即nil），则log记录envoy正常退出</li><li>调用envoy.Cleanup，删除刚刚退出的envoy进程对应的配置文件，文件路径由ConfigPath和epoch序列号串起来得到</li><li>如果envoy进程为非正常退出，也就是除了“否则”描述的case之外的2中情况，则试图恢复刚刚退出的envoy进程（可见前面向所有其他进程发出errAbort消息的意思，并非永远停止envoy，pilot-agent接下来马上就会重启被abort的envoy）。恢复方式并不是当场启动新的envoy，而是schedule一次reconcile。如果启动不成功，可以在得到exitStatus之后再次schedule（每次间隔时间为 $2^n*200$ 毫秒 ），最多重试10次（budget），如果10次都失败，则退出整个golang的进程（os.Exit）,由容器环境决定如何恢复pilot-agent。所谓的schedule，就是往agent.retry.restart写入一个预定的未来的某个时刻，并扣掉一次budget（budget在每次reconcile之前都会被重置为10），然后就结束当前循环。在下一个开始的时候，会检测agent.retry.restart，如果非空，则计算距离reconcile的时间delay</li></ol></li><li>time.After（delay）:监听是否到时间执行schedule的reconcile了，到了则执行agent.reconcile</li><li>ctx.Done:执行agent.terminate terminate方法比较简单，向所有的envoy进程的abortCh发出errAbort消息，造成他们全体被kill（Cmd.Kill），然后agent自己return，退出当前的循环，这样就不会有人再去重启envoy</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *agent)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">log.Info(<span class="string">&quot;Starting proxy agent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Throttle processing up to smoothed 1 qps with bursts up to 10 qps.</span></span><br><span class="line"><span class="comment">// High QPS is needed to process messages on all channels.</span></span><br><span class="line">rateLimiter := rate.NewLimiter(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">err := rateLimiter.Wait(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">a.terminate()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum duration or duration till next restart</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a.retry.restart != <span class="literal">nil</span> &#123;</span><br><span class="line">delay = time.Until(*a.retry.restart)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> config := &lt;-a.configCh:</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(a.desiredConfig, config) &#123;</span><br><span class="line">log.Infof(<span class="string">&quot;Received new config, resetting budget&quot;</span>)</span><br><span class="line">a.desiredConfig = config</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset retry budget if and only if the desired config changes</span></span><br><span class="line">a.retry.budget = a.retry.MaxRetries</span><br><span class="line">a.reconcile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> status := &lt;-a.statusCh:</span><br><span class="line"><span class="comment">// delete epoch record and update current config</span></span><br><span class="line"><span class="comment">// avoid self-aborting on non-abort error</span></span><br><span class="line"><span class="built_in">delete</span>(a.epochs, status.epoch)</span><br><span class="line"><span class="built_in">delete</span>(a.abortCh, status.epoch)</span><br><span class="line">a.currentConfig = a.epochs[a.latestEpoch()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> status.err == errAbort &#123;</span><br><span class="line">log.Infof(<span class="string">&quot;Epoch %d aborted&quot;</span>, status.epoch)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> status.err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warnf(<span class="string">&quot;Epoch %d terminated with an error: %v&quot;</span>, status.epoch, status.err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> due to Envoy hot restart race conditions, an error from the</span></span><br><span class="line"><span class="comment">// process requires aggressive non-graceful restarts by killing all</span></span><br><span class="line"><span class="comment">// existing proxy instances</span></span><br><span class="line">a.abortAll()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Infof(<span class="string">&quot;Epoch %d exited normally&quot;</span>, status.epoch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cleanup for the epoch</span></span><br><span class="line">a.proxy.Cleanup(status.epoch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedule a retry for an error.</span></span><br><span class="line"><span class="comment">// the current config might be out of date from here since its proxy might have been aborted.</span></span><br><span class="line"><span class="comment">// the current config will change on abort, hence retrying prior to abort will not progress.</span></span><br><span class="line"><span class="comment">// that means that aborted envoy might need to re-schedule a retry if it was not already scheduled.</span></span><br><span class="line"><span class="keyword">if</span> status.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// skip retrying twice by checking retry restart delay</span></span><br><span class="line"><span class="keyword">if</span> a.retry.restart == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a.retry.budget &gt; <span class="number">0</span> &#123;</span><br><span class="line">delayDuration := a.retry.InitialInterval * (<span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(a.retry.MaxRetries-a.retry.budget))</span><br><span class="line">restart := time.Now().Add(delayDuration)</span><br><span class="line">a.retry.restart = &amp;restart</span><br><span class="line">a.retry.budget = a.retry.budget - <span class="number">1</span></span><br><span class="line">log.Infof(<span class="string">&quot;Epoch %d: set retry delay to %v, budget to %d&quot;</span>, status.epoch, delayDuration, a.retry.budget)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Error(<span class="string">&quot;Permanent error: budget exhausted trying to fulfill the desired configuration&quot;</span>)</span><br><span class="line">a.proxy.Panic(status.epoch)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Debugf(<span class="string">&quot;Epoch %d: restart already scheduled&quot;</span>, status.epoch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(delay):</span><br><span class="line">a.reconcile()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> _, more := &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">if</span> !more &#123;</span><br><span class="line">a.terminate()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Envoy-启动流程"><a href="#Envoy-启动流程" class="headerlink" title="Envoy 启动流程"></a>Envoy 启动流程</h1><h2 id="热重启"><a href="#热重启" class="headerlink" title="热重启"></a>热重启</h2><p>Pilot agent 的职责之一就是重启proxy，一般是Envoy。可以支持Envoy的热重启。</p><blockquote><p>Agent manages the restarts and the life cycle of a proxy binary. Agent keeps track of all running proxy epochs and their configurations. Hot restarts are performed by launching a new proxy process with a strictly incremented restart epoch. <strong>It is up to the proxy to ensure that older epochs gracefully shutdown and carry over all the necessary state to the latest epoch. The agent does not terminate older epochs.</strong> The initial epoch is 0.</p></blockquote><p>旧实例是否完全关闭，并将必要的状态数据迁移到新实例是由 Proxy 负责的（Agent 不会管）。Agent 不会关闭旧实例。言下之意，Proxy 自己负责旧实例的处理。</p><blockquote><p>The restart protocol matches Envoy semantics for restart epochs: to successfully launch a new Envoy process that will replace the running Envoy processes, the restart epoch of the new process must be exactly 1 greater than the highest restart epoch of the currently running Envoy processes. See <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/hot_restart.html">https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/hot_restart.html</a> for more information about the Envoy hot restart protocol. Agent requires two functions “run” and “cleanup”. Run function is a call to start the proxy and must block until the proxy exits. Cleanup function is executed immediately after the proxy exits and must be non-blocking since it is executed synchronously in the main agent control loop. Both functions take the proxy epoch as an argument. A typical scenario would involve epoch 0 followed by a failed epoch 1 start. The agent then attempts to start epoch 1 again.</p></blockquote><blockquote><p>Whenever the run function returns an error, the agent assumes that the proxy failed to start and attempts to restart the proxy several times with an exponential back-off. The subsequent restart attempts may reuse the epoch from the failed attempt. Retry budgets are allocated whenever the desired configuration changes.</p></blockquote><blockquote><p>Agent executes a single control loop that receives notifications about scheduled configuration updates, exits from older proxy epochs, and retry attempt timers. The call to schedule a configuration update will block until the control loop is ready to accept and process the configuration update.</p></blockquote><p>热重启的流程：</p><ol><li>启动另外一个envoy2进程（Secondary process）</li><li>envoy2通知envoy1（Primary process）关闭其管理的端口，由envoy2接管</li><li>通过UDS把envoy1可用的listen sockets拿过来</li><li>envoy2初始化成功，通知envoy1在一段时间内（drain-time-s）优雅关闭正在工作的请求</li><li>到了时间（parent-shutdown-time-s），envoy2通知envoy1自行关闭</li><li>envoy2升级为envoy1</li></ol><blockquote><p>从上面的执行步骤来看，poilt-agent <strong>只负责启动另一个envoy进程</strong>，其他由envoy自行处理。</p></blockquote><h2 id="抢救-Envoy"><a href="#抢救-Envoy" class="headerlink" title="抢救 Envoy"></a>抢救 Envoy</h2><blockquote><p>envoy是一个服务，既然是服务都不可能保证100%的可用，如果envoy不幸运宕掉了，那么pilot-agent如何进行抢救，保证envoy高可用？</p></blockquote><h3 id="获取退出状态"><a href="#获取退出状态" class="headerlink" title="获取退出状态"></a>获取退出状态</h3><blockquote><p>在上面提到pilot-agent启动envoy后，会监听envoy的退出状态，发现非正常退出状态，就会抢救envoy。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxy envoy)</span> <span class="title">Run</span><span class="params">(config <span class="keyword">interface</span>&#123;&#125;, epoch <span class="keyword">int</span>, abort &lt;-<span class="keyword">chan</span> error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Set if the caller is monitoring envoy, for example in tests or if envoy runs in same</span></span><br><span class="line">    <span class="comment">// container with the app.</span></span><br><span class="line">    <span class="keyword">if</span> proxy.errChan != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Caller passed a channel, will wait itself for termination</span></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        proxy.errChan &lt;- cmd.Wait()</span><br><span class="line">      &#125;()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      done &lt;- cmd.Wait()</span><br><span class="line">    &#125;()</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抢救envoy"><a href="#抢救envoy" class="headerlink" title="抢救envoy"></a>抢救envoy</h3><blockquote><p>使用 kill -9 可以模拟envoy非正常退出状态。当出现非正常退出，pilot-agent的抢救机制会被触发。如果第一次抢救成功，那当然是好，如果失败了，pilot-agent会继续抢救，最多抢救10次，每次间隔时间为 2 n <em>100</em> time.Millisecond。超过10次都没有救活，pilit-agent就会放弃抢救，宣布死亡，并且退出istio/proxy，让k8s重新启动一个新容器。</p></blockquote><p><code>istio.io/istio/pilot/pkg/proxy/agent.go #164</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *agent)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">case</span> status := &lt;-a.statusCh:</span><br><span class="line">        ......</span><br><span class="line">      <span class="keyword">if</span> status.err == errAbort &#123;</span><br><span class="line">        <span class="comment">//pilot-agent通知退出 或 envoy非正常退出</span></span><br><span class="line">        log.Infof(<span class="string">&quot;Epoch %d aborted&quot;</span>, status.epoch)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> status.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//envoy非正常退出</span></span><br><span class="line">        log.Warnf(<span class="string">&quot;Epoch %d terminated with an error: %v&quot;</span>, status.epoch, status.err)</span><br><span class="line">                ......</span><br><span class="line">        a.abortAll()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正常退出</span></span><br><span class="line">        log.Infof(<span class="string">&quot;Epoch %d exited normally&quot;</span>, status.epoch)</span><br><span class="line">      &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> status.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// skip retrying twice by checking retry restart delay</span></span><br><span class="line">      <span class="keyword">if</span> a.retry.restart == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a.retry.budget &gt; <span class="number">0</span> &#123;</span><br><span class="line">          delayDuration := a.retry.InitialInterval * (<span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(a.retry.MaxRetries-a.retry.budget))</span><br><span class="line">          restart := time.Now().Add(delayDuration)</span><br><span class="line">          a.retry.restart = &amp;restart</span><br><span class="line">          a.retry.budget = a.retry.budget - <span class="number">1</span></span><br><span class="line">          log.Infof(<span class="string">&quot;Epoch %d: set retry delay to %v, budget to %d&quot;</span>, status.epoch, delayDuration, a.retry.budget)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//宣布死亡，退出istio/proxy</span></span><br><span class="line">          log.Error(<span class="string">&quot;Permanent error: budget exhausted trying to fulfill the desired configuration&quot;</span>)</span><br><span class="line">          a.proxy.Panic(a.desiredConfig)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Debugf(<span class="string">&quot;Epoch %d: restart already scheduled&quot;</span>, status.epoch)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(delay):</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">case</span> _, more := &lt;-ctx.Done():</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>istio.io/istio/pilot/pkg/proxy/agent.go #72</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  errAbort = errors.New(<span class="string">&quot;epoch aborted&quot;</span>)</span><br><span class="line">  <span class="comment">// DefaultRetry configuration for proxies</span></span><br><span class="line">  DefaultRetry = Retry&#123;</span><br><span class="line">    MaxRetries:      <span class="number">10</span>,</span><br><span class="line">    InitialInterval: <span class="number">200</span> * time.Millisecond,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.servicemesher.com/blog/istio-service-mesh-source-code-pilot-agent-deepin">Service Mesh深度学习系列part1—istio源码分析之pilot-agent模块分析</a></li><li><a href="https://segmentfault.com/a/1190000015171622"> istio源码分析——pilot-agent如何管理envoy生命周期</a></li></ol><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol><li><h2 id="Agent-生成-Envoy-的配置？"><a href="#Agent-生成-Envoy-的配置？" class="headerlink" title="Agent 生成 Envoy 的配置？"></a>Agent 生成 Envoy 的配置？</h2><p>指的是结合用户自定义配置生成 Envoy 的启动参数配置。</p></li><li><h2 id="Agent-在-Envoy-热重启中扮演什么角色？"><a href="#Agent-在-Envoy-热重启中扮演什么角色？" class="headerlink" title="Agent 在 Envoy 热重启中扮演什么角色？"></a>Agent 在 Envoy 热重启中扮演什么角色？</h2><p>Agent <strong>只负责启动另一个envoy进程</strong>，其他由envoy自行处理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pilot 是 Istio 中一个重要的组件，它主要分为 Agent 和 Discovery Services 两部分。本文着重介绍下承担 Envoy 保姆一职的 Agent。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://camo.githubusercontent.com/919e2e3cd8e4267a00035b813df53902864a3388/68747470733a2f2f63646e2e7261776769742e636f6d2f697374696f2f70696c6f742f6d61737465722f646f632f70696c6f742e737667&quot; alt=&quot;Pilot&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://moeyui1.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Istio" scheme="http://moeyui1.github.io/tags/Istio/"/>
    
      <category term="meituan" scheme="http://moeyui1.github.io/tags/meituan/"/>
    
      <category term="service mesh" scheme="http://moeyui1.github.io/tags/service-mesh/"/>
    
  </entry>
  
</feed>
