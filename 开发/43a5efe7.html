<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"moeyui1.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="在 Spring 中可以使用类级别的@Validated 注解对整个类的方法做校验，实际运行时，Spring 会通过 CGLIB 生成基于类的代理，这个生成的代理是原始类的子类。而这个自动生成的子类不会继承原始类的注解，故在编写 Component 处理逻辑时检测不到原始类的注解。"><meta property="og:type" content="article"><meta property="og:title" content="Spring CGLIB 动态代理子类导致的注解丢失"><meta property="og:url" content="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/43a5efe7.html"><meta property="og:site_name" content="不是很懂"><meta property="og:description" content="在 Spring 中可以使用类级别的@Validated 注解对整个类的方法做校验，实际运行时，Spring 会通过 CGLIB 生成基于类的代理，这个生成的代理是原始类的子类。而这个自动生成的子类不会继承原始类的注解，故在编写 Component 处理逻辑时检测不到原始类的注解。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2019/09/07/n1qlnK.md.png"><meta property="og:image" content="https://s2.ax1x.com/2019/09/07/n1qact.png"><meta property="article:published_time" content="2019-09-07T14:02:02.000Z"><meta property="article:modified_time" content="2021-02-08T10:12:18.753Z"><meta property="article:author" content="moeyui"><meta property="article:tag" content="Spring"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.ax1x.com/2019/09/07/n1qlnK.md.png"><link rel="canonical" href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/43a5efe7.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Spring CGLIB 动态代理子类导致的注解丢失 | 不是很懂</title><script>function sendPageView(){if(CONFIG.hostname===location.hostname){var e=localStorage.getItem("uid")||Math.random()+"."+Math.random();localStorage.setItem("uid",e),navigator.sendBeacon("https://www.google-analytics.com/collect",new URLSearchParams({v:1,tid:"UA-75483578-1",cid:e,t:"pageview",dp:encodeURIComponent(location.pathname)}))}}document.addEventListener("pjax:complete",sendPageView),sendPageView()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script>function loadCss(e){var n=document,s=n.head,t=n.createElement("link");t.rel="stylesheet",t.href=e,function e(s){if(n.body)return s();setTimeout(function(){e(s)})}(function(){s.appendChild(t)})}loadCss("/style.css"),loadCss("//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"),loadCss("//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css")</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"></noscript></head><body itemscope="" itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">不是很懂</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">不是很懂你们程序员</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/moeyui1" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://moeyui1.github.io/%E5%BC%80%E5%8F%91/43a5efe7.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/blogAvatar.jpg"><meta itemprop="name" content="moeyui"><meta itemprop="description" content="moeyui | moeyui's blog"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不是很懂"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Spring CGLIB 动态代理子类导致的注解丢失</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-07 22:02:02" itemprop="dateCreated datePublished" datetime="2019-09-07T22:02:02+08:00">2019-09-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-02-08 18:12:18" itemprop="dateModified" datetime="2021-02-08T18:12:18+08:00">2021-02-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a></span></span><span id="/%E5%BC%80%E5%8F%91/43a5efe7.html" class="post-meta-item leancloud_visitors" data-flag-title="Spring CGLIB 动态代理子类导致的注解丢失" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/%E5%BC%80%E5%8F%91/43a5efe7.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/%E5%BC%80%E5%8F%91/43a5efe7.html" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>在 Spring 中可以使用类级别的<code>@Validated</code> 注解对整个类的方法做校验，实际运行时，Spring 会通过 CGLIB 生成基于类的代理，这个生成的代理是原始类的子类。而这个自动生成的子类不会继承原始类的注解，故在编写 Component 处理逻辑时检测不到原始类的注解。</p><span id="more"></span><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>如下的一个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Component("abb")</span></span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cupCounter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Function("echo")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String str)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Function</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时使用<code>@Validated</code>和<code>@CustomAnnotation</code>注解的类没有扫描到<code>@CustomAnnotation</code>注解，断点观察被<code>@Validated</code>注解的类注册到 Context 时的<code>beanType</code>并非原来的类型，而是 CGLIB 生成的子类。并且这个子类没有注解。</p><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/n1qlnK"><img data-src="https://s2.ax1x.com/2019/09/07/n1qlnK.md.png" alt="n1qlnK.md.png"></a></p><p><img data-src="https://s2.ax1x.com/2019/09/07/n1qact.png" alt="n1qact.png"></p><p>使用<code>@Validated</code>可以让Spring帮你做类的数据校验。猜想为了实现校验，Spring使用了CGLIB代理（当需要代理的类没有实现接口时，Spring 总是使用基于类的动态代理即CGLIB），注册的bean是一个CGLIB子类，所以丢失了注解信息。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然生成的代理类会丢失注解信息，那么 Spring 的注解如<code>@Controller</code>又是如何工作的呢？</p><p>翻阅一下 Spring 源码，参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33678399">SpringMVC源码之Controller查找原理</a>。</p><ul><li><p><code>AbstractHandlerMethodMapping#processCandidateBean</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Could not resolve type for bean '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在这里判断bean是否为一个 Handler</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) {</span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>RequestMappingHandlerMapping#isHandler</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Expects a handler to have either a type-level @{<span class="doctag">@link</span> Controller}</span></span><br><span class="line"><span class="comment">	 * annotation or a type-level @{<span class="doctag">@link</span> RequestMapping} annotation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>{</span><br><span class="line">    <span class="comment">//逻辑上通过判断是否含 @Controller 注解，但这里使用了一个 AnnotatedElementUtils</span></span><br><span class="line">    <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>AnnotatedElementUtils#hasAnnotation</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine if an annotation of the specified {<span class="doctag">@code</span> annotationType}</span></span><br><span class="line"><span class="comment">	 * is &lt;em&gt;available&lt;/em&gt; on the supplied {<span class="doctag">@link</span> AnnotatedElement} or</span></span><br><span class="line"><span class="comment">	 * within the annotation hierarchy &lt;em&gt;above&lt;/em&gt; the specified element.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If this method returns {<span class="doctag">@code</span> true}, then {<span class="doctag">@link</span> #findMergedAnnotationAttributes}</span></span><br><span class="line"><span class="comment">	 * will return a non-null value.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method follows &lt;em&gt;find semantics&lt;/em&gt; as described in the</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@linkplain</span> AnnotatedElementUtils class-level javadoc}.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element the annotated element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> annotationType the annotation type to find</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if a matching annotation is present</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isAnnotated(AnnotatedElement, Class)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(AnnotatedElement element, Class&lt;? extends Annotation&gt; annotationType)</span> </span>{</span><br><span class="line">    <span class="comment">// Shortcut: directly present on the element, with no processing needed?</span></span><br><span class="line">    <span class="comment">// 这是传统的判断方法</span></span><br><span class="line">    <span class="keyword">if</span> (element.isAnnotationPresent(annotationType)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 关键在于 searchWithFindSemantics 方法</span></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(searchWithFindSemantics(element, annotationType, <span class="keyword">null</span>, alwaysTrueAnnotationProcessor));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>AnnotatedElementUtils#searchWithFindSemantics</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Search for annotations of the specified {<span class="doctag">@code</span> annotationName} or</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@code</span> annotationType} on the specified {<span class="doctag">@code</span> element}, following</span></span><br><span class="line"><span class="comment">	 * &lt;em&gt;find semantics&lt;/em&gt;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element the annotated element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> annotationType the annotation type to find</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> annotationName the fully qualified class name of the annotation</span></span><br><span class="line"><span class="comment">	 * type to find (as an alternative to {<span class="doctag">@code</span> annotationType})</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> processor the processor to delegate to</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the result of the processor (potentially {<span class="doctag">@code</span> null})</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">searchWithFindSemantics</span><span class="params">(AnnotatedElement element,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> String annotationName, Processor&lt;T&gt; processor)</span> </span>{</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里有很多个重载方法，一直点进去看</span></span><br><span class="line">		<span class="keyword">return</span> searchWithFindSemantics(element,</span><br><span class="line">				(annotationType != <span class="keyword">null</span> ? Collections.singleton(annotationType) : Collections.emptySet()),</span><br><span class="line">				annotationName, <span class="keyword">null</span>, processor);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 到这里可以看到对 bean class 进行判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Class) {</span><br><span class="line">					Class&lt;?&gt; clazz = (Class&lt;?&gt;) element;</span><br><span class="line">					<span class="keyword">if</span> (!Annotation.class.isAssignableFrom(clazz)) {</span><br><span class="line">						<span class="comment">// Search on interfaces</span></span><br><span class="line">						<span class="keyword">for</span> (Class&lt;?&gt; ifc : clazz.getInterfaces()) {</span><br><span class="line">							T result = searchWithFindSemantics(ifc, annotationTypes, annotationName,</span><br><span class="line">									containerType, processor, visited, metaDepth);</span><br><span class="line">							<span class="keyword">if</span> (result != <span class="keyword">null</span>) {</span><br><span class="line">								<span class="keyword">return</span> result;</span><br><span class="line">							}</span><br><span class="line">						}</span><br><span class="line">						<span class="comment">// Search on superclass</span></span><br><span class="line">						<span class="comment">// 判断了父类，CGLIB 生成的子类父类是原始类，所以就能找到原来的注解</span></span><br><span class="line">						Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line">						<span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object.class) {</span><br><span class="line">							T result = searchWithFindSemantics(superclass, annotationTypes, annotationName,</span><br><span class="line">									containerType, processor, visited, metaDepth);</span><br><span class="line">							<span class="keyword">if</span> (result != <span class="keyword">null</span>) {</span><br><span class="line">								<span class="keyword">return</span> result;</span><br><span class="line">							}</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>这样就知道了<code>@Controller</code>是如何支持代理类了，故使用<code>AnnotatedElementUtils</code>来判断注解就OK了？</p><p>当然没那么简单，这样修改后，又出现了新问题：</p><h3 id="方法级别的注解也丢了"><a href="#方法级别的注解也丢了" class="headerlink" title="方法级别的注解也丢了"></a>方法级别的注解也丢了</h3><p><code>AnnotatedElementUtils</code>只能用于类级别注解，而 CGLIB 代理类中的方法注解也丢失了</p><p>别忘了Spring中还使用了方法级别注解<code>@RequestMapping</code>，于是又翻看源码，观察上面的源码找到 Handler 之后是如何处理方法级别注解的。</p><ul><li><p><code>AbstractHandlerMethodMapping#detectHandlerMethods</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Look for handler methods in the specified handler bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>{</span><br><span class="line">		Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">				obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="comment">// 在这里获取代理子类的原始类型</span></span><br><span class="line">			Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">			Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">					(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; {</span><br><span class="line">						<span class="keyword">try</span> {</span><br><span class="line">							<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">						}</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">									userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">						}</span><br><span class="line">					});</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">				logger.trace(formatMappings(userType, methods));</span><br><span class="line">			}</span><br><span class="line">			methods.forEach((method, mapping) -&gt; {</span><br><span class="line">				Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">				registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">			});</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>ClassUtils#getUserClass(java.lang.Class&lt;?&gt;)</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the user-defined class for the given class: usually simply the given</span></span><br><span class="line"><span class="comment">	 * class, but the original class in case of a CGLIB-generated subclass.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz the class to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the user-defined class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getUserClass(Class&lt;?&gt; clazz) {</span><br><span class="line">    <span class="keyword">if</span> (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {</span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object.class) {</span><br><span class="line">            <span class="keyword">return</span> superclass;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>由<code>ClassUtils</code>的注解可知，通过这个方法可以直接获取到原始类型，Spring在这之后直接处理原始类型的方法。</p><p>那为什么不在<code>@Controller</code>中也获取原始类型呢？通过上面的源码可以看到<code>isHandler</code>的判断逻辑非常的复杂，可能考虑到某些代理子类上可能会有<code>@Controller</code>注解？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断 Spring bean 的注解时，考虑到 bean 有可能是动态代理子类，使用<code>isAnnotationPresent</code>或<code>getAnnotation</code>等方法不能获取到原始类的注解。应该使用<code>AnnotatedElementUtils</code>来判断类级别注解，对于方法级别甚至参数级别注解，应使用<code>ClassUtils</code>获取原始类的 Class 进行判断。</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Spring/" rel="tag"># Spring</a> <a href="/tags/Java/" rel="tag"># Java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%91%A8%E6%8A%A5/a647f20.html" rel="prev" title="Serverless 每周小报-20190610"><i class="fa fa-chevron-left"></i> Serverless 每周小报-20190610</a></div><div class="post-nav-item"> <a href="/%E5%BC%80%E5%8F%91/a1eba719.html" rel="next" title="Go 开发经验总结">Go 开发经验总结<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%86%8D%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">问题再现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-number">2.</span> <span class="nav-text">解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B9%9F%E4%B8%A2%E4%BA%86"><span class="nav-number">2.1.</span> <span class="nav-text">方法级别的注解也丢了</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="moeyui" src="/images/blogAvatar.jpg"><p class="site-author-name" itemprop="name">moeyui</p><div class="site-description" itemprop="description">moeyui | moeyui's blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">40</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">37</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/moeyui1" title="GitHub → https://github.com/moeyui1" rel="noopener" target="_blank"><i class="github fa-fw"></i> GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> © 2015 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa-user"></i></span> <span class="author" itemprop="copyrightHolder">moeyui</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> &amp; <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer></div><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/bundle.js"></script><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  };(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();;NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Nk9tNzbllEl79DVtRiOuLmbm-gzGzoHsz',
      appKey     : 'uPzxSfSzF95Gav6vGx2dOhCq',
      placeholder: "Just go go",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>